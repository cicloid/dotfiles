SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/vim.vim
Sourced 9 times
Total time:   0.181384
 Self time:   0.081030

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Vim 8.0 script
                            " Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
                            " Last Change:	Dec 15, 2017
                            " Version:	8.0-07
                            " URL:	http://www.drchip.org/astronaut/vim/index.html#SYNTAX_VIM
                            " Automatically generated keyword lists: {{{1
                            
                            " Quit when a syntax file was already loaded {{{2
    9              0.000045 if exists("b:current_syntax")
                              finish
                            endif
    9              0.000063 let s:keepcpo= &cpo
    9              0.000057 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    9              0.000215 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    9              0.000086 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " regular vim commands {{{2
    9              0.000976 syn keyword vimCommand contained	a  arga[dd] argu[ment] bad[d] bn[ext] breakd[el] bw[ipeout] cadde[xpr] cc cf[ile] changes cla[st] cnf[ile] comp[iler] cq[uit] cw[indow] delep dell diffg[et] dig[raphs] doau ea el[se] endt[ry] f[ile] fina[lly] foldd[oopen] go[to] ha[rdcopy] hid[e] ij[ump] isp[lit] keepa l[ist] lat lcl[ose] lex[pr] lgete[xpr] lla[st] lnf[ile] lol[der] lt[ag] lw[indow] menut[ranslate] mkv[imrc] n[ext] nmapc[lear] nore omapc[lear] pa[ckadd] perld[o] prev[ious] promptr[epl] ptj[ump] pts[elect] py[thon] pyx quita[ll] redr[aw] retu[rn] rub[y] sI sIn sal[l] sba[ll] sbp[revious] scg scripte[ncoding] setg[lobal] sgI sgn sic sim[alt] sla[st] smile so[urce] spelli[nfo] sr sri sta[g] stopi[nsert] sus[pend] sync ta[g] tabe[dit] tabn[ext] tabs te[aroff] tm[enu] to[pleft] tu[nmenu] undol[ist] up[date] vi[sual] vmapc[lear] wa[ll] winp[os] ws[verb] xmapc[lear] xprop
    9              0.000956 syn keyword vimCommand contained	ab argd[elete] as[cii] bd[elete] bo[tright] breakl[ist] cN[ext] caddf[ile] ccl[ose] cfdo chd[ir] cle[arjumps] co[py] con[tinue] cr[ewind] d[elete] deletel delm[arks] diffo[ff] dir dp earlier elsei[f] endw[hile] files fini[sh] folddoc[losed] gr[ep] helpc[lose] his[tory] il[ist] iuna[bbrev] keepalt la[st] later lcs lf[ile] lgr[ep] lli[st] lo[adview] lop[en] lua m[ove] mes mkvie[w] nb[key] noa nos[wapfile] on[ly] packl[oadall] po[p] pro ps[earch] ptl[ast] pu[t] pydo pyxdo r[ead] redraws[tatus] rew[ind] rubyd[o] sIc sIp san[dbox] sbf[irst] sbr[ewind] sci scs setl[ocal] sgc sgp sie sin sm[agic] sn[ext] sor[t] spellr[epall] srI srl star[tinsert] sts[elect] sv[iew] syncbind tab tabf[ind] tabnew tags tf[irst] tma[p] tp[revious] tunma[p] unh[ide] v  vie[w] vne[w] wh[ile] wn[ext] wundo xme xunme
    9              0.007661 syn keyword vimCommand contained	abc[lear] argdo au bel[owright] bp[revious] bro[wse] cNf[ile] cal[l] cd cfir[st] che[ckpath] clo[se] col[der] conf[irm] cs debug deletep delp diffp[atch] dj[ump] dr[op] ec em[enu] ene[w] filet fir[st] foldo[pen] grepa[dd] helpf[ind] i  imapc[lear] j[oin] keepj[umps] lad[dexpr] lb[uffer] lcscope lfdo lgrepa[dd] lmak[e] loadk lp[revious] luado ma[rk] messages mod[e] nbc[lose] noautocmd nu[mber] opt[ions] pc[lose] popu[p] prof[ile] ptN[ext] ptn[ext] pw[d] pyf[ile] pyxfile rec[over] reg[isters] ri[ght] rubyf[ile] sIe sIr sav[eas] sbl[ast] sc scl scscope sf[ind] sge sgr sig sip sm[ap] sno[magic] sp[lit] spellu[ndo] src srn startg[replace] sun[hide] sw[apname] syntime tabN[ext] tabfir[st] tabo[nly] tc[l] th[row] tmapc[lear] tr[ewind] u[ndo] unl ve[rsion] vim[grep] vs[plit] win[size] wp[revious] wv[iminfo] xmenu xunmenu
    9              0.000564 syn keyword vimCommand contained	abo[veleft] arge[dit] bN[ext] bf[irst] br[ewind] bufdo c[hange] cat[ch] cdo cg[etfile] checkt[ime] cmapc[lear] colo[rscheme] cope[n] cscope debugg[reedy] deletl dep diffpu[t] dl ds[earch] echoe[rr] en[dif] ex filetype fix[del] for gui helpg[rep] ia in ju[mps] keepp[atterns] laddb[uffer] lbo[ttom] ld[o] lfir[st] lh[elpgrep] lmapc[lear] loadkeymap lpf[ile] luafile mak[e] mk[exrc] mz[scheme] nbs[tart] noh[lsearch] o[pen] ownsyntax pe[rl] pp[op] profd[el] pta[g] ptp[revious] py3 python3 q[uit] red[o] res[ize] rightb[elow] rundo sIg sN[ext] sbN[ext] sbm[odified] scI scp se[t] sfir[st] sgi sh[ell] sign sir sme snoreme spe[llgood] spellw[rong] sre[wind] srp startr[eplace] sunme sy t  tabc[lose] tabl[ast] tabp[revious] tcld[o] tj[ump] tn[ext] try una[bbreviate] unlo[ckvar] verb[ose] vimgrepa[dd] wN[ext] winc[md] wq x[it] xnoreme xwininfo
    9              0.000645 syn keyword vimCommand contained	al[l] argg[lobal] b[uffer] bl[ast] brea[k] buffers cabc[lear] cb[uffer] ce[nter] cgetb[uffer] chi[story] cn[ext] com cp[revious] cstag delc[ommand] deletp di[splay] diffs[plit] dli[st] dsp[lit] echom[sg] endf[unction] exi[t] filt[er] fo[ld] fu[nction] gvim helpt[ags] iabc[lear] intro k  lN[ext] laddf[ile] lc[d] le[ft] lg[etfile] lhi[story] lne[xt] loc[kmarks] lr[ewind] lv[imgrep] marks mks[ession] mzf[ile] new nor ol[dfiles] p[rint] ped[it] pre[serve] promptf[ind] ptf[irst] ptr[ewind] py3do pythonx qa[ll] redi[r] ret[ab] ru[ntime] rv[iminfo] sIl sa[rgument] sb[uffer] sbn[ext] sce scr[iptnames] setf[iletype] sg sgl si sil[ent] sl[eep] smenu snoremenu spelld[ump] spr[evious] srg st[op] stj[ump] sunmenu syn tN[ext] tabd[o] tabm[ove] tabr[ewind] tclf[ile] tl[ast] tno[remap] ts[elect] undoj[oin] uns[ilent] vert[ical] viu[sage] w[rite] windo wqa[ll] xa[ll] xnoremenu y[ank]
    9              0.000325 syn keyword vimCommand contained	ar[gs] argl[ocal] ba[ll] bm[odified] breaka[dd] bun[load] cad[dbuffer] cbo[ttom] cex[pr] cgete[xpr] cl[ist] cnew[er] comc[lear] cpf[ile] cuna[bbrev] delel delf[unction] dif[fupdate] difft[his] do e[dit] echon endfo[r] exu[sage] fin[d] foldc[lose] g  h[elp] hi if is[earch] kee[pmarks] lNf[ile] lan[guage] lch[dir] lefta[bove] lgetb[uffer] ll lnew[er] lockv[ar] ls lvimgrepa[dd] mat[ch] mksp[ell] 
    9              0.000088 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    9              0.000063 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] P[rint] S  TOhtml XMLent XMLns 
                            
                            " vimOptions are caught only when contained in a vimSet {{{2
    9              0.000261 syn keyword vimOption contained	acd ambw arshape background ballooneval bg bomb bs cb ch cinoptions cms commentstring copyindent cscopepathcomp csprg cursorbind delcombine digraph eadirection emo equalprg expandtab fdls fex fileignorecase fml foldlevel formatexpr gcr go guifontset helpheight history hlsearch imactivatekey imi imstyle indentkeys isf isprint km laststatus lisp loadplugins lz mat maxmempattern mh mmp more mouses mzq number opendevice paragraphs penc pi previewheight printmbcharset pvw rdt renderoptions rl ru sbo scrollbind secure shcf shelltemp shortmess showtabline sj smd spell splitbelow ssl stl sw sxe tabpagemax tags tbs termguicolors tf title tms ts ttybuiltin tx undolevels vbs viewdir vop wd wic wildmode winheight wm wrapscan
    9              0.000239 syn keyword vimOption contained	ai anti autochdir backspace balloonexpr bh breakat bsdir cc charconvert cinw co compatible cot cscopeprg csqf cursorcolumn dex dip eb emoji errorbells exrc fdm ff filetype fmr foldlevelstart formatlistpat gd gp guifontwide helplang hk ic imaf iminsert inc indk isfname joinspaces kmp lazyredraw lispwords lpl ma matchpairs maxmemtot mis mmt mouse mouseshape mzquantum numberwidth operatorfunc paste perldll pm previewwindow printmbfont pythondll re report rlc rubydll sbr scrolljump sel shell shelltype shortname shq slm sn spellcapcheck splitright ssop stmp swapfile sxq tabstop tagstack tc termkey tgc titlelen to tsl ttyfast uc undoreload vdir viewoptions wa weirdinvert wig wildoptions winminheight wmh write
    9              0.000245 syn keyword vimOption contained	akm antialias autoindent backup bdir bin breakindent bsk ccv ci cinwords cocu complete cp cscopequickfix csre cursorline dg dir ed enc errorfile fcl fdn ffs fillchars fo foldmarker formatoptions gdefault grepformat guiheadroom hf hkmap icon imak ims include inex isi js kp lbr list lrm macatsui matchtime mco mkspellmem mod mousef mouset mzschemedll nuw opfunc pastetoggle pex pmbcs printdevice printoptions pythonthreedll readonly restorescreen rnu ruf sc scrolloff selection shellcmdflag shellxescape showbreak si sm so spellfile spr st sts swapsync syn tag tal tcldll termsize tgst titleold toolbar tsr ttym udf updatecount ve vif wak wfh wildchar wim winminwidth wmnu writeany
    9              0.000249 syn keyword vimOption contained	al ar autoread backupcopy bdlay binary breakindentopt bt cd cin clipboard cole completefunc cpo cscoperelative cst cwh dict directory edcompatible encoding errorformat fcs fdo fic fixendofline foldclose foldmethod formatprg gfm grepprg guioptions hh hkmapp iconstring imc imsearch includeexpr inf isident key langmap lcs listchars ls magic maxcombine mef ml modeline mousefocus mousetime mzschemegcdll odev osfiletype patchexpr pexpr pmbfn printencoding prompt pyx redrawtime revins ro ruler scb scrollopt selectmode shellpipe shellxquote showcmd sidescroll smartcase softtabstop spelllang sps sta su swb synmaxcol tagbsearch tb tenc terse thesaurus titlestring toolbariconsize ttimeout ttymouse udir updatetime verbose viminfo warn wfw wildcharm winaltkeys winptydll wmw writebackup
    9              0.000256 syn keyword vimOption contained	aleph arab autowrite backupdir belloff bk bri bufhidden cdpath cindent cm colorcolumn completeopt cpoptions cscopetag csto debug dictionary display ef endofline esckeys fdc fdt fileencoding fixeol foldcolumn foldminlines fp gfn gtl guipty hi hkp ignorecase imcmdline imsf incsearch infercase isk keymap langmenu linebreak lm lsp makeef maxfuncdepth menc mls modelines mousehide mp nf oft pa patchmode pfn popt printexpr pt pyxversion regexpengine ri rop rulerformat scl scs sessionoptions shellquote shiftround showfulltag sidescrolloff smartindent sol spellsuggest sr stal sua swf syntax tagcase tbi term textauto tildeop tk top ttimeoutlen ttyscroll ul ur verbosefile viminfofile wb wh wildignore window winwidth wop writedelay
    9              0.000233 syn keyword vimOption contained	allowrevins arabic autowriteall backupext beval bkc briopt buflisted cedit cink cmdheight columns concealcursor cpt cscopetagorder csverb deco diff dy efm eol et fde fen fileencodings fk foldenable foldnestmax fs gfs gtt guitablabel hid hl im imd imst inde insertmode iskeyword keymodel langnoremap lines lmap luadll makeencoding maxmapdepth menuitems mm modifiable mousem mps nrformats ofu packpath path ph pp printfont pumheight qe relativenumber rightleft rs runtimepath scr sect sft shellredir shiftwidth showmatch signcolumn smarttab sp spf srr startofline suffixes switchbuf ta taglength tbidi termbidi textmode timeout tl tpm ttm ttytype undodir ut vfile virtualedit wc whichwrap wildignorecase winfixheight wiv wrap ws
    9              0.000274 syn keyword vimOption contained	altkeymap arabicshape aw backupskip bex bl brk buftype cf cinkeys cmdwinheight com conceallevel crb cscopeverbose cuc def diffexpr ea ei ep eventignore fdi fenc fileformat fkmap foldexpr foldopen fsync gfw guicursor guitabtooltip hidden hlg imactivatefunc imdisable imstatusfunc indentexpr is isp keywordprg langremap linespace lnr lw makeprg maxmem mfd mmd modified mousemodel msm nu omnifunc para pdev pheader preserveindent printheader pvh quoteescape remap rightleftcmd rtp sb scroll sections sh shellslash shm showmode siso smc spc spl ss statusline suffixesadd sws tabline tagrelative tbis termencoding textwidth timeoutlen tm tr tty tw undofile vb vi visualbell wcm wi wildmenu winfixwidth wiw wrapmargin ww
    9              0.000108 syn keyword vimOption contained	ambiwidth ari awa balloondelay bexpr bo browsedir casemap cfu cino cmp comments confirm cryptmethod cspc cul define diffopt ead ek equalalways ex fdl fencs fileformats flp foldignore foldtext ft ghr guifont helpfile highlight hls 
                            
                            " vimOptions: These are the turn-off setting variants {{{2
    9              0.000288 syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobinary nobomb nobuflisted nocin noconfirm nocrb nocscopeverbose nocsverb nocursorbind nodeco nodiff noeb noek noendofline noerrorbells noex nofen nofixendofline nofkmap nofsync noguipty nohk nohkp noic noim noimd noinf nois nolangnoremap nolazyredraw nolinebreak nolist noloadplugins nolrm noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw norelativenumber norestorescreen nori norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx noundofile novisualbell nowarn noweirdinvert nowfw nowildignorecase nowinfixheight nowiv nowrap nowrite nowritebackup
    9              0.001101 syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa nobeval nobk nobreakindent nocf nocindent nocopyindent nocscoperelative nocsre nocuc nocursorcolumn nodelcombine nodigraph noed noemo noeol noesckeys noexpandtab nofic nofixeol nofoldenable nogd nohid nohkmap nohls noicon noimc noimdisable noinfercase nojoinspaces nolangremap nolbr nolisp nolnr nolpl nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly noremap norevins norightleft nornu nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast noudf novb nowa nowb nowfh nowic nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
    9              0.000135 syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobin nobl nobri noci nocompatible nocp nocscopetag nocst nocul nocursorline nodg noea noedcompatible noemoji noequalalways noet noexrc nofileignorecase nofk nofs nogdefault nohidden nohkmapp nohlsearch noignorecase noimcmdline noincsearch noinsertmode nojs 
                            
                            " vimOptions: These are the invertible variants {{{2
    9              0.000231 syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbinary invbomb invbuflisted invcin invconfirm invcrb invcscopeverbose invcsverb invcursorbind invdeco invdiff inveb invek invendofline inverrorbells invex invfen invfixendofline invfkmap invfsync invguipty invhk invhkp invic invim invimd invinf invis invlangnoremap invlazyredraw invlinebreak invlist invloadplugins invlrm invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invrelativenumber invrestorescreen invri invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invundofile invvisualbell invwarn invweirdinvert invwfw invwildignorecase invwinfixheight invwiv invwrap invwrite invw
    9              0.000233 syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invbeval invbk invbreakindent invcf invcindent invcopyindent invcscoperelative invcsre invcuc invcursorcolumn invdelcombine invdigraph inved invemo inveol invesckeys invexpandtab invfic invfixeol invfoldenable invgd invhid invhkmap invhls invicon invimc invimdisable invinfercase invjoinspaces invlangremap invlbr invlisp invlnr invlpl invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invremap invrevins invrightleft invrnu invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invudf invvb invwa invwb invwfh invwic invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
    9              0.000116 syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbin invbl invbri invci invcompatible invcp invcscopetag invcst invcul invcursorline invdg invea invedcompatible invemoji invequalalways invet invexrc invfileignorecase invfk invfs invgdefault invhidden invhkmapp invhlsearch invignorecase invimcmdline invincsearch invinsertmode invjs 
                            
                            " termcap codes (which can also be set) {{{2
    9              0.000255 syn keyword vimOption contained	t_8b t_AB t_al t_bc t_BE t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_EI t_F2 t_F4 t_F6 t_F8 t_fs t_IE t_k1 t_k2 t_K3 t_K4 t_K5 t_K6 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_PE t_PS t_RB t_RC t_RF t_RI t_RS t_RV t_Sb t_SC t_se t_Sf t_SH t_SI t_so t_sr t_SR t_te t_Te t_ti t_ts t_Ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_VS t_WP t_WS t_xn t_xs t_ZH t_ZR
    9              0.000094 syn keyword vimOption contained	t_8f t_AF t_AL t_BD t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EC t_F1 t_F3 t_F5 t_F7 t_F9 t_GP t_IS t_K1 t_k3 t_k4 t_k5 t_k6 t_k7 
    9              0.000060 syn match   vimOption contained	"t_%1"
    9              0.000044 syn match   vimOption contained	"t_#2"
    9              0.000047 syn match   vimOption contained	"t_#4"
    9              0.000043 syn match   vimOption contained	"t_@7"
    9              0.000046 syn match   vimOption contained	"t_*7"
    9              0.000036 syn match   vimOption contained	"t_&8"
    9              0.000038 syn match   vimOption contained	"t_%i"
    9              0.000043 syn match   vimOption contained	"t_k;"
                            
                            " unsupported settings: some were supported by vi but don't do anything in vim {{{2
                            " others have been dropped along with msdos support
    9              0.000135 syn keyword vimErrSetting contained	bioskey biosk conskey consk autoprint beautify flash graphic hardtabs mesg novice open op optimize redraw slow slowopen sourceany w300 w1200 w9600 hardtabs ht nobioskey nobiosk noconskey noconsk noautoprint nobeautify noflash nographic nohardtabs nomesg nonovice noopen noop nooptimize noredraw noslow noslowopen nosourceany now300 now1200 now9600 w1200 w300 w9600 
                            
                            " AutoCmd Events {{{2
    9              0.000028 syn case ignore
    9              0.000424 syn keyword vimAutoEvent contained	BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre CmdlineEnter CmdlineLeave CmdUndefined CmdwinEnter CmdwinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEnter TabLeave TabNew TermChanged Te
                            
                            " Highlight commonly used Groupnames {{{2
    9              0.000163 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    9              0.000387 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual VisualNOS WarningMsg WildMenu 
    9              0.000069 syn match vimHLGroup contained	"Conceal"
    9              0.000009 syn case match
                            
                            " Function Names {{{2
    9              0.000281 syn keyword vimFuncName contained	abs append argv assert_fails assert_notequal atan browsedir bufname byte2line ceil ch_close ch_getbufnr ch_logfile ch_sendexpr cindent complete_add cos cursor diff_filler eval exepath extend filter floor foldclosed foldtextresult garbagecollect getbufvar getcmdline getcompletion getfperm getline getpos gettabinfo getwinposx glob2regpat haslocaldir histget hostname input inputsave isdirectory job_getchannel job_status js_encode len line2byte log10 mapcheck matcharg matchstr mkdir nr2char pow py3eval readfile remote_expr remote_send repeat screenattr search searchpos setbufvar setline setqflist setwinvar simplify soundfold sqrt strcharpart strftime string strridx submatch synID synstack tabpagebuflist tagfiles tanh term_getattr term_getline term_getstatus term_gettty term_sendkeys term_wait test_feedinput test_null_channel test_null_list test_override timer_pause timer_stopall tr undofile values wildmenumode win_findbuf winheight winline winrestview wordcount
    9              0.000262 syn keyword vimFuncName contained	acos argc asin assert_false assert_notmatch atan2 bufexists bufnr byteidx changenr ch_close_in ch_getjob ch_open ch_sendraw clearmatches complete_check cosh deepcopy diff_hlID eventhandler exists feedkeys finddir fmod foldclosedend foreground get getchar getcmdpos getcurpos getfsize getloclist getqflist gettabvar getwinposy globpath hasmapto histnr iconv inputdialog inputsecret islocked job_info job_stop json_decode libcall lispindent luaeval match matchdelete matchstrpos mode or prevnonblank pyeval reltime remote_foreground remote_startserver resolve screenchar searchdecl server2client setcharsearch setloclist setreg sha256 sin spellbadword str2float strchars strgetchar strlen strtrans substitute synIDattr system tabpagenr taglist tempname term_getcursor term_getscrolled term_gettitle term_list term_setsize test_alloc_fail test_garbagecollect_now test_null_dict test_null_partial test_settime timer_start tolower trunc undotree virtcol winbufnr win_getid win_id2tabwin winnr w
    9              0.000349 syn keyword vimFuncName contained	add argidx assert_equal assert_inrange assert_report balloon_show buflisted bufwinid byteidxcomp char2nr ch_evalexpr ch_info ch_read ch_setoptions col confirm count delete empty executable exp filereadable findfile fnameescape foldlevel funcref getbufinfo getcharmod getcmdtype getcwd getftime getmatches getreg gettabwinvar getwinvar has histadd hlexists indent inputlist insert isnan job_setoptions join json_encode libcallnr localtime map matchadd matchend max mzeval pathshorten printf pyxeval reltimefloat remote_peek remove reverse screencol searchpair serverlist setcmdpos setmatches settabvar shellescape sinh spellsuggest str2nr strdisplaywidth stridx strpart strwidth synconcealed synIDtrans systemlist tabpagewinnr tan term_getaltscreen term_getjob term_getsize term_getttty term_scrape term_start test_autochdir test_ignore_error test_null_job test_null_string timer_info timer_stop toupper type uniq visualmode wincol win_gotoid win_id2win winrestcmd winwidth xor
    9              0.000231 syn keyword vimFuncName contained	and arglistid assert_exception assert_match assert_true browse bufloaded bufwinnr call ch_canread ch_evalraw ch_log ch_readraw ch_status complete copy cscope_connection did_filetype escape execute expand filewritable float2nr fnamemodify foldtext function getbufline getcharsearch getcmdwintype getfontname getftype getpid getregtype getwininfo glob has_key histdel hlID index inputrestore invert items job_start js_decode keys line log maparg matchaddpos matchlist min nextnonblank perleval pumvisible range reltimestr remote_read rename round screenrow searchpairpos setbufline setfperm setpos settabwinvar shiftwidth sort split 
                            
                            "--- syntax here and above generated by mkvimvim ---
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    9              0.000045 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a' 
                              com! -nargs=* VimFolda <args> fold 
                             else 
                              com! -nargs=* VimFolda <args> 
                             endif
                             if g:vimsyn_folding =~# 'f' 
                              com! -nargs=* VimFoldf <args> fold 
                             else 
                              com! -nargs=* VimFoldf <args> 
                             endif
                             if g:vimsyn_folding =~# 'l' 
                              com! -nargs=* VimFoldl <args> fold 
                             else 
                              com! -nargs=* VimFoldl <args> 
                             endif
                             if g:vimsyn_folding =~# 'm' 
                              com! -nargs=* VimFoldm <args> fold 
                             else 
                              com! -nargs=* VimFoldm <args> 
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P' 
                              com! -nargs=* VimFoldP <args> fold 
                             else 
                              com! -nargs=* VimFoldP <args> 
                             endif
                             if g:vimsyn_folding =~# 'r' 
                              com! -nargs=* VimFoldr <args> fold 
                             else 
                              com! -nargs=* VimFoldr <args> 
                             endif
                             if g:vimsyn_folding =~# 't' 
                              com! -nargs=* VimFoldt <args> fold 
                             else 
                              com! -nargs=* VimFoldt <args> 
                             endif
                            else
    9              0.000162  com! -nargs=*	VimFolda	<args>
    9              0.000053  com! -nargs=*	VimFoldf	<args>
    9              0.000043  com! -nargs=*	VimFoldl	<args>
    9              0.000054  com! -nargs=*	VimFoldm	<args>
    9              0.000041  com! -nargs=*	VimFoldp	<args>
    9              0.000042  com! -nargs=*	VimFoldP	<args>
    9              0.000042  com! -nargs=*	VimFoldr	<args>
    9              0.000042  com! -nargs=*	VimFoldt	<args>
    9              0.000011 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    9              0.000056 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    9              0.000025 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    9              0.000015 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    9              0.000018 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Variable options {{{2
    9              0.000016 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
                            else
    9              0.000037  let s:vimsyn_maxlines= 60
    9              0.000008 endif
                            
                            " Numbers {{{2
                            " =======
    9              0.000232 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    9              0.000194 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    9              0.000062 syn match vimNumber	"\<0[xX]\x\+"
    9              0.000066 syn match vimNumber	"\%(^\|[^a-zA-Z]\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    9              0.000510 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    9              0.000097 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    9              0.000075 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    9              0.000051 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    9              0.000048 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    9              0.000033 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    9              0.000158 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    9              0.000124 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    9              0.000115 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    9              0.000175 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    9              0.000036 syn keyword vimBehaveModel contained	mswin	xterm
    9              0.000043 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    9              0.000046  syn match   vimBehaveError contained	"[^ ]\+"
    9              0.000008 endif
                            
                            " Filetypes {{{2
                            " =========
    9              0.000183 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    9              0.000034 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    9              0.000044  syn match   vimFTError  contained	"\I\i*"
    9              0.000004 endif
    9              0.000038 syn keyword vimFTCmd    contained	filet[ype]
    9              0.000087 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    9              0.001624 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    9              0.000034 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    9              0.000187  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    9              0.000008 endif
    9              0.000090 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    9              0.000037 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    9              0.000130  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    9              0.000008 endif
    9              0.000039 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    9              0.000473 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    9              0.000170 syn match	vimOper	"\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    9              0.000144 syn match	vimOper	"\(\<is\>\|\<isnot\>\)[?#]\{0,2}"		skipwhite nextgroup=vimString,vimSpecFile
    9              0.000135 syn match	vimOper	"||\|&&\|[-+.]"			skipwhite nextgroup=vimString,vimSpecFile
    9              0.000098 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    9              0.000175 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    9              0.000044 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    9              0.000040  syn match	vimOperError	")"
    9              0.000006 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    9              0.000282 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    9              0.001675 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    9              0.000239 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    9              0.000053 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    9              0.000119  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    9              0.000013 endif
    9              0.000061 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    9              0.000052 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    9              0.000043 syn keyword	vimFuncKey   contained	fu[nction]
    9              0.000043 syn match	vimFuncBlank contained	"\s\+"
                            
    9              0.000068 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    9              0.000143 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    9              0.000143 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    9              0.000160 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    9              0.000137 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    9              0.000131 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    9              0.000160 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    9              0.000056 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    9              0.001333 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    9              0.000044 syn keyword	vimUserCommand	contained	com[mand]
    9              0.000205 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    9              0.000048 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    9              0.000138 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    9              0.000226 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    9              0.000213 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    9              0.000222 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    9              0.000126 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    9              0.000120 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    9              0.000124 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    9              0.000139 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    9              0.000048 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    9              0.000046  syn match	vimUserCmdError	contained	"\S\+\>"
    9              0.000008 endif
    9              0.000010 syn case ignore
    9              0.000401 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    9              0.000130 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    9              0.000156 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    9              0.000130 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    9              0.000009 syn case match
    9              0.000060 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    9              0.000116 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    9              0.000111 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    9              0.000101 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    9              0.000069 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    9              0.000050 syn match	vimEnvvar	"\$\I\i*"
    9              0.000049 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    9              0.000113 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    9              0.000043 syn match	vimPatSepErr	contained	"\\)"
    9              0.000038 syn match	vimPatSep	contained	"\\|"
    9              0.000142 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    9              0.000102 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    9              0.000044 syn match	vimNotPatSep	contained	"\\\\"
    9              0.000241 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    9              0.000118 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    9              0.000083 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    9              0.000084 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    9              0.000100 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    9              0.000136 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    9              0.000091 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    9              0.000072 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    9              0.000255 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    9              0.000137 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    9              0.000062 syn cluster	vimSubstList	add=vimCollection
    9              0.000135 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    9              0.000108 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    9              0.000092 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    9              0.000096 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    9              0.000084 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    9              0.000191 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    9              0.000225 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    9              0.000126 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    9              0.000046 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    9              0.000101 syn match	vimCollClass    contained transparent	"\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    9              0.000044 syn match	vimSubstSubstr  contained	"\\z\=\d"
    9              0.000056 syn match	vimSubstTwoBS   contained	"\\\\"
    9              0.000104 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    9              0.000045 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    9              0.000067 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    9              0.000197 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    9              0.000193 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    9              0.000189 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    9              0.000194 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    9              0.000219 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    9              0.000142 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    9              0.000047 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    9              0.000070 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    9              0.000057 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    9              0.000086 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    9              0.000045 syn match	vimRegister	'@"'
    9              0.000055 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    9              0.000095 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    9              0.000180 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    9              0.000115 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    9              0.000228 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    9              0.000060 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    9              0.000054 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    9              0.000472 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    9              0.000286 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    9              0.000146 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    9              0.000109 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    9              0.000069 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    9              0.000140 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    9              0.000205 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    9              0.000196 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent nextgroup=vimAutoCmdSpace
    9              0.000097 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    9              0.000046 syn match	vimAutoCmdSfxList	contained	"\S*"
    9              0.000120 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    9              0.000378 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    9              0.000533 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    9              0.000208 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone
    9              0.000011 syn case ignore
    9              0.000035 syn keyword	vimEchoHLNone	none
    9              0.000007 syn case match
                            
                            " Maps {{{2
                            " ====
    9              0.000145 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    9              0.000357 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    9              0.000061 syn keyword	vimMap		mapc[lear] smapc[lear]
    9              0.000252 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    9              0.000233 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    9              0.000143 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    9              0.000280 syn match	vimMapMod	contained	"\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    9              0.000176 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    9              0.000099 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    9              0.000009 syn case ignore
    9              0.000064 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    9              0.000037 syn case match
                            
                            " Menus {{{2
                            " =====
    9              0.000239 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    9              0.000281 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    9              0.000193 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    9              0.000108 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    9              0.000197 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    9              0.000198 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    9              0.000085 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    9              0.000173 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    9              0.000051 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    9              0.000018 syn case ignore
    9              0.000226 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    9              0.000206 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    9              0.000152 syn match	vimNotation	"\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"		contains=vimBracket
    9              0.000126 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1			contains=vimBracket
    9              0.000123 syn match	vimNotation	'\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    9              0.000124 syn match	vimNotation	"\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    9              0.000048 syn match	vimBracket contained	"[\\<>]"
    9              0.000009 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    9              0.000235 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    9              0.000143 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    9              0.000076 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    9              0.000075 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    9              0.000176  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)[0-9]\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    9              0.000061  syn match	vimElseIfErr	"\<else\s\+if\>"
    9              0.000058  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    9              0.000009 endif
                            
                            " Norm {{{2
                            " ====
    9              0.000083 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    9              0.000042 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    9              0.000128 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    9              0.000165 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    9              0.000038 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    9              0.000061 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    9              0.000045  syn match	vimSynError	contained	"\i\+"
    9              0.000084  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    9              0.000008 endif
    9              0.000105 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    9              0.000087 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    9              0.000107 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    9              0.000196 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    9              0.000188 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    9              0.000092 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    9              0.000113 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    9              0.000036 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    9              0.000043  syn match	vimSynCaseError	contained	"\i\+"
    9              0.000007 endif
    9              0.000042 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    9              0.000068 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    9              0.000070 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    9              0.000286 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    9              0.000110 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    9              0.000095 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    9              0.000126 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    9              0.000068 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    9              0.000094 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    9              0.000049 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    9              0.000077 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    9              0.000058 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    9              0.000146 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    9              0.000068 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    9              0.000130 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    9              0.000067 syn match	vimSynKeyOpt	contained	"\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    9              0.000066 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    9              0.000306 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    9              0.000069 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    9              0.000116 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    9              0.000097 syn match	vimSynMtchOpt	contained	"\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    9              0.000054 if has("conceal")
    9              0.000135  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    9              0.000046  syn match	vimSynMtchCchar	contained	"\S"
    9              0.000008 endif
    9              0.000067 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    9              0.000095 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    9              0.000360 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    9              0.000203 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    9              0.000077 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    9              0.000116 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    9              0.000115 syn match	vimSynRegOpt	contained	"\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    9              0.000094 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    9              0.000155 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup
    9              0.000187 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    9              0.000082 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    9              0.000094 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    9              0.000046 syn match	vimSynPatMod	contained	"lc=\d\+"
    9              0.000082 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    9              0.000076 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    9              0.000042 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    9              0.000049 syn match	vimMtchComment	contained	'"[^"]\+$'
    9              0.000060 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    9              0.000329 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    9              0.000051 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    9              0.000044  syn match	vimSyncError	contained	"\i\+"
    9              0.000014 endif
    9              0.000046 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    9              0.000064 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    9              0.000085 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    9              0.000094 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    9              0.000065 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    9              0.000107 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    9              0.000071 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    9              0.000078 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    9              0.000101 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    9              0.000029 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    9              0.000159 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    9              0.000155 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    9              0.000046 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    9              0.000052  syn match	vimHiCtermError	contained	"[^0-9]\i*"
    9              0.000008 endif
    9              0.000120 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    9              0.000043 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    9              0.000033 syn match	vimHiGroup	contained	"\i\+"
    9              0.000035 syn case ignore
    9              0.000066 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    9              0.000045 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    9              0.000009 syn case match
    9              0.000072 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    9              0.000104 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    9              0.000023 syn case ignore
    9              0.000095 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    9              0.000052 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    9              0.000007 syn case match
    9              0.000052 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    9              0.000044 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    9              0.000043 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    9              0.000421 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    9              0.000096 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    9              0.000047 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    9              0.000037  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    9              0.000016 endif
    9              0.000074 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    9              0.000130 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    9              0.000075 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    9              0.000174 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    9              0.000085 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    9              0.000077 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    9              0.000189 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    9              0.000097 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    9              0.000034 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    9              0.000101 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    9              0.000301 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    9              0.000058 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    9              0.000043 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    9              0.000144 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    9              0.000195 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    9              0.000087 syn match	vimContinue	"^\s*\\"
    9              0.000148 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    9              0.000054 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    9              0.000114 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    9              0.000047 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    9              0.000234 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    9              0.000218 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua      (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'p' : embed perl     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'P' : embed python   (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'r' : embed ruby     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 't' : embed tcl      (but only if vim supports it)
    9              0.000055 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= "lmpPr"
                            endif
                            
                            " [-- lua --] {{{3
    9              0.000261 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    9              0.000161 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    9              0.000232 if (g:vimsyn_embed =~# 'l' && has("lua")) && filereadable(s:luapath)
    9              0.000022  unlet! b:current_syntax
    9   0.016013   0.000816  exe "syn include @vimLuaScript ".s:luapath
    9              0.000211  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    9              0.000110  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
    9              0.000066  syn cluster vimFuncBodyList	add=vimLuaRegion
    9              0.000014 else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
                            endif
    9              0.000014 unlet s:luapath
                            
                            " [-- perl --] {{{3
    9              0.000223 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    9              0.000174 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    9              0.000194 if (g:vimsyn_embed =~# 'p' && has("perl")) && filereadable(s:perlpath)
    9              0.000027  unlet! b:current_syntax
    9   0.046309   0.000734  exe "syn include @vimPerlScript ".s:perlpath
    9              0.000255  VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPerlScript
    9              0.000152  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+	contains=@vimPerlScript
    9              0.000062  syn cluster vimFuncBodyList	add=vimPerlRegion
    9              0.000025 else
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
                            endif
    9              0.000023 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    9              0.000260 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    9              0.000180 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    9              0.000190 if (g:vimsyn_embed =~# 'r' && has("ruby")) && filereadable(s:rubypath)
    9              0.000019  unlet! b:current_syntax
    9   0.032582   0.000825  exe "syn include @vimRubyScript ".s:rubypath
    9              0.000183  VimFoldr syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimRubyScript
    9              0.000088  syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
    9              0.000044  syn cluster vimFuncBodyList	add=vimRubyRegion
    9              0.000008 else
                             syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
                            endif
    9              0.000016 unlet s:rubypath
                            
                            " [-- python --] {{{3
    9              0.000230 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    9              0.000176 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    9              0.000205 if g:vimsyn_embed =~# 'P' && (has("python") || has("python3")) && filereadable(s:pythonpath)
    9              0.000030  unlet! b:current_syntax
    9   0.008504   0.000679  exe "syn include @vimPythonScript ".s:pythonpath
    9              0.000168  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPythonScript
    9              0.000166  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
    9              0.000105  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(.*\)$+ end=+^\z1$+		contains=@vimPythonScript
    9              0.000110  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
    9              0.000044  syn cluster vimFuncBodyList	add=vimPythonRegion
    9              0.000006 else
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
                            endif
    9              0.000016 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    9              0.000079 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    9              0.000013  let s:trytcl= 1
    9              0.000007 endif
    9              0.000009 if s:trytcl
    9              0.000228  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    9              0.000185  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    9              0.000050  if (g:vimsyn_embed =~# 't' && has("tcl")) && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    9              0.000079   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    9              0.000049   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    9              0.000004  endif
    9              0.000024  unlet s:tclpath
    9              0.000008 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    9              0.000010 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    9              0.000204 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    9              0.000142 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    9              0.000056 if (g:vimsyn_embed =~# 'm' && has("mzscheme")) && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    9              0.000071  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    9              0.000071  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    9              0.000006 endif
    9              0.000021 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    9              0.000023 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    9              0.000057 exe "syn sync maxlines=".s:vimsyn_maxlines
    9              0.000030 syn sync linecont	"^\s\+\\"
    9              0.000064 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    9              0.000025 if !exists("skip_vim_syntax_inits")
    9              0.000048  if !exists("g:vimsyn_noerror")
    9              0.000050   hi def link vimBehaveError	vimError
    9              0.000041   hi def link vimCollClassErr	vimError
    9              0.000034   hi def link vimErrSetting	vimError
    9              0.000018   hi def link vimEmbedError	vimError
    9              0.000041   hi def link vimFTError	vimError
    9              0.000034   hi def link vimFunctionError	vimError
    9              0.000033   hi def link vimFunc         	vimError
    9              0.000037   hi def link vimHiAttribList	vimError
    9              0.000086   hi def link vimHiCtermError	vimError
    9              0.000052   hi def link vimHiKeyError	vimError
    9              0.000026   hi def link vimKeyCodeError	vimError
    9              0.000031   hi def link vimMapModErr	vimError
    9              0.000035   hi def link vimSubstFlagErr	vimError
    9              0.000043   hi def link vimSynCaseError	vimError
    9              0.000031   hi def link vimBufnrWarn	vimWarn
    9              0.000007  endif
                            
    9              0.000057  hi def link vimAbb	vimCommand
    9              0.000047  hi def link vimAddress	vimMark
    9              0.000046  hi def link vimAugroupError	vimError
    9              0.000055  hi def link vimAugroupKey	vimCommand
    9              0.000029  hi def link vimAuHighlight	vimHighlight
    9              0.000032  hi def link vimAutoCmdOpt	vimOption
    9              0.000047  hi def link vimAutoCmd	vimCommand
    9              0.000070  hi def link vimAutoEvent	Type
    9              0.000034  hi def link vimAutoSet	vimCommand
    9              0.000045  hi def link vimBehaveModel	vimBehave
    9              0.000048  hi def link vimBehave	vimCommand
    9              0.000048  hi def link vimBracket	Delimiter
    9              0.000053  hi def link vimCmplxRepeat	SpecialChar
    9              0.000061  hi def link vimCommand	Statement
    9              0.000050  hi def link vimComment	Comment
    9              0.000048  hi def link vimCommentString	vimString
    9              0.000052  hi def link vimCommentTitle	PreProc
    9              0.000058  hi def link vimCondHL	vimCommand
    9              0.000051  hi def link vimContinue	Special
    9              0.000069  hi def link vimCtrlChar	SpecialChar
    9              0.000057  hi def link vimEchoHLNone	vimGroup
    9              0.000055  hi def link vimEchoHL	vimCommand
    9              0.000057  hi def link vimElseIfErr	Error
    9              0.000084  hi def link vimElseif	vimCondHL
    9              0.000064  hi def link vimEnvvar	PreProc
    9              0.000050  hi def link vimError	Error
    9              0.000046  hi def link vimFBVar	vimVar
    9              0.000043  hi def link vimFgBgAttrib	vimHiAttrib
    9              0.000043  hi def link vimFold	Folded
    9              0.000061  hi def link vimFTCmd	vimCommand
    9              0.000042  hi def link vimFTOption	vimSynType
    9              0.000044  hi def link vimFuncKey	vimCommand
    9              0.000055  hi def link vimFuncName	Function
    9              0.000055  hi def link vimFuncSID	Special
    9              0.000067  hi def link vimFuncVar	Identifier
    9              0.000029  hi def link vimGroupAdd	vimSynOption
    9              0.000042  hi def link vimGroupName	vimGroup
    9              0.000043  hi def link vimGroupRem	vimSynOption
    9              0.000062  hi def link vimGroupSpecial	Special
    9              0.000050  hi def link vimGroup	Type
    9              0.000064  hi def link vimHiAttrib	PreProc
    9              0.000043  hi def link vimHiClear	vimHighlight
    9              0.000036  hi def link vimHiCtermFgBg	vimHiTerm
    9              0.000035  hi def link vimHiCTerm	vimHiTerm
    9              0.000045  hi def link vimHighlight	vimCommand
    9              0.000036  hi def link vimHiGroup	vimGroupName
    9              0.000049  hi def link vimHiGuiFgBg	vimHiTerm
    9              0.000034  hi def link vimHiGuiFont	vimHiTerm
    9              0.000044  hi def link vimHiGuiRgb	vimNumber
    9              0.000034  hi def link vimHiGui	vimHiTerm
    9              0.000047  hi def link vimHiNmbr	Number
    9              0.000045  hi def link vimHiStartStop	vimHiTerm
    9              0.000056  hi def link vimHiTerm	Type
    9              0.000048  hi def link vimHLGroup	vimGroup
    9              0.000038  hi def link vimHLMod	PreProc
    9              0.000101  hi def link vimInsert	vimString
    9              0.000055  hi def link vimIskSep	Delimiter
    9              0.000039  hi def link vimKeyCode	vimSpecFile
    9              0.000036  hi def link vimKeyword	Statement
    9              0.000054  hi def link vimLet	vimCommand
    9              0.000045  hi def link vimLineComment	vimComment
    9              0.000043  hi def link vimMapBang	vimCommand
    9              0.000047  hi def link vimMapModKey	vimFuncSID
    9              0.000039  hi def link vimMapMod	vimBracket
    9              0.000045  hi def link vimMap	vimCommand
    9              0.000057  hi def link vimMark	Number
    9              0.000047  hi def link vimMarkNumber	vimNumber
    9              0.000038  hi def link vimMenuMod	vimMapMod
    9              0.000039  hi def link vimMenuNameMore	vimMenuName
    9              0.000059  hi def link vimMenuName	PreProc
    9              0.000042  hi def link vimMtchComment	vimComment
    9              0.000043  hi def link vimNorm	vimCommand
    9              0.000054  hi def link vimNotation	Special
    9              0.000055  hi def link vimNotFunc	vimCommand
    9              0.000044  hi def link vimNotPatSep	vimString
    9              0.000062  hi def link vimNumber	Number
    9              0.000053  hi def link vimOperError	Error
    9              0.000050  hi def link vimOper	Operator
    9              0.000054  hi def link vimOption	PreProc
    9              0.000061  hi def link vimParenSep	Delimiter
    9              0.000047  hi def link vimPatSepErr	vimPatSep
    9              0.000042  hi def link vimPatSepR	vimPatSep
    9              0.000109  hi def link vimPatSep	SpecialChar
    9              0.000046  hi def link vimPatSepZone	vimString
    9              0.000042  hi def link vimPatSepZ	vimPatSep
    9              0.000057  hi def link vimPattern	Type
    9              0.000049  hi def link vimPlainMark	vimMark
    9              0.000099  hi def link vimPlainRegister	vimRegister
    9              0.000054  hi def link vimRegister	SpecialChar
    9              0.000072  hi def link vimScriptDelim	Comment
    9              0.000058  hi def link vimSearchDelim	Statement
    9              0.000045  hi def link vimSearch	vimString
    9              0.000052  hi def link vimSep	Delimiter
    9              0.000044  hi def link vimSetMod	vimOption
    9              0.000047  hi def link vimSetSep	Statement
    9              0.000044  hi def link vimSetString	vimString
    9              0.000063  hi def link vimSpecFile	Identifier
    9              0.000044  hi def link vimSpecFileMod	vimSpecFile
    9              0.000036  hi def link vimSpecial	Type
    9              0.000036  hi def link vimStatement	Statement
    9              0.000046  hi def link vimStringCont	vimString
    9              0.000051  hi def link vimString	String
    9              0.000045  hi def link vimSubst1	vimSubst
    9              0.000047  hi def link vimSubstDelim	Delimiter
    9              0.000057  hi def link vimSubstFlags	Special
    9              0.000052  hi def link vimSubstSubstr	SpecialChar
    9              0.000049  hi def link vimSubstTwoBS	vimString
    9              0.000058  hi def link vimSubst	vimCommand
    9              0.000090  hi def link vimSynCaseError	Error
    9              0.000054  hi def link vimSynCase	Type
    9              0.000066  hi def link vimSyncC	Type
    9              0.000058  hi def link vimSyncError	Error
    9              0.000052  hi def link vimSyncGroupName	vimGroupName
    9              0.000051  hi def link vimSyncGroup	vimGroupName
    9              0.000055  hi def link vimSyncKey	Type
    9              0.000055  hi def link vimSyncNone	Type
    9              0.000031  hi def link vimSynContains	vimSynOption
    9              0.000063  hi def link vimSynError	Error
    9              0.000049  hi def link vimSynKeyContainedin	vimSynContains
    9              0.000072  hi def link vimSynKeyOpt	vimSynOption
    9              0.000029  hi def link vimSynMtchGrp	vimSynOption
    9              0.000032  hi def link vimSynMtchOpt	vimSynOption
    9              0.000027  hi def link vimSynNextgroup	vimSynOption
    9              0.000054  hi def link vimSynNotPatRange	vimSynRegPat
    9              0.000040  hi def link vimSynOption	Special
    9              0.000042  hi def link vimSynPatRange	vimString
    9              0.000028  hi def link vimSynRegOpt	vimSynOption
    9              0.000038  hi def link vimSynRegPat	vimString
    9              0.000048  hi def link vimSynReg	Type
    9              0.000045  hi def link vimSyntax	vimCommand
    9              0.000046  hi def link vimSynType	vimSpecial
    9              0.000057  hi def link vimTodo	Todo
    9              0.000059  hi def link vimUnmap	vimMap
    9              0.000071  hi def link vimUserAttrbCmpltFunc	Special
    9              0.000035  hi def link vimUserAttrbCmplt	vimSpecial
    9              0.000054  hi def link vimUserAttrbKey	vimOption
    9              0.000031  hi def link vimUserAttrb	vimSpecial
    9              0.000049  hi def link vimUserAttrbError	Error
    9              0.000075  hi def link vimUserCmdError	Error
    9              0.000052  hi def link vimUserCommand	vimCommand
    9              0.000076  hi def link vimUserFunc	Normal
    9              0.000067  hi def link vimVar	Identifier
    9              0.000042  hi def link vimWarn	WarningMsg
    9              0.000006 endif
                            
                            " Current Syntax Variable: {{{2
    9              0.000039 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    9              0.000036 delc VimFolda
    9              0.000082 delc VimFoldf
    9              0.000018 delc VimFoldl
    9              0.000023 delc VimFoldm
    9              0.000014 delc VimFoldp
    9              0.000020 delc VimFoldP
    9              0.000014 delc VimFoldr
    9              0.000015 delc VimFoldt
    9              0.000060 let &cpo = s:keepcpo
    9              0.000016 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/lua.vim
Sourced 9 times
Total time:   0.015091
 Self time:   0.015091

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " quit when a syntax file was already loaded
    9              0.000063 if exists("b:current_syntax")
                              finish
                            endif
                            
    9              0.000072 let s:cpo_save = &cpo
    9              0.000068 set cpo&vim
                            
    9              0.000023 if !exists("lua_version")
                              " Default is lua 5.2
                              let lua_version = 5
                              let lua_subversion = 2
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
                            endif
                            
    9              0.000010 syn case match
                            
                            " syncing method
    9              0.000027 syn sync minlines=100
                            
                            " Comments
    9              0.000063 syn keyword luaTodo            contained TODO FIXME XXX
    9              0.000112 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    9              0.000018 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
                            elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    9              0.000147   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    9              0.000006 endif
                            
                            " First line may start with #!
    9              0.000060 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    9              0.000427 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    9              0.000413 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    9              0.000037 syn match  luaParenError ")"
    9              0.000042 syn match  luaBraceError "}"
    9              0.000074 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    9              0.000313 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    9              0.000265 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    9              0.000195 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    9              0.000258 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    9              0.000028 syn keyword luaElse contained else
                            
                            " do ... end
    9              0.000271 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    9              0.000336 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    9              0.000379 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    9              0.000313 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    9              0.000029 syn keyword luaIn contained in
                            
                            " other keywords
    9              0.000036 syn keyword luaStatement return local break
    9              0.000023 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    9              0.000030   syn keyword luaStatement goto
    9              0.000071   syn match luaLabel "::\I\i*::"
    9              0.000007 endif
    9              0.000056 syn keyword luaOperator and or not
    9              0.000033 syn keyword luaConstant nil
    9              0.000012 if lua_version > 4
    9              0.000032   syn keyword luaConstant true false
    9              0.000006 endif
                            
                            " Strings
    9              0.000012 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
                            elseif lua_version == 5
    9              0.000011   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
                              else
    9              0.000048     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
                                else " Lua 5.2
    9              0.000088       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    9              0.000006     endif
    9              0.000093     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    9              0.000005   endif
    9              0.000003 endif
    9              0.000157 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    9              0.000129 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    9              0.000055 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    9              0.000068 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    9              0.000107 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    9              0.000063 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    9              0.000016 if lua_version >= 5
    9              0.000018   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
                              elseif lua_subversion >= 2
    9              0.000053     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    9              0.000007   endif
    9              0.000006 endif
                            
    9              0.000044 syn keyword luaFunc assert collectgarbage dofile error next
    9              0.000082 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    9              0.000009 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
                            elseif lua_version == 5
    9              0.000048   syn keyword luaFunc getmetatable setmetatable
    9              0.000037   syn keyword luaFunc ipairs pairs
    9              0.000032   syn keyword luaFunc pcall xpcall
    9              0.000047   syn keyword luaFunc _G loadfile rawequal require
    9              0.000011   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
                              else
    9              0.000061     syn keyword luaFunc load select
    9              0.000051     syn match   luaFunc /\<package\.cpath\>/
    9              0.000058     syn match   luaFunc /\<package\.loaded\>/
    9              0.000060     syn match   luaFunc /\<package\.loadlib\>/
    9              0.000076     syn match   luaFunc /\<package\.path\>/
    9              0.000036     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
                                elseif lua_subversion == 2
    9              0.000051       syn keyword luaFunc _ENV rawlen
    9              0.000045       syn match   luaFunc /\<package\.config\>/
    9              0.000048       syn match   luaFunc /\<package\.preload\>/
    9              0.000056       syn match   luaFunc /\<package\.searchers\>/
    9              0.000069       syn match   luaFunc /\<package\.searchpath\>/
    9              0.000072       syn match   luaFunc /\<bit32\.arshift\>/
    9              0.000059       syn match   luaFunc /\<bit32\.band\>/
    9              0.000046       syn match   luaFunc /\<bit32\.bnot\>/
    9              0.000068       syn match   luaFunc /\<bit32\.bor\>/
    9              0.000054       syn match   luaFunc /\<bit32\.btest\>/
    9              0.000072       syn match   luaFunc /\<bit32\.bxor\>/
    9              0.000059       syn match   luaFunc /\<bit32\.extract\>/
    9              0.000056       syn match   luaFunc /\<bit32\.lrotate\>/
    9              0.000042       syn match   luaFunc /\<bit32\.lshift\>/
    9              0.000040       syn match   luaFunc /\<bit32\.replace\>/
    9              0.000051       syn match   luaFunc /\<bit32\.rrotate\>/
    9              0.000044       syn match   luaFunc /\<bit32\.rshift\>/
    9              0.000009     endif
    9              0.000045     syn match luaFunc /\<coroutine\.running\>/
    9              0.000006   endif
    9              0.000076   syn match   luaFunc /\<coroutine\.create\>/
    9              0.000057   syn match   luaFunc /\<coroutine\.resume\>/
    9              0.000042   syn match   luaFunc /\<coroutine\.status\>/
    9              0.000064   syn match   luaFunc /\<coroutine\.wrap\>/
    9              0.000051   syn match   luaFunc /\<coroutine\.yield\>/
    9              0.000057   syn match   luaFunc /\<string\.byte\>/
    9              0.000047   syn match   luaFunc /\<string\.char\>/
    9              0.000038   syn match   luaFunc /\<string\.dump\>/
    9              0.000086   syn match   luaFunc /\<string\.find\>/
    9              0.000047   syn match   luaFunc /\<string\.format\>/
    9              0.000049   syn match   luaFunc /\<string\.gsub\>/
    9              0.000041   syn match   luaFunc /\<string\.len\>/
    9              0.000055   syn match   luaFunc /\<string\.lower\>/
    9              0.000047   syn match   luaFunc /\<string\.rep\>/
    9              0.000044   syn match   luaFunc /\<string\.sub\>/
    9              0.000052   syn match   luaFunc /\<string\.upper\>/
    9              0.000015   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
                              else
    9              0.000047     syn match luaFunc /\<string\.gmatch\>/
    9              0.000037     syn match luaFunc /\<string\.match\>/
    9              0.000049     syn match luaFunc /\<string\.reverse\>/
    9              0.000006   endif
    9              0.000009   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
                              elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
                              elseif lua_subversion == 2
    9              0.000049     syn match luaFunc /\<table\.pack\>/
    9              0.000072     syn match luaFunc /\<table\.unpack\>/
    9              0.000008   endif
    9              0.000040   syn match   luaFunc /\<table\.concat\>/
    9              0.000040   syn match   luaFunc /\<table\.sort\>/
    9              0.000061   syn match   luaFunc /\<table\.insert\>/
    9              0.000048   syn match   luaFunc /\<table\.remove\>/
    9              0.000045   syn match   luaFunc /\<math\.abs\>/
    9              0.000039   syn match   luaFunc /\<math\.acos\>/
    9              0.000036   syn match   luaFunc /\<math\.asin\>/
    9              0.000035   syn match   luaFunc /\<math\.atan\>/
    9              0.000042   syn match   luaFunc /\<math\.atan2\>/
    9              0.000039   syn match   luaFunc /\<math\.ceil\>/
    9              0.000048   syn match   luaFunc /\<math\.sin\>/
    9              0.000038   syn match   luaFunc /\<math\.cos\>/
    9              0.000034   syn match   luaFunc /\<math\.tan\>/
    9              0.000039   syn match   luaFunc /\<math\.deg\>/
    9              0.000047   syn match   luaFunc /\<math\.exp\>/
    9              0.000055   syn match   luaFunc /\<math\.floor\>/
    9              0.000056   syn match   luaFunc /\<math\.log\>/
    9              0.000043   syn match   luaFunc /\<math\.max\>/
    9              0.000038   syn match   luaFunc /\<math\.min\>/
    9              0.000012   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
                              else
    9              0.000009     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
                                endif
    9              0.000037     syn match luaFunc /\<math\.huge\>/
    9              0.000079     syn match luaFunc /\<math\.fmod\>/
    9              0.000047     syn match luaFunc /\<math\.modf\>/
    9              0.000055     syn match luaFunc /\<math\.cosh\>/
    9              0.000073     syn match luaFunc /\<math\.sinh\>/
    9              0.000036     syn match luaFunc /\<math\.tanh\>/
    9              0.000008   endif
    9              0.000035   syn match   luaFunc /\<math\.pow\>/
    9              0.000047   syn match   luaFunc /\<math\.rad\>/
    9              0.000051   syn match   luaFunc /\<math\.sqrt\>/
    9              0.000043   syn match   luaFunc /\<math\.frexp\>/
    9              0.000045   syn match   luaFunc /\<math\.ldexp\>/
    9              0.000046   syn match   luaFunc /\<math\.random\>/
    9              0.000065   syn match   luaFunc /\<math\.randomseed\>/
    9              0.000048   syn match   luaFunc /\<math\.pi\>/
    9              0.000038   syn match   luaFunc /\<io\.close\>/
    9              0.000034   syn match   luaFunc /\<io\.flush\>/
    9              0.000041   syn match   luaFunc /\<io\.input\>/
    9              0.000042   syn match   luaFunc /\<io\.lines\>/
    9              0.000042   syn match   luaFunc /\<io\.open\>/
    9              0.000049   syn match   luaFunc /\<io\.output\>/
    9              0.000041   syn match   luaFunc /\<io\.popen\>/
    9              0.000049   syn match   luaFunc /\<io\.read\>/
    9              0.000038   syn match   luaFunc /\<io\.stderr\>/
    9              0.000044   syn match   luaFunc /\<io\.stdin\>/
    9              0.000040   syn match   luaFunc /\<io\.stdout\>/
    9              0.000043   syn match   luaFunc /\<io\.tmpfile\>/
    9              0.000034   syn match   luaFunc /\<io\.type\>/
    9              0.000042   syn match   luaFunc /\<io\.write\>/
    9              0.000036   syn match   luaFunc /\<os\.clock\>/
    9              0.000040   syn match   luaFunc /\<os\.date\>/
    9              0.000045   syn match   luaFunc /\<os\.difftime\>/
    9              0.000053   syn match   luaFunc /\<os\.execute\>/
    9              0.000038   syn match   luaFunc /\<os\.exit\>/
    9              0.000040   syn match   luaFunc /\<os\.getenv\>/
    9              0.000037   syn match   luaFunc /\<os\.remove\>/
    9              0.000070   syn match   luaFunc /\<os\.rename\>/
    9              0.000047   syn match   luaFunc /\<os\.setlocale\>/
    9              0.000039   syn match   luaFunc /\<os\.time\>/
    9              0.000042   syn match   luaFunc /\<os\.tmpname\>/
    9              0.000049   syn match   luaFunc /\<debug\.debug\>/
    9              0.000052   syn match   luaFunc /\<debug\.gethook\>/
    9              0.000042   syn match   luaFunc /\<debug\.getinfo\>/
    9              0.000087   syn match   luaFunc /\<debug\.getlocal\>/
    9              0.000048   syn match   luaFunc /\<debug\.getupvalue\>/
    9              0.000055   syn match   luaFunc /\<debug\.setlocal\>/
    9              0.000039   syn match   luaFunc /\<debug\.setupvalue\>/
    9              0.000067   syn match   luaFunc /\<debug\.sethook\>/
    9              0.000051   syn match   luaFunc /\<debug\.traceback\>/
    9              0.000014   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
                              elseif lua_subversion == 2
    9              0.000053     syn match luaFunc /\<debug\.getmetatable\>/
    9              0.000049     syn match luaFunc /\<debug\.setmetatable\>/
    9              0.000051     syn match luaFunc /\<debug\.getregistry\>/
    9              0.000051     syn match luaFunc /\<debug\.getuservalue\>/
    9              0.000040     syn match luaFunc /\<debug\.setuservalue\>/
    9              0.000045     syn match luaFunc /\<debug\.upvalueid\>/
    9              0.000057     syn match luaFunc /\<debug\.upvaluejoin\>/
    9              0.000007   endif
    9              0.000008 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    9              0.000076 hi def link luaStatement		Statement
    9              0.000052 hi def link luaRepeat		Repeat
    9              0.000046 hi def link luaFor			Repeat
    9              0.000053 hi def link luaString		String
    9              0.000057 hi def link luaString2		String
    9              0.000074 hi def link luaNumber		Number
    9              0.000064 hi def link luaOperator		Operator
    9              0.000046 hi def link luaIn			Operator
    9              0.000049 hi def link luaConstant		Constant
    9              0.000048 hi def link luaCond		Conditional
    9              0.000047 hi def link luaElse		Conditional
    9              0.000046 hi def link luaFunction		Function
    9              0.000048 hi def link luaComment		Comment
    9              0.000048 hi def link luaTodo		Todo
    9              0.000057 hi def link luaTable		Structure
    9              0.000047 hi def link luaError		Error
    9              0.000055 hi def link luaParenError		Error
    9              0.000069 hi def link luaBraceError		Error
    9              0.000048 hi def link luaSpecial		SpecialChar
    9              0.000049 hi def link luaFunc		Identifier
    9              0.000044 hi def link luaLabel		Label
                            
                            
    9              0.000022 let b:current_syntax = "lua"
                            
    9              0.000062 let &cpo = s:cpo_save
    9              0.000042 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/perl.vim
Sourced 9 times
Total time:   0.045486
 Self time:   0.039512

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl 5
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Homepage:      http://github.com/vim-perl/vim-perl/tree/master
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2017-09-12
                            " Contributors:  Andy Lester <andy@petdance.com>
                            "                Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
                            "                Lukas Mai <l.mai.web.de>
                            "                Nick Hibma <nick@van-laarhoven.org>
                            "                Sonia Heimann <niania@netsurf.org>
                            "                Rob Hoelz <rob@hoelz.ro>
                            "                and many others.
                            "
                            " Please download the most recent version first, before mailing
                            " any comments.
                            "
                            " The following parameters are available for tuning the
                            " perl syntax highlighting, with defaults given:
                            "
                            " let perl_include_pod = 1
                            " unlet perl_no_scope_in_variables
                            " unlet perl_no_extended_vars
                            " unlet perl_string_as_statement
                            " unlet perl_no_sync_on_sub
                            " unlet perl_no_sync_on_global_var
                            " let perl_sync_dist = 100
                            " unlet perl_fold
                            " unlet perl_fold_blocks
                            " unlet perl_nofold_packages
                            " unlet perl_nofold_subs
                            " unlet perl_fold_anonymous_subs
                            " unlet perl_no_subprototype_error
                            
    9              0.000064 if exists("b:current_syntax")
                              finish
                            endif
                            
    9              0.000055 let s:cpo_save = &cpo
    9              0.000051 set cpo&vim
                            
                            " POD starts with ^=<word> and ends with ^=cut
                            
    9              0.000063 if !exists("perl_include_pod") || perl_include_pod == 1
                              " Include a while extra syntax file
    9   0.013994   0.008020   syn include @Pod syntax/pod.vim
    9              0.000019   unlet b:current_syntax
    9              0.000023   if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend fold extend
                                syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend fold extend
                              else
    9              0.000099     syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend
    9              0.000097     syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend
    9              0.000007   endif
    9              0.000006 else
                              " Use only the bare minimum of rules
                              if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" fold
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut"
                              endif
                            endif
                            
                            
    9              0.000022 syn cluster perlTop		contains=TOP
                            
    9              0.000059 syn region perlBraces start="{" end="}" transparent extend
                            
                            " All keywords
                            "
    9              0.000073 syn match perlConditional		"\<\%(if\|elsif\|unless\|given\|when\|default\)\>"
    9              0.000096 syn match perlConditional		"\<else\%(\%(\_s\*if\>\)\|\>\)" contains=perlElseIfError skipwhite skipnl skipempty
    9              0.000146 syn match perlRepeat			"\<\%(while\|for\%(each\)\=\|do\|until\|continue\)\>"
    9              0.000124 syn match perlOperator			"\<\%(defined\|undef\|eq\|ne\|[gl][et]\|cmp\|not\|and\|or\|xor\|not\|bless\|ref\|do\)\>"
                            " for some reason, adding this as the nextgroup for perlControl fixes BEGIN
                            " folding issues...
    9              0.000072 syn match perlFakeGroup 		"" contained
    9              0.000094 syn match perlControl			"\<\%(BEGIN\|CHECK\|INIT\|END\|UNITCHECK\)\>\_s*" nextgroup=perlFakeGroup
                            
    9              0.000048 syn match perlStatementStorage		"\<\%(my\|our\|local\|state\)\>"
    9              0.000050 syn match perlStatementControl		"\<\%(return\|last\|next\|redo\|goto\|break\)\>"
    9              0.000078 syn match perlStatementScalar		"\<\%(chom\=p\|chr\|crypt\|r\=index\|lc\%(first\)\=\|length\|ord\|pack\|sprintf\|substr\|fc\|uc\%(first\)\=\)\>"
    9              0.000056 syn match perlStatementRegexp		"\<\%(pos\|quotemeta\|split\|study\)\>"
    9              0.000069 syn match perlStatementNumeric		"\<\%(abs\|atan2\|cos\|exp\|hex\|int\|log\|oct\|rand\|sin\|sqrt\|srand\)\>"
    9              0.000062 syn match perlStatementList		"\<\%(splice\|unshift\|shift\|push\|pop\|join\|reverse\|grep\|map\|sort\|unpack\)\>"
    9              0.000054 syn match perlStatementHash		"\<\%(delete\|each\|exists\|keys\|values\)\>"
    9              0.000057 syn match perlStatementIOfunc		"\<\%(syscall\|dbmopen\|dbmclose\)\>"
    9              0.000127 syn match perlStatementFiledesc		"\<\%(binmode\|close\%(dir\)\=\|eof\|fileno\|getc\|lstat\|printf\=\|read\%(dir\|line\|pipe\)\|rewinddir\|say\|select\|stat\|tell\%(dir\)\=\|write\)\>" nextgroup=perlFiledescStatementNocomma skipwhite
    9              0.000115 syn match perlStatementFiledesc		"\<\%(fcntl\|flock\|ioctl\|open\%(dir\)\=\|read\|seek\%(dir\)\=\|sys\%(open\|read\|seek\|write\)\|truncate\)\>" nextgroup=perlFiledescStatementComma skipwhite
    9              0.000037 syn match perlStatementVector		"\<vec\>"
    9              0.000102 syn match perlStatementFiles		"\<\%(ch\%(dir\|mod\|own\|root\)\|glob\|link\|mkdir\|readlink\|rename\|rmdir\|symlink\|umask\|unlink\|utime\)\>"
    9              0.000055 syn match perlStatementFiles		"-[rwxoRWXOezsfdlpSbctugkTBMAC]\>"
    9              0.000060 syn match perlStatementFlow		"\<\%(caller\|die\|dump\|eval\|exit\|wantarray\|evalbytes\)\>"
    9              0.000050 syn match perlStatementInclude		"\<\%(require\|import\|unimport\)\>"
    9              0.000221 syn match perlStatementInclude		"\<\%(use\|no\)\s\+\%(\%(attributes\|attrs\|autodie\|autouse\|parent\|base\|big\%(int\|num\|rat\)\|blib\|bytes\|charnames\|constant\|diagnostics\|encoding\%(::warnings\)\=\|feature\|fields\|filetest\|if\|integer\|less\|lib\|locale\|mro\|open\|ops\|overload\|overloading\|re\|sigtrap\|sort\|strict\|subs\|threads\%(::shared\)\=\|utf8\|vars\|version\|vmsish\|warnings\%(::register\)\=\)\>\)\="
    9              0.000251 syn match perlStatementProc		"\<\%(alarm\|exec\|fork\|get\%(pgrp\|ppid\|priority\)\|kill\|pipe\|set\%(pgrp\|priority\)\|sleep\|system\|times\|wait\%(pid\)\=\)\>"
    9              0.000105 syn match perlStatementSocket		"\<\%(accept\|bind\|connect\|get\%(peername\|sock\%(name\|opt\)\)\|listen\|recv\|send\|setsockopt\|shutdown\|socket\%(pair\)\=\)\>"
    9              0.000072 syn match perlStatementIPC		"\<\%(msg\%(ctl\|get\|rcv\|snd\)\|sem\%(ctl\|get\|op\)\|shm\%(ctl\|get\|read\|write\)\)\>"
    9              0.000096 syn match perlStatementNetwork		"\<\%(\%(end\|[gs]et\)\%(host\|net\|proto\|serv\)ent\|get\%(\%(host\|net\)by\%(addr\|name\)\|protoby\%(name\|number\)\|servby\%(name\|port\)\)\)\>"
    9              0.000068 syn match perlStatementPword		"\<\%(get\%(pw\%(uid\|nam\)\|gr\%(gid\|nam\)\|login\)\)\|\%(end\|[gs]et\)\%(pw\|gr\)ent\>"
    9              0.000054 syn match perlStatementTime		"\<\%(gmtime\|localtime\|time\)\>"
                            
    9              0.000075 syn match perlStatementMisc		"\<\%(warn\|format\|formline\|reset\|scalar\|prototype\|lock\|tied\=\|untie\)\>"
                            
    9              0.000065 syn keyword perlTodo			TODO TODO: TBD TBD: FIXME FIXME: XXX XXX: NOTE NOTE: contained
                            
    9              0.000124 syn region perlStatementIndirObjWrap   matchgroup=perlStatementIndirObj start="\%(\<\%(map\|grep\|sort\|printf\=\|say\|system\|exec\)\>\s*\)\@<={" end="}" transparent extend
                            
    9              0.000068 syn match perlLabel      "^\s*\h\w*\s*::\@!\%(\<v\d\+\s*:\)\@<!"
                            
                            " Perl Identifiers.
                            "
                            " Should be cleaned up to better handle identifiers in particular situations
                            " (in hash keys for example)
                            "
                            " Plain identifiers: $foo, @foo, $#foo, %foo, &foo and dereferences $$foo, @$foo, etc.
                            " We do not process complex things such as @{${"foo"}}. Too complicated, and
                            " too slow. And what is after the -> is *not* considered as part of the
                            " variable - there again, too complicated and too slow.
                            
                            " Special variables first ($^A, ...) and ($|, $', ...)
    9              0.000072 syn match  perlVarPlain		 "$^[ACDEFHILMNOPRSTVWX]\="
    9              0.000058 syn match  perlVarPlain		 "$[\\\"\[\]'&`+*.,;=%~!?@#$<>(-]"
    9              0.000036 syn match  perlVarPlain		 "@[-+]"
    9              0.000043 syn match  perlVarPlain		 "$\%(0\|[1-9]\d*\)"
                            " Same as above, but avoids confusion in $::foo (equivalent to $main::foo)
    9              0.000038 syn match  perlVarPlain		 "$::\@!"
                            " These variables are not recognized within matches.
    9              0.000044 syn match  perlVarNotInMatches	 "$[|)]"
                            " This variable is not recognized within matches delimited by m//.
    9              0.000039 syn match  perlVarSlash		 "$/"
                            
                            " And plain identifiers
    9              0.000107 syn match  perlPackageRef	 "[$@#%*&]\%(\%(::\|'\)\=\I\i*\%(\%(::\|'\)\I\i*\)*\)\=\%(::\|'\)\I"ms=s+1,me=e-1 contained
                            
                            " To not highlight packages in variables as a scope reference - i.e. in
                            " $pack::var, pack:: is a scope, just set "perl_no_scope_in_variables"
                            " If you don't want complex things like @{${"foo"}} to be processed,
                            " just set the variable "perl_no_extended_vars"...
                            
    9              0.000037 if !exists("perl_no_scope_in_variables")
    9              0.000217   syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    9              0.000229   syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    9              0.000222   syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    9              0.000010 else
                              syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                              syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                              syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                            endif
                            
    9              0.000072 syn match  perlVarPlain2	 "%[-+]"
                            
    9              0.000035 if !exists("perl_no_extended_vars")
    9              0.000734   syn cluster perlExpr		contains=perlStatementIndirObjWrap,perlStatementScalar,perlStatementRegexp,perlStatementNumeric,perlStatementList,perlStatementHash,perlStatementFiles,perlStatementTime,perlStatementMisc,perlVarPlain,perlVarPlain2,perlVarNotInMatches,perlVarSlash,perlVarBlock,perlVarBlock2,perlShellCommand,perlFloat,perlNumber,perlStringUnexpanded,perlString,perlQQ,perlArrow,perlBraces
    9              0.000209   syn region perlArrow		matchgroup=perlArrow start="->\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    9              0.000204   syn region perlArrow		matchgroup=perlArrow start="->\s*\[" end="\]" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    9              0.000187   syn region perlArrow		matchgroup=perlArrow start="->\s*{" end="}" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    9              0.000203   syn match  perlArrow		"->\s*{\s*\I\i*\s*}" contains=perlVarSimpleMemberName nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    9              0.000199   syn region perlArrow		matchgroup=perlArrow start="->\s*\$*\I\i*\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    9              0.000275   syn region perlVarBlock	matchgroup=perlVarPlain start="\%($#\|[$@]\)\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000208   syn region perlVarBlock2	matchgroup=perlVarPlain start="[%&*]\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000160   syn match  perlVarPlain2	"[%&*]\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000170   syn match  perlVarPlain	"\%(\$#\|[@$]\)\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000207   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\={" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000173   syn match  perlVarSimpleMember	"\%(->\)\={\s*\I\i*\s*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contains=perlVarSimpleMemberName contained extend
    9              0.000079   syn match  perlVarSimpleMemberName	"\I\i*" contained
    9              0.000194   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\=\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    9              0.000130   syn match perlPackageConst	"__PACKAGE__" nextgroup=perlMethod,perlPostDeref
    9              0.000145   syn match  perlMethod		"->\$*\I\i*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    9              0.000157   syn match  perlPostDeref	"->\%($#\|[$@%&*]\)\*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    9              0.000185   syn region  perlPostDeref	start="->\%($#\|[$@%&*]\)\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    9              0.000208   syn region  perlPostDeref	matchgroup=perlPostDeref start="->\%($#\|[$@%&*]\){" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    9              0.000016 endif
                            
                            " File Descriptors
    9              0.000047 syn match  perlFiledescRead	"<\h\w*>"
                            
    9              0.000071 syn match  perlFiledescStatementComma	"(\=\s*\<\u\w*\>\s*,"me=e-1 transparent contained contains=perlFiledescStatement
    9              0.000087 syn match  perlFiledescStatementNocomma "(\=\s*\<\u\w*\>\s*[^, \t]"me=e-1 transparent contained contains=perlFiledescStatement
                            
    9              0.000035 syn match  perlFiledescStatement	"\<\u\w*\>" contained
                            
                            " Special characters in strings and matches
    9              0.000073 syn match  perlSpecialString	"\\\%(\o\{1,3}\|x\%({\x\+}\|\x\{1,2}\)\|c.\|[^cx]\)" contained extend
    9              0.000059 syn match  perlSpecialStringU2	"\\." extend contained contains=NONE
    9              0.000030 syn match  perlSpecialStringU	"\\\\" contained
    9              0.000038 syn match  perlSpecialMatch	"\\[1-9]" contained extend
    9              0.000054 syn match  perlSpecialMatch	"\\g\%(\d\+\|{\%(-\=\d\+\|\h\w*\)}\)" contained
    9              0.000039 syn match  perlSpecialMatch	"\\k\%(<\h\w*>\|'\h\w*'\)" contained
    9              0.000037 syn match  perlSpecialMatch	"{\d\+\%(,\%(\d\+\)\=\)\=}" contained
    9              0.000044 syn match  perlSpecialMatch	"\[[]-]\=[^\[\]]*[]-]\=\]" contained extend
    9              0.000035 syn match  perlSpecialMatch	"[+*()?.]" contained
    9              0.000045 syn match  perlSpecialMatch	"(?[#:=!]" contained
    9              0.000053 syn match  perlSpecialMatch	"(?[impsx]*\%(-[imsx]\+\)\=)" contained
    9              0.000039 syn match  perlSpecialMatch	"(?\%([-+]\=\d\+\|R\))" contained
    9              0.000074 syn match  perlSpecialMatch	"(?\%(&\|P[>=]\)\h\w*)" contained
    9              0.000068 syn match  perlSpecialMatch	"(\*\%(\%(PRUNE\|SKIP\|THEN\)\%(:[^)]*\)\=\|\%(MARK\|\):[^)]*\|COMMIT\|F\%(AIL\)\=\|ACCEPT\))" contained
                            
                            " Possible errors
                            "
                            " Highlight lines with only whitespace (only in blank delimited here documents) as errors
    9              0.000042 syn match  perlNotEmptyLine	"^\s\+$" contained
                            " Highlight "} else if (...) {", it should be "} else { if (...) { " or "} elsif (...) {"
    9              0.000082 syn match perlElseIfError	"else\_s*if" containedin=perlConditional
    9              0.000075 syn keyword perlElseIfError	elseif containedin=perlConditional
                            
                            " Variable interpolation
                            "
                            " These items are interpolated inside "" strings and similar constructs.
    9              0.000157 syn cluster perlInterpDQ	contains=perlSpecialString,perlVarPlain,perlVarNotInMatches,perlVarSlash,perlVarBlock
                            " These items are interpolated inside '' strings and similar constructs.
    9              0.000066 syn cluster perlInterpSQ	contains=perlSpecialStringU,perlSpecialStringU2
                            " These items are interpolated inside m// matches and s/// substitutions.
    9              0.000114 syn cluster perlInterpSlash	contains=perlSpecialString,perlSpecialMatch,perlVarPlain,perlVarBlock
                            " These items are interpolated inside m## matches and s### substitutions.
    9              0.000049 syn cluster perlInterpMatch	contains=@perlInterpSlash,perlVarSlash
                            
                            " Shell commands
    9              0.000090 syn region  perlShellCommand	matchgroup=perlMatchStartEnd start="`" end="`" contains=@perlInterpDQ keepend
                            
                            " Constants
                            "
                            " Numbers
    9              0.000111 syn match  perlNumber	"\<\%(0\%(x\x[[:xdigit:]_]*\|b[01][01_]*\|\o[0-7_]*\|\)\|[1-9][[:digit:]_]*\)\>"
    9              0.000078 syn match  perlFloat	"\<\d[[:digit:]_]*[eE][\-+]\=\d\+"
    9              0.000086 syn match  perlFloat	"\<\d[[:digit:]_]*\.[[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
    9              0.000047 syn match  perlFloat    "\.[[:digit:]][[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
                            
    9              0.000129 syn match  perlString	"\<\%(v\d\+\%(\.\d\+\)*\|\d\+\%(\.\d\+\)\{2,}\)\>" contains=perlVStringV
    9              0.000086 syn match  perlVStringV	"\<v" contained
                            
                            
    9              0.000083 syn region perlParensSQ		start=+(+ end=+)+ extend contained contains=perlParensSQ,@perlInterpSQ keepend
    9              0.000079 syn region perlBracketsSQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsSQ,@perlInterpSQ keepend
    9              0.000102 syn region perlBracesSQ		start=+{+ end=+}+ extend contained contains=perlBracesSQ,@perlInterpSQ keepend
    9              0.000106 syn region perlAnglesSQ		start=+<+ end=+>+ extend contained contains=perlAnglesSQ,@perlInterpSQ keepend
                            
    9              0.000086 syn region perlParensDQ		start=+(+ end=+)+ extend contained contains=perlParensDQ,@perlInterpDQ keepend
    9              0.000114 syn region perlBracketsDQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsDQ,@perlInterpDQ keepend
    9              0.000076 syn region perlBracesDQ		start=+{+ end=+}+ extend contained contains=perlBracesDQ,@perlInterpDQ keepend
    9              0.000086 syn region perlAnglesDQ		start=+<+ end=+>+ extend contained contains=perlAnglesDQ,@perlInterpDQ keepend
                            
                            
                            " Simple version of searches and matches
    9              0.000128 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1[msixpodualgcn]*+ contains=@perlInterpMatch keepend extend
    9              0.000119 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m#+ end=+#[msixpodualgcn]*+ contains=@perlInterpMatch keepend extend
    9              0.000099 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*'+ end=+'[msixpodualgcn]*+ contains=@perlInterpSQ keepend extend
    9              0.000108 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*/+ end=+/[msixpodualgcn]*+ contains=@perlInterpSlash keepend extend
    9              0.000115 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*(+ end=+)[msixpodualgcn]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
    9              0.000130 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*{+ end=+}[msixpodualgcn]*+ contains=@perlInterpMatch,perlBracesDQ extend
    9              0.000118 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*<+ end=+>[msixpodualgcn]*+ contains=@perlInterpMatch,perlAnglesDQ keepend extend
    9              0.000121 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*\[+ end=+\][msixpodualgcn]*+ contains=@perlInterpMatch,perlBracketsDQ keepend extend
                            
                            " Below some hacks to recognise the // variant. This is virtually impossible to catch in all
                            " cases as the / is used in so many other ways, but these should be the most obvious ones.
    9              0.000238 syn region perlMatch	matchgroup=perlMatchStartEnd start="\%([$@%&*]\@<!\%(\<split\|\<while\|\<if\|\<unless\|\.\.\|[-+*!~(\[{=]\)\s*\)\@<=/\%(/=\)\@!" start=+^/\%(/=\)\@!+ start=+\s\@<=/\%(/=\)\@![^[:space:][:digit:]$@%=]\@=\%(/\_s*\%([([{$@%&*[:digit:]"'`]\|\_s\w\|[[:upper:]_abd-fhjklnqrt-wyz]\)\)\@!+ skip=+\\/+ end=+/[msixpodualgcn]*+ contains=@perlInterpSlash extend
                            
                            
                            " Substitutions
                            " perlMatch is the first part, perlSubstitution* is the substitution part
    9              0.000126 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    9              0.000164 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*'+  end=+'+me=e-1 contains=@perlInterpSQ nextgroup=perlSubstitutionSQ keepend extend
    9              0.000160 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*/+  end=+/+me=e-1 contains=@perlInterpSlash nextgroup=perlSubstitutionGQQ keepend extend
    9              0.000110 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s#+  end=+#+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    9              0.000147 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    9              0.000158 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    9              0.000139 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    9              0.000180 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    9              0.000128 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]'([{<]\)+ end=+\z1[msixpodualgcern]*+ keepend contained contains=@perlInterpDQ extend
    9              0.000100 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlParensDQ keepend extend
    9              0.000144 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][msixpodualgcern]*+ contained contains=@perlInterpDQ,perlBracketsDQ keepend extend
    9              0.000110 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlBracesDQ keepend extend extend
    9              0.000138 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlAnglesDQ keepend extend
    9              0.000092 syn region perlSubstitutionSQ		matchgroup=perlMatchStartEnd start=+'+  end=+'[msixpodualgcern]*+ contained contains=@perlInterpSQ keepend extend
                            
                            " Translations
                            " perlMatch is the first part, perlTranslation* is the second, translator part.
    9              0.000130 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\>\s*\z([^[:space:]([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    9              0.000108 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)#+ end=+#+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    9              0.000131 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    9              0.000229 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    9              0.000131 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    9              0.000188 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    9              0.000084 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]([{<]\)+ end=+\z1[cdsr]*+ contained
    9              0.000103 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[cdsr]*+ contains=perlParensSQ contained
    9              0.000177 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][cdsr]*+ contains=perlBracketsSQ contained
    9              0.000094 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[cdsr]*+ contains=perlBracesSQ contained
    9              0.000091 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[cdsr]*+ contains=perlAnglesSQ contained
                            
                            
                            " Strings and q, qq, qw and qr expressions
                            
    9              0.000082 syn region perlStringUnexpanded	matchgroup=perlStringStartEnd start="'" end="'" contains=@perlInterpSQ keepend extend
    9              0.000120 syn region perlString		matchgroup=perlStringStartEnd start=+"+  end=+"+ contains=@perlInterpDQ keepend extend
    9              0.000173 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpSQ keepend extend
    9              0.000078 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q#+ end=+#+ contains=@perlInterpSQ keepend extend
    9              0.000113 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    9              0.000120 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    9              0.000104 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    9              0.000119 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    9              0.000095 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpDQ keepend extend
    9              0.000088 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]#+ end=+#+ contains=@perlInterpDQ keepend extend
    9              0.000103 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*(+ end=+)+ contains=@perlInterpDQ,perlParensDQ keepend extend
    9              0.000120 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*\[+ end=+\]+ contains=@perlInterpDQ,perlBracketsDQ keepend extend
    9              0.000144 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*{+ end=+}+ contains=@perlInterpDQ,perlBracesDQ keepend extend
    9              0.000105 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*<+ end=+>+ contains=@perlInterpDQ,perlAnglesDQ keepend extend
                            
    9              0.000107 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\z([^[:space:]#([{<]\)+  end=+\z1+ contains=@perlInterpSQ keepend extend
    9              0.000101 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw#+  end=+#+ contains=@perlInterpSQ keepend extend
    9              0.000119 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*(+  end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    9              0.000112 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\[+  end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    9              0.000112 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*{+  end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    9              0.000138 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*<+  end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    9              0.000096 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\>\s*\z([^[:space:]#([{<'/]\)+  end=+\z1[imosxdual]*+ contains=@perlInterpMatch keepend extend
    9              0.000091 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*/+  end=+/[imosxdual]*+ contains=@perlInterpSlash keepend extend
    9              0.000104 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr#+  end=+#[imosxdual]*+ contains=@perlInterpMatch keepend extend
    9              0.000090 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*'+  end=+'[imosxdual]*+ contains=@perlInterpSQ keepend extend
    9              0.000125 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*(+  end=+)[imosxdual]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
                            
                            " A special case for qr{}, qr<> and qr[] which allows for comments and extra whitespace in the pattern
    9              0.000141 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*{+  end=+}[imosxdual]*+ contains=@perlInterpMatch,perlBracesDQ,perlComment keepend extend
    9              0.000166 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*<+  end=+>[imosxdual]*+ contains=@perlInterpMatch,perlAnglesDQ,perlComment keepend extend
    9              0.000164 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*\[+  end=+\][imosxdual]*+ contains=@perlInterpMatch,perlBracketsDQ,perlComment keepend extend
                            
                            " Constructs such as print <<EOF [...] EOF, 'here' documents
                            "
                            " XXX Any statements after the identifier are in perlString colour (i.e.
                            " 'if $a' in 'print <<EOF if $a'). This is almost impossible to get right it
                            " seems due to the 'auto-extending nature' of regions.
    9              0.000124 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\z(\I\i*\)+  end=+$+     contains=@perlTop oneline
    9              0.000096 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ end=+$+ contains=@perlTop oneline
    9              0.000092 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ end=+$+ contains=@perlTop oneline
    9              0.000093 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*""+       end=+$+     contains=@perlTop oneline
    9              0.000093 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*''+       end=+$+     contains=@perlTop oneline
    9              0.000037 if exists("perl_fold")
                              syn region perlHereDoc	start=+<<\z(\I\i*\)+ matchgroup=perlStringStartEnd      end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*""+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*''+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL fold extend
                            else
    9              0.000106   syn region perlHereDoc	start=+<<\z(\I\i*\)+ matchgroup=perlStringStartEnd      end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    9              0.000107   syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    9              0.000109   syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    9              0.000123   syn region perlHereDoc	start=+<<\s*""+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    9              0.000157   syn region perlHereDoc	start=+<<\s*''+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    9              0.000095   syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL
    9              0.000008 endif
                            
                            
                            " Class declarations
                            "
    9              0.000086 syn match   perlPackageDecl		"\<package\s\+\%(\h\|::\)\%(\w\|::\)*" contains=perlStatementPackage
    9              0.000029 syn keyword perlStatementPackage	package contained
                            
                            " Functions
                            "       sub [name] [(prototype)] {
                            "
    9              0.000043 syn match perlSubError "[^[:space:];{#]" contained
    9              0.000063 syn match perlSubAttributesCont "\h\w*\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained
    9              0.000125 syn region perlSubAttributesCont matchgroup=perlSubAttributesCont start="\h\w*(" end=")\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained contains=@perlInterpSQ,perlParensSQ
    9              0.000100 syn cluster perlSubAttrMaybe contains=perlSubAttributesCont,perlSubError,perlFakeGroup
    9              0.000053 syn match perlSubAttributes "" contained nextgroup=perlSubError
    9              0.000054 syn match perlSubAttributes ":\_s*" contained nextgroup=@perlSubAttrMaybe
    9              0.000037 if get(g:, "perl_sub_signatures", 0)
                                syn match perlSignature +(\_[^)]*)\_s*+ nextgroup=perlSubAttributes,perlComment contained
                            else
    9              0.000116     syn match perlSubPrototypeError "(\%(\_s*\%(\%(\\\%([$@%&*]\|\[[$@%&*]\+\]\)\|[$&*]\|[@%]\%(\_s*)\)\@=\|;\%(\_s*[)$@%&*\\]\)\@=\|_\%(\_s*[);]\)\@=\)\_s*\)*\)\@>\zs\_[^)]\+" contained
    9              0.000106     syn match perlSubPrototype +(\_[^)]*)\_s*+ nextgroup=perlSubAttributes,perlComment contained contains=perlSubPrototypeError
    9              0.000008 endif
                            
    9              0.000147 syn match perlSubName +\%(\h\|::\|'\w\)\%(\w\|::\|'\w\)*\_s*\|+ contained nextgroup=perlSubPrototype,perlSignature,perlSubAttributes,perlComment
                            
    9              0.000066 syn match perlFunction +\<sub\>\_s*+ nextgroup=perlSubName
                            
                            " The => operator forces a bareword to the left of it to be interpreted as
                            " a string
    9              0.000053 syn match  perlString "\I\@<!-\?\I\i*\%(\s*=>\)\@="
                            
                            " All other # are comments, except ^#!
    9              0.000089 syn match  perlComment		"#.*" contains=perlTodo,@Spell extend
    9              0.000035 syn match  perlSharpBang	"^#!.*"
                            
                            " Formats
    9              0.000215 syn region perlFormat		matchgroup=perlStatementIOFunc start="^\s*\<format\s\+\k\+\s*=\s*$"rs=s+6 end="^\s*\.\s*$" contains=perlFormatName,perlFormatField,perlVarPlain,perlVarPlain2
    9              0.000169 syn match  perlFormatName	"format\s\+\k\+\s*="lc=7,me=e-1 contained
    9              0.000092 syn match  perlFormatField	"[@^][|<>~]\+\%(\.\.\.\)\=" contained
    9              0.000032 syn match  perlFormatField	"[@^]#[#.]*" contained
    9              0.000029 syn match  perlFormatField	"@\*" contained
    9              0.000045 syn match  perlFormatField	"@[^A-Za-z_|<>~#*]"me=e-1 contained
    9              0.000032 syn match  perlFormatField	"@$" contained
                            
                            " __END__ and __DATA__ clauses
    9              0.000042 if exists("perl_fold")
                              syntax region perlDATA		start="^__DATA__$" skip="." end="." contains=@perlDATA fold
                              syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA fold
                            else
    9              0.000078   syntax region perlDATA		start="^__DATA__$" skip="." end="." contains=@perlDATA
    9              0.000146   syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA
    9              0.000007 endif
                            
                            "
                            " Folding
                            
    9              0.000029 if exists("perl_fold")
                              " Note: this bit must come before the actual highlighting of the "package"
                              " keyword, otherwise this will screw up Pod lines that match /^package/
                              if !exists("perl_nofold_packages")
                                syn region perlPackageFold start="^package \S\+;\s*\%(#.*\)\=$" end="^1;\=\s*\%(#.*\)\=$" end="\n\+package"me=s-1 transparent fold keepend
                              endif
                              if !exists("perl_nofold_subs")
                                if get(g:, "perl_fold_anonymous_subs", 0)
                                  syn region perlSubFold start="\<sub\>[^{]*{" end="}" transparent fold keepend extend
                                  syn region perlSubFold start="\<\%(BEGIN\|END\|CHECK\|INIT\)\>\s*{" end="}" transparent fold keepend
                                else
                                  syn region perlSubFold     start="^\z(\s*\)\<sub\>.*[^};]$" end="^\z1}\s*\%(#.*\)\=$" transparent fold keepend
                                  syn region perlSubFold start="^\z(\s*\)\<\%(BEGIN\|END\|CHECK\|INIT\|UNITCHECK\)\>.*[^};]$" end="^\z1}\s*$" transparent fold keepend
                                endif
                              endif
                            
                              if exists("perl_fold_blocks")
                                syn region perlBlockFold start="^\z(\s*\)\%(if\|elsif\|unless\|for\|while\|until\|given\)\s*(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" start="^\z(\s*\)for\%(each\)\=\s*\%(\%(my\|our\)\=\s*\S\+\s*\)\=(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                                syn region perlBlockFold start="^\z(\s*\)\%(do\|else\)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*while" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                              endif
                            
                              setlocal foldmethod=syntax
                              syn sync fromstart
                            else
                              " fromstart above seems to set minlines even if perl_fold is not set.
    9              0.000030   syn sync minlines=0
    9              0.000009 endif
                            
                            " NOTE: If you're linking new highlight groups to perlString, please also put
                            "       them into b:match_skip in ftplugin/perl.vim.
                            
                            " The default highlighting.
    9              0.000093 hi def link perlSharpBang		PreProc
    9              0.000049 hi def link perlControl		PreProc
    9              0.000053 hi def link perlInclude		Include
    9              0.000041 hi def link perlSpecial		Special
    9              0.000045 hi def link perlString		String
    9              0.000045 hi def link perlCharacter		Character
    9              0.000047 hi def link perlNumber		Number
    9              0.000043 hi def link perlFloat		Float
    9              0.000046 hi def link perlType			Type
    9              0.000043 hi def link perlIdentifier		Identifier
    9              0.000046 hi def link perlLabel		Label
    9              0.000052 hi def link perlStatement		Statement
    9              0.000046 hi def link perlConditional		Conditional
    9              0.000047 hi def link perlRepeat		Repeat
    9              0.000109 hi def link perlOperator		Operator
    9              0.000043 hi def link perlFunction		Keyword
    9              0.000044 hi def link perlSubName		Function
    9              0.000052 hi def link perlSubPrototype		Type
    9              0.000045 hi def link perlSignature		Type
    9              0.000047 hi def link perlSubAttributes	PreProc
    9              0.000035 hi def link perlSubAttributesCont	perlSubAttributes
    9              0.000050 hi def link perlComment		Comment
    9              0.000047 hi def link perlTodo			Todo
    9              0.000041 if exists("perl_string_as_statement")
                              hi def link perlStringStartEnd	perlStatement
                            else
    9              0.000034   hi def link perlStringStartEnd	perlString
    9              0.000005 endif
    9              0.000028 hi def link perlVStringV		perlStringStartEnd
    9              0.000037 hi def link perlList			perlStatement
    9              0.000027 hi def link perlMisc			perlStatement
    9              0.000027 hi def link perlVarPlain		perlIdentifier
    9              0.000028 hi def link perlVarPlain2		perlIdentifier
    9              0.000026 hi def link perlArrow		perlIdentifier
    9              0.000039 hi def link perlFiledescRead		perlIdentifier
    9              0.000039 hi def link perlFiledescStatement	perlIdentifier
    9              0.000030 hi def link perlVarSimpleMember	perlIdentifier
    9              0.000043 hi def link perlVarSimpleMemberName 	perlString
    9              0.000028 hi def link perlVarNotInMatches	perlIdentifier
    9              0.000028 hi def link perlVarSlash		perlIdentifier
    9              0.000028 hi def link perlQQ			perlString
    9              0.000027 hi def link perlHereDoc		perlString
    9              0.000031 hi def link perlStringUnexpanded	perlString
    9              0.000027 hi def link perlSubstitutionSQ	perlString
    9              0.000029 hi def link perlSubstitutionGQQ	perlString
    9              0.000029 hi def link perlTranslationGQ	perlString
    9              0.000071 hi def link perlMatch		perlString
    9              0.000029 hi def link perlMatchStartEnd	perlStatement
    9              0.000026 hi def link perlFormatName		perlIdentifier
    9              0.000036 hi def link perlFormatField		perlString
    9              0.000024 hi def link perlPackageDecl		perlType
    9              0.000026 hi def link perlStorageClass		perlType
    9              0.000035 hi def link perlPackageRef		perlType
    9              0.000033 hi def link perlStatementPackage	perlStatement
    9              0.000030 hi def link perlStatementStorage	perlStatement
    9              0.000039 hi def link perlStatementControl	perlStatement
    9              0.000029 hi def link perlStatementScalar	perlStatement
    9              0.000029 hi def link perlStatementRegexp	perlStatement
    9              0.000030 hi def link perlStatementNumeric	perlStatement
    9              0.000026 hi def link perlStatementList	perlStatement
    9              0.000028 hi def link perlStatementHash	perlStatement
    9              0.000031 hi def link perlStatementIOfunc	perlStatement
    9              0.000032 hi def link perlStatementFiledesc	perlStatement
    9              0.000029 hi def link perlStatementVector	perlStatement
    9              0.000049 hi def link perlStatementFiles	perlStatement
    9              0.000036 hi def link perlStatementFlow	perlStatement
    9              0.000038 hi def link perlStatementInclude	perlStatement
    9              0.000032 hi def link perlStatementProc	perlStatement
    9              0.000031 hi def link perlStatementSocket	perlStatement
    9              0.000030 hi def link perlStatementIPC		perlStatement
    9              0.000026 hi def link perlStatementNetwork	perlStatement
    9              0.000030 hi def link perlStatementPword	perlStatement
    9              0.000028 hi def link perlStatementTime	perlStatement
    9              0.000046 hi def link perlStatementMisc	perlStatement
    9              0.000038 hi def link perlStatementIndirObj	perlStatement
    9              0.000032 hi def link perlFunctionName		perlIdentifier
    9              0.000030 hi def link perlMethod		perlIdentifier
    9              0.000038 hi def link perlPostDeref		perlIdentifier
    9              0.000070 hi def link perlFunctionPRef		perlType
    9              0.000032 if !get(g:, 'perl_include_pod', 1)
                              hi def link perlPOD		perlComment
                            endif
    9              0.000034 hi def link perlShellCommand		perlString
    9              0.000027 hi def link perlSpecialAscii		perlSpecial
    9              0.000041 hi def link perlSpecialDollar	perlSpecial
    9              0.000035 hi def link perlSpecialString	perlSpecial
    9              0.000030 hi def link perlSpecialStringU	perlSpecial
    9              0.000030 hi def link perlSpecialMatch		perlSpecial
    9              0.000028 hi def link perlDATA			perlComment
                            
                            " NOTE: Due to a bug in Vim (or more likely, a misunderstanding on my part),
                            "       I had to remove the transparent property from the following regions
                            "       in order to get them to highlight correctly.  Feel free to remove
                            "       these and reinstate the transparent property if you know how.
    9              0.000031 hi def link perlParensSQ		perlString
    9              0.000031 hi def link perlBracketsSQ		perlString
    9              0.000030 hi def link perlBracesSQ		perlString
    9              0.000035 hi def link perlAnglesSQ		perlString
                            
    9              0.000031 hi def link perlParensDQ		perlString
    9              0.000031 hi def link perlBracketsDQ		perlString
    9              0.000030 hi def link perlBracesDQ		perlString
    9              0.000032 hi def link perlAnglesDQ		perlString
                            
    9              0.000033 hi def link perlSpecialStringU2	perlString
                            
                            " Possible errors
    9              0.000056 hi def link perlNotEmptyLine		Error
    9              0.000052 hi def link perlElseIfError		Error
    9              0.000048 hi def link perlSubPrototypeError	Error
    9              0.000098 hi def link perlSubError		Error
                            
                            " Syncing to speed up processing
                            "
    9              0.000026 if !exists("perl_no_sync_on_sub")
    9              0.000088   syn sync match perlSync	grouphere NONE "^\s*\<package\s"
    9              0.000051   syn sync match perlSync	grouphere NONE "^\s*\<sub\>"
    9              0.000046   syn sync match perlSync	grouphere NONE "^}"
    9              0.000008 endif
                            
    9              0.000025 if !exists("perl_no_sync_on_global_var")
    9              0.000084   syn sync match perlSync	grouphere NONE "^$\I[[:alnum:]_:]+\s*=\s*{"
    9              0.000058   syn sync match perlSync	grouphere NONE "^[@%]\I[[:alnum:]_:]+\s*=\s*("
    9              0.000007 endif
                            
    9              0.000024 if exists("perl_sync_dist")
                              execute "syn sync maxlines=" . perl_sync_dist
                            else
    9              0.000013   syn sync maxlines=100
    9              0.000007 endif
                            
    9              0.000080 syn sync match perlSyncPOD	grouphere perlPOD "^=pod"
    9              0.000058 syn sync match perlSyncPOD	grouphere perlPOD "^=head"
    9              0.000062 syn sync match perlSyncPOD	grouphere perlPOD "^=item"
    9              0.000043 syn sync match perlSyncPOD	grouphere NONE "^=cut"
                            
    9              0.000025 let b:current_syntax = "perl"
                            
    9              0.000083 let &cpo = s:cpo_save
    9              0.000017 unlet s:cpo_save
                            
                            " XXX Change to sts=4:sw=4
                            " vim:ts=8:sts=2:sw=2:expandtab:ft=vim

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/vim-polyglot/syntax/pod.vim
Sourced 9 times
Total time:   0.005498
 Self time:   0.005498

count  total (s)   self (s)
    9              0.000077 if !exists('g:polyglot_disabled') || index(g:polyglot_disabled, 'perl') == -1
                              
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      http://github.com/vim-perl/vim-perl
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   {{LAST_CHANGE}}
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    9              0.000028 if exists("b:current_syntax")
                              finish
                            endif
                            
    9              0.000035 let s:cpo_save = &cpo
    9              0.000048 set cpo&vim
                            
                            " POD commands
    9              0.000134 syn match podCommand    "^=encoding"  nextgroup=podCmdText contains=@NoSpell
    9              0.000113 syn match podCommand    "^=head[1234]"  nextgroup=podCmdText contains=@NoSpell
    9              0.000099 syn match podCommand    "^=item"        nextgroup=podCmdText contains=@NoSpell
    9              0.000087 syn match podCommand    "^=over"        nextgroup=podOverIndent skipwhite contains=@NoSpell
    9              0.000050 syn match podCommand    "^=back"        contains=@NoSpell
    9              0.000045 syn match podCommand    "^=cut"         contains=@NoSpell
    9              0.000038 syn match podCommand    "^=pod"         contains=@NoSpell
    9              0.000079 syn match podCommand    "^=for"         nextgroup=podForKeywd skipwhite contains=@NoSpell
    9              0.000080 syn match podCommand    "^=begin"       nextgroup=podForKeywd skipwhite contains=@NoSpell
    9              0.000074 syn match podCommand    "^=end"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
    9              0.000084 syn match podCmdText	".*$" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
    9              0.000042 syn match podOverIndent	"\d\+" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
    9              0.000046 syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
    9              0.000047 syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                            " Inline textual items handled specially by POD
    9              0.000089 syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
    9              0.000082 syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
    9              0.000122 syn region podFormat	start="[IBSCLFX]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
    9              0.000126 syn region podFormat	start="[IBSCLFX]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
    9              0.000037 syn match  podFormat	"Z<>"
    9              0.000122 syn match  podFormat	"E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
    9              0.000049 syn match  podEscape	"\I\i*>"me=e-1 contained contains=@NoSpell
    9              0.000041 syn match  podEscape2	"\d\+>"me=e-1 contained contains=@NoSpell
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    9              0.000066 hi def link podCommand		Statement
    9              0.000048 hi def link podCmdText		String
    9              0.000047 hi def link podOverIndent	Number
    9              0.000047 hi def link podForKeywd		Identifier
    9              0.000047 hi def link podFormat		Identifier
    9              0.000098 hi def link podVerbatimLine	PreProc
    9              0.000049 hi def link podSpecial		Identifier
    9              0.000051 hi def link podEscape		String
    9              0.000043 hi def link podEscape2		Number
                            
    9              0.000030 if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn match podCmdText    ".*$" contained contains=podFormat
                            endif
                            
    9              0.000022 if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn match podFormat   "E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<< " contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<< " contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<< " contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<< " contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" oneline contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\s" end="\s>>" oneline contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" oneline contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\s" end="\s>>" oneline contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">" oneline
                              syn region podItalicBold contained start="B<[^<]"me=e end=">" oneline
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e oneline contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\s"ms=s-2 end="\s>>"me=e oneline contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e oneline contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\s"ms=s-2 end="\s>>"me=e oneline contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
                            endif
                            
    9              0.000072 let b:current_syntax = "pod"
                            
    9              0.000083 let &cpo = s:cpo_save
    9              0.000016 unlet s:cpo_save
                            
                            " vim: ts=8
                            
    9              0.000037 endif

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/pod.vim
Sourced 9 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      http://github.com/vim-perl/vim-perl
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2017-09-12
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    9              0.000061 if exists("b:current_syntax")
    9              0.000014   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " POD commands
                            syn match podCommand    "^=encoding"  nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=head[1234]"  nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=item"        nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=over"        nextgroup=podOverIndent skipwhite contains=@NoSpell
                            syn match podCommand    "^=back"        contains=@NoSpell
                            syn match podCommand    "^=cut"         contains=@NoSpell
                            syn match podCommand    "^=pod"         contains=@NoSpell
                            syn match podCommand    "^=for"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            syn match podCommand    "^=begin"       nextgroup=podForKeywd skipwhite contains=@NoSpell
                            syn match podCommand    "^=end"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
                            syn match podCmdText	".*$" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
                            syn match podOverIndent	"\d\+" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
                            syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
                            syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                            " Inline textual items handled specially by POD
                            syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
                            syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
                            syn region podFormat	start="[IBSCLFX]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                            syn region podFormat	start="[IBSCLFX]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            syn match  podFormat	"Z<>"
                            syn match  podFormat	"E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            syn match  podEscape	"\I\i*>"me=e-1 contained contains=@NoSpell
                            syn match  podEscape2	"\d\+>"me=e-1 contained contains=@NoSpell
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            hi def link podCommand		Statement
                            hi def link podCmdText		String
                            hi def link podOverIndent	Number
                            hi def link podForKeywd		Identifier
                            hi def link podFormat		Identifier
                            hi def link podVerbatimLine	PreProc
                            hi def link podSpecial		Identifier
                            hi def link podEscape		String
                            hi def link podEscape2		Number
                            
                            if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn match podCmdText    ".*$" contained contains=podFormat
                            endif
                            
                            if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn match podFormat   "E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<< " contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<< " contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<< " contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<< " contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" oneline contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\s" end="\s>>" oneline contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" oneline contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\s" end="\s>>" oneline contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">" oneline
                              syn region podItalicBold contained start="B<[^<]"me=e end=">" oneline
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e oneline contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\s"ms=s-2 end="\s>>"me=e oneline contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e oneline contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\s"ms=s-2 end="\s>>"me=e oneline contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
                            endif
                            
                            let b:current_syntax = "pod"
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/ruby.vim
Sourced 9 times
Total time:   0.031660
 Self time:   0.030836

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    9              0.000038 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " this file uses line continuations
    9              0.000065 let s:cpo_sav = &cpo
    9              0.000057 set cpo&vim
                            
                            " Folding Config {{{1
    9              0.000036 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
    9              0.000231 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    9              0.000034 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction " }}}
                            
    9              0.000167 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
                            " Whitespace Errors {{{1
    9              0.000025 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators {{{1
    9              0.000030 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^|*/%+-]\|&\.\@!\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@1<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@2<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation {{{1
    9              0.000077 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
    9              0.000075 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
    9              0.000039 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
    9              0.000080 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    9              0.000162 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
    9              0.000044 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
    9              0.000103 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
    9              0.000034 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
    9              0.000046 syn region rubyNoInterpolation	      start="\\#{" end="}"	      contained
    9              0.000045 syn match  rubyNoInterpolation	      "\\#{"		      display contained
    9              0.000049 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
    9              0.000046 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
    9              0.000068 syn match rubyDelimiterEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
    9              0.000088 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
    9              0.000078 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
    9              0.000805 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
    9              0.000093 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " Regular Expression Metacharacters {{{1
                            " These are mostly Oniguruma ready
    9              0.000084 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
    9              0.000236 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    9              0.000157 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
    9              0.000037 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
    9              0.000123 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
    9              0.000041 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
    9              0.000032 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
    9              0.000051 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
    9              0.000059 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
    9              0.000028 syn match  rubyRegexpDot	"\."		       contained display
    9              0.000022 syn match  rubyRegexpSpecial	"|"		       contained display
    9              0.000042 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
    9              0.000053 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    9              0.000048 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    9              0.000044 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
    9              0.000048 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
    9              0.000093 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
    9              0.000115 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
    9              0.000267 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes {{{1
    9              0.000100 syn match rubyASCIICode "\%(\w\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
    9              0.000127 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"								display
    9              0.000079 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"						display
    9              0.000054 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"								display
    9              0.000071 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"								display
    9              0.000058 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"					display
    9              0.000078 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)r\=i\=\>"	display
                            
                            " Identifiers {{{1
    9              0.000078 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
    9              0.000065 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
    9              0.000065 syn match  rubyConstant		"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    9              0.000051 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    9              0.000131 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"	display
    9              0.000074 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    9              0.000091 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
    9              0.000060 syn match  rubySymbol		"[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
    9              0.000069 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
    9              0.000056 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
                            
    9   0.000221   0.000161 if s:foldable(':')
    9              0.000129   syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
    9              0.000119   syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
    9              0.000044 else
                              syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape
                              syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            endif
                            
    9              0.000079 syn match  rubyCapitalizedMethod	"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)*\s*(\@="
                            
    9              0.000047 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
    9              0.000095 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" oneline display contains=rubyBlockParameter
                            
    9              0.000045 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
    9              0.000038 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
    9              0.000036 syn match rubyPredefinedVariable "$\d\+"										   display
    9              0.000082 syn match rubyPredefinedVariable "$_\>"											   display
    9              0.000068 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
    9              0.000064 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
    9              0.000072 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    9              0.000093 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|FALSE\|NIL\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
    9              0.000089 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression {{{1
    9   0.000082   0.000043 if s:foldable('/')
    9              0.000186   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    9              0.000149   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    9              0.000010 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                            endif
                            
                            " Generalized Regular Expression {{{1
    9   0.000121   0.000081 if s:foldable('%')
    9              0.000113   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    9              0.000137   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
    9              0.000236   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape fold
    9              0.000111   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
    9              0.000120   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
    9              0.000167   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    9              0.000010 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            endif
                            
                            " Normal String {{{1
    9              0.000064 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    9   0.000247   0.000199 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=@rubyStringSpecial' . s:spell_cluster
    9   0.000215   0.000174 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=rubyQuoteEscape'	 . s:spell_cluster
                            
                            " Shell Command Output {{{1
    9   0.000062   0.000028 if s:foldable('%')
    9              0.000102   syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial fold
    9              0.000004 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            endif
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings {{{1
    9   0.000070   0.000039 if s:foldable('%')
    9              0.000100   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    9              0.000126   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    9              0.000135   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    9              0.000122   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    9              0.000120   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    9              0.000125   syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    9              0.000094   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1" fold
    9              0.000115   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    9              0.000116   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    9              0.000116   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    9              0.000122   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    9              0.000126   syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    9              0.000008 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                            endif
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output {{{1
                            " Note: %= is not matched here as the beginning of a double quoted string
    9   0.000092   0.000044 if s:foldable('%')
    9              0.000124   syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    9              0.000102   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    9              0.000164   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    9              0.000156   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    9              0.000130   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    9              0.000136   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    9              0.000095   syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    9              0.000009 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            endif
                            
                            " Array of Symbols {{{1
    9   0.000078   0.000039 if s:foldable('%')
                              " Array of Symbols
    9              0.000104   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	fold
    9              0.000213   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    9              0.000141   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    9              0.000133   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    9              0.000127   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
    9              0.000103   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial fold
    9              0.000176   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    9              0.000145   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    9              0.000126   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    9              0.000137   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    9              0.000019 else
                              " Array of Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                            endif
                            
                            " Here Document {{{1
    9              0.000185 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
    9              0.000124 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    9              0.000095 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    9              0.000087 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    9   0.000104   0.000065 if s:foldable('<<')
    9              0.000207   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    9              0.000165   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    9              0.000139   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    fold keepend
    9              0.000143   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
    9              0.000167   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    9              0.000132   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    9              0.000123   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    fold keepend
    9              0.000119   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    9              0.000019 else
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                            
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            endif
                            
                            " eRuby Config {{{1
    9              0.000035 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
                            end
                            
                            " Module, Class, Method and Alias Declarations {{{1
    9              0.000140 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
    9              0.000111 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
    9              0.000167 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    9              0.000073 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    9              0.000076 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    9              0.000082 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
    9              0.000155 syn match  rubyFunction "\%(\s\|^\)\@1<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    9              0.000174 syn match  rubyFunction "\%([[:space:].]\|^\)\@2<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    9              0.000233 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords {{{1
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
    9              0.000081 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
    9              0.000047 syn match   rubyOperator       "\<defined?" display
    9              0.000043 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
    9              0.000043 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
    9              0.000081 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__dir__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
    9              0.000045 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    9              0.000049 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    9              0.000107   syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
    9              0.000067   syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    9              0.000064   syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
    9              0.000070   syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    9              0.000063   syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
    9   0.000094   0.000051   if s:foldable('def')
    9              0.000132     syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000009   else
                                syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9   0.000083   0.000045   if s:foldable('class')
    9              0.000131     syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000058   else
                                syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9   0.000093   0.000041   if s:foldable('module')
    9              0.000098     syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000011   else
                                syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " modifiers
    9              0.000085   syn match rubyLineContinuation    "\\$" nextgroup=rubyConditionalModifier,rubyRepeatModifier skipwhite skipnl
    9              0.000094   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
    9              0.000051   syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
                            
    9   0.000075   0.000040   if s:foldable('do')
    9              0.000096     syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000007   else
                                syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " curly bracket block or hash literal
    9   0.000060   0.000031   if s:foldable('{')
    9              0.000071     syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop fold
    9              0.000004   else
                                syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9   0.000100   0.000070   if s:foldable('[')
    9              0.000093     syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop fold
    9              0.000006   else
                                syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " statements without 'do'
    9   0.000073   0.000047   if s:foldable('begin')
    9              0.000092     syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000005   else
                                syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9   0.000066   0.000039   if s:foldable('case')
    9              0.000095     syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000016   else
                                syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9   0.000057   0.000032   if s:foldable('if')
    9              0.000212     syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    9              0.000013   else
                                syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    9              0.000083   syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
    9              0.000058   syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
    9              0.000093   syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
    9              0.000115   syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
    9              0.000192   syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
    9   0.000085   0.000052   if s:foldable('for')
    9              0.000152     syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
    9              0.000011   else
                                syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                              endif
                            
    9              0.000022   if !exists("ruby_minlines")
                                let ruby_minlines = 500
                              endif
    9              0.000051   exec "syn sync minlines=" . ruby_minlines
                            
    9              0.000006 else
                              syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
                            endif
                            
                            " Special Methods {{{1
    9              0.000025 if !exists("ruby_no_special_methods")
    9              0.000054   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
    9              0.000053   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
    9              0.000041   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
    9              0.000063   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
    9              0.000082   syn keyword rubyEval	    eval class_eval instance_eval module_eval
    9              0.000035   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
    9              0.000043   syn match   rubyInclude   "\<include\>[?!]\@!"
    9              0.000044   syn keyword rubyInclude   autoload extend load prepend refine require require_relative using
    9              0.000036   syn keyword rubyKeyword   callcc caller lambda proc
    9              0.000013 endif
                            
                            " Comments and Documentation {{{1
    9              0.000086 syn match   rubySharpBang "\%^#!.*" display
    9              0.000049 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    9              0.000109 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
    9   0.000091   0.000056 if !exists("ruby_no_comment_fold") && s:foldable('#')
    9              0.000121   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    9              0.000140   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
    9              0.000008 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Keyword Nobbling {{{1
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
    9              0.000115 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\<\%(BEGIN\|END\)\>\)" transparent contains=NONE
    9              0.000082 syn match rubyKeywordAsMethod "\(defined?\|exit!\)\@!\<[_[:lower:]][_[:alnum:]]*[?!]"			       transparent contains=NONE
                            
                            " More Symbols {{{1
    9              0.000054 syn match  rubySymbol		"\%([{(,]\_s*\)\zs\l\w*[!?]\=::\@!"he=e-1
    9              0.000084 syn match  rubySymbol		"[]})\"':]\@1<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="he=e-1
    9              0.000053 syn match  rubySymbol		"\%([{(,]\_s*\)\zs[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
    9              0.000058 syn match  rubySymbol		"[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="hs=s+1,he=e-1
                            
                            " __END__ Directive {{{1
    9   0.000114   0.000082 if s:foldable('__END__')
    9              0.000090   syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
    9              0.000011 else
                              syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            endif
                            
                            " Default Highlighting {{{1
    9              0.000031 hi def link rubyClass			rubyDefine
    9              0.000021 hi def link rubyModule			rubyDefine
    9              0.000026 hi def link rubyMethodExceptional	rubyDefine
    9              0.000076 hi def link rubyDefine			Define
    9              0.000054 hi def link rubyFunction		Function
    9              0.000042 hi def link rubyConditional		Conditional
    9              0.000027 hi def link rubyConditionalModifier	rubyConditional
    9              0.000029 hi def link rubyExceptional		rubyConditional
    9              0.000042 hi def link rubyRepeat			Repeat
    9              0.000022 hi def link rubyRepeatModifier		rubyRepeat
    9              0.000022 hi def link rubyOptionalDo		rubyRepeat
    9              0.000038 hi def link rubyControl			Statement
    9              0.000054 hi def link rubyInclude			Include
    9              0.000044 hi def link rubyInteger			Number
    9              0.000042 hi def link rubyASCIICode		Character
    9              0.000042 hi def link rubyFloat			Float
    9              0.000042 hi def link rubyBoolean			Boolean
    9              0.000040 hi def link rubyException		Exception
    9              0.000026 if !exists("ruby_no_identifiers")
    9              0.000044   hi def link rubyIdentifier		Identifier
    9              0.000007 else
                              hi def link rubyIdentifier		NONE
                            endif
    9              0.000026 hi def link rubyClassVariable		rubyIdentifier
    9              0.000091 hi def link rubyConstant		Type
    9              0.000028 hi def link rubyGlobalVariable		rubyIdentifier
    9              0.000020 hi def link rubyBlockParameter		rubyIdentifier
    9              0.000028 hi def link rubyInstanceVariable	rubyIdentifier
    9              0.000022 hi def link rubyPredefinedIdentifier	rubyIdentifier
    9              0.000024 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    9              0.000028 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    9              0.000044 hi def link rubySymbol			Constant
    9              0.000041 hi def link rubyKeyword			Keyword
    9              0.000040 hi def link rubyOperator		Operator
    9              0.000040 hi def link rubyBeginEnd		Statement
    9              0.000049 hi def link rubyAccess			Statement
    9              0.000041 hi def link rubyAttribute		Statement
    9              0.000039 hi def link rubyEval			Statement
    9              0.000041 hi def link rubyPseudoVariable		Constant
    9              0.000027 hi def link rubyCapitalizedMethod	rubyLocalVariableOrMethod
                            
    9              0.000042 hi def link rubyComment			Comment
    9              0.000038 hi def link rubyData			Comment
    9              0.000052 hi def link rubyDataDirective		Delimiter
    9              0.000039 hi def link rubyDocumentation		Comment
    9              0.000044 hi def link rubyTodo			Todo
                            
    9              0.000028 hi def link rubyQuoteEscape		rubyStringEscape
    9              0.000043 hi def link rubyStringEscape		Special
    9              0.000043 hi def link rubyInterpolationDelimiter	Delimiter
    9              0.000026 hi def link rubyNoInterpolation		rubyString
    9              0.000040 hi def link rubySharpBang		PreProc
    9              0.000026 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    9              0.000025 hi def link rubySymbolDelimiter		rubySymbol
    9              0.000040 hi def link rubyStringDelimiter		Delimiter
    9              0.000022 hi def link rubyHeredoc			rubyString
    9              0.000084 hi def link rubyString			String
    9              0.000027 hi def link rubyRegexpEscape		rubyRegexpSpecial
    9              0.000024 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    9              0.000031 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    9              0.000026 hi def link rubyRegexpDot		rubyRegexpCharClass
    9              0.000025 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    9              0.000049 hi def link rubyRegexpSpecial		Special
    9              0.000045 hi def link rubyRegexpComment		Comment
    9              0.000020 hi def link rubyRegexp			rubyString
                            
    9              0.000042 hi def link rubyInvalidVariable		Error
    9              0.000039 hi def link rubyError			Error
    9              0.000021 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    9              0.000031 let b:current_syntax = "ruby"
                            
    9              0.000074 let &cpo = s:cpo_sav
    9              0.000016 unlet! s:cpo_sav
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/python.vim
Sourced 9 times
Total time:   0.007729
 Self time:   0.007729

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2016 Oct 29
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " quit when a syntax file was already loaded.
    9              0.000059 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    9              0.000038 let s:cpo_save = &cpo
    9              0.000052 set cpo&vim
                            
    9              0.000038 if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
                            endif
                            
    9              0.000022 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    9              0.000045 syn keyword pythonStatement	False None True
    9              0.000045 syn keyword pythonStatement	as assert break continue del exec global
    9              0.000035 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    9              0.000050 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    9              0.000027 syn keyword pythonConditional	elif else if
    9              0.000025 syn keyword pythonRepeat	for while
    9              0.000040 syn keyword pythonOperator	and in is not or
    9              0.000031 syn keyword pythonException	except finally raise try
    9              0.000025 syn keyword pythonInclude	from import
    9              0.000025 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    9              0.000073 syn match   pythonDecorator	"@" display contained
    9              0.000089 syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
    9              0.000162 syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
    9              0.000156 syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
    9              0.000172 syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
    9              0.000045 syn match   pythonFunction	"\h\w*" display contained
                            
    9              0.000074 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    9              0.000031 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    9              0.000133 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    9              0.000156 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    9              0.000202 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    9              0.000148 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    9              0.000051 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    9              0.000042 syn match   pythonEscape	"\\\o\{1,3}" contained
    9              0.000027 syn match   pythonEscape	"\\x\x\{2}" contained
    9              0.000055 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    9              0.000035 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    9              0.000039 syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    9              0.000034 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    9              0.000060   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    9              0.000081   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    9              0.000037   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    9              0.000052   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    9              0.000046   syn match   pythonNumber	"\<\d\+[jJ]\>"
    9              0.000043   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    9              0.000103   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    9              0.000054   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    9              0.000010 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    9              0.000028 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    9              0.000033   syn keyword pythonBuiltin	False True None
    9              0.000032   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    9              0.000041   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    9              0.000039   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    9              0.000054   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    9              0.000034   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    9              0.000034   syn keyword pythonBuiltin	help hex id input int isinstance
    9              0.000036   syn keyword pythonBuiltin	issubclass iter len list locals map max
    9              0.000097   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    9              0.000044   syn keyword pythonBuiltin	print property range repr reversed round set
    9              0.000036   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    9              0.000035   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    9              0.000031   syn keyword pythonBuiltin	basestring cmp execfile file
    9              0.000029   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    9              0.000027   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    9              0.000029   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    9              0.000030   syn keyword pythonBuiltin	apply buffer coerce intern
                              " avoid highlighting attributes as builtins
    9              0.000110   syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
    9              0.000008 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    9              0.000026 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    9              0.000027   syn keyword pythonExceptions	BaseException Exception
    9              0.000029   syn keyword pythonExceptions	ArithmeticError BufferError
    9              0.000022   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    9              0.000026   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    9              0.000027   syn keyword pythonExceptions	AssertionError AttributeError
    9              0.000028   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    9              0.000023   syn keyword pythonExceptions	ImportError IndentationError
    9              0.000069   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    9              0.000032   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    9              0.000033   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    9              0.000031   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    9              0.000041   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    9              0.000022   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    9              0.000025   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    9              0.000022   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    9              0.000020   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    9              0.000020   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    9              0.000026   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    9              0.000026   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    9              0.000023   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    9              0.000046   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    9              0.000050   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    9              0.000036   syn keyword pythonExceptions	PermissionError ProcessLookupError
    9              0.000027   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    9              0.000025   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    9              0.000025   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    9              0.000029   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    9              0.000037   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    9              0.000026   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    9              0.000024   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    9              0.000024   syn keyword pythonExceptions	ResourceWarning
    9              0.000007 endif
                            
    9              0.000037 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    9              0.000019 if !exists("python_no_doctest_highlight")
    9              0.000032   if !exists("python_no_doctest_code_highlight")
    9              0.000185     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
    9              0.000078     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    9              0.000008   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    9              0.000004 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    9              0.000058 syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
    9              0.000091 hi def link pythonStatement		Statement
    9              0.000044 hi def link pythonConditional		Conditional
    9              0.000041 hi def link pythonRepeat		Repeat
    9              0.000041 hi def link pythonOperator		Operator
    9              0.000124 hi def link pythonException		Exception
    9              0.000043 hi def link pythonInclude		Include
    9              0.000047 hi def link pythonAsync			Statement
    9              0.000039 hi def link pythonDecorator		Define
    9              0.000074 hi def link pythonDecoratorName		Function
    9              0.000046 hi def link pythonFunction		Function
    9              0.000064 hi def link pythonComment		Comment
    9              0.000049 hi def link pythonTodo			Todo
    9              0.000067 hi def link pythonString		String
    9              0.000042 hi def link pythonRawString		String
    9              0.000038 hi def link pythonQuotes		String
    9              0.000021 hi def link pythonTripleQuotes		pythonQuotes
    9              0.000042 hi def link pythonEscape		Special
    9              0.000053 if !exists("python_no_number_highlight")
    9              0.000069   hi def link pythonNumber		Number
    9              0.000005 endif
    9              0.000023 if !exists("python_no_builtin_highlight")
    9              0.000054   hi def link pythonBuiltin		Function
    9              0.000006 endif
    9              0.000019 if !exists("python_no_exception_highlight")
    9              0.000041   hi def link pythonExceptions		Structure
    9              0.000007 endif
    9              0.000019 if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
                            endif
    9              0.000019 if !exists("python_no_doctest_highlight")
    9              0.000041   hi def link pythonDoctest		Special
    9              0.000039   hi def link pythonDoctestValue	Define
    9              0.000007 endif
                            
    9              0.000035 let b:current_syntax = "python"
                            
    9              0.000094 let &cpo = s:cpo_save
    9              0.000013 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/splitjoin.vim/ftplugin/vim/splitjoin.vim
Sourced 9 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
    9              0.000097 if !exists('b:splitjoin_split_callbacks')
    9              0.000054   let b:splitjoin_split_callbacks = [
                                    \ 'sj#vim#Split',
                                    \ ]
    9              0.000009 endif
                            
    9              0.000024 if !exists('b:splitjoin_join_callbacks')
    9              0.000027   let b:splitjoin_join_callbacks = [
                                    \ 'sj#vim#Join',
                                    \ ]
    9              0.000025 endif

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/ftplugin/vim.vim
Sourced 9 times
Total time:   0.003928
 Self time:   0.003928

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Dec 05
                            
                            " Only do this when not done yet for this buffer
    9              0.000047 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    9              0.000018 let b:did_ftplugin = 1
                            
    9              0.000038 let s:cpo_save = &cpo
    9              0.000061 set cpo-=C
                            
    9              0.000084 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    9              0.000071 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    9              0.000216 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    9              0.000028 setlocal keywordprg=:help
                            
                            " Set 'comments' to format dashed lists in comments
    9              0.000047 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    9              0.000019 if &tw == 0
                              setlocal tw=78
                            endif
                            
                            " Comments start with a double quote
    9              0.000047 setlocal commentstring=\"%s
                            
    9              0.000052 if !exists("no_plugin_maps") && !exists("no_vim_maps")
                              " Move around functions.
    9              0.000659   nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    9              0.000199   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    9              0.000150   nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    9              0.000160   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    9              0.000177   nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    9              0.000174   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    9              0.000130   nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    9              0.000194   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                              " Move around comments
    9              0.000130   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    9              0.000161   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    9              0.000130   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    9              0.000142   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    9              0.000007 endif
                            
                            " Let the matchit plugin know what items can be matched.
    9              0.000027 if exists("loaded_matchit")
    9              0.000018   let b:match_ignorecase = 0
    9              0.000147   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    9              0.000027   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    9              0.000007 endif
                            
    9              0.000067 let &cpo = s:cpo_save
    9              0.000017 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/vim-textobj-function/after/ftplugin/vim/textobj-function.vim
Sourced 9 times
Total time:   0.000456
 Self time:   0.000456

count  total (s)   self (s)
                            " Vim additional ftplugin: vim/textobj-function
                            " Version: 0.4.0
                            " Copyright (C) 2007-2014 Kana Natsuno <http://whileimautomaton.net/>
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            
                            
                            
                            
    9              0.000082 let b:textobj_function_select = function('textobj#function#vim#select')
                            
                            
                            
                            
    9              0.000030 if exists('b:undo_ftplugin')
    9              0.000023   let b:undo_ftplugin .= '|'
    9              0.000009 else
                              let b:undo_ftplugin = ''
                            endif
    9              0.000059 let b:undo_ftplugin .= 'unlet b:textobj_function_select'
                            
                            " __END__
                            " vim: foldmethod=marker

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/indent/vim.vim
Sourced 9 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    9              0.000054 if exists("b:did_indent")
                              finish
                            endif
    9              0.000017 let b:did_indent = 1
                            
    9              0.000043 setlocal indentexpr=GetVimIndent()
    9              0.000030 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    9              0.000017 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    9              0.000023 if exists("*GetVimIndent")
    9              0.000007   finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ '^\s*\\'
                                while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/autoload/netrw.vim
Sourced 1 time
Total time:   0.016693
 Self time:   0.014793

count  total (s)   self (s)
                            " netrw.vim: Handles file transfer and remote directory listing across
                            "            AUTOLOAD SECTION
                            " Date:		Apr 20, 2016
                            " Version:	156
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and come with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_netrw")
                              finish
                            endif
                            " netrw requires vim having patch 213; netrw will benefit from vim's having patch#656, too
    1              0.000006 if v:version < 704 || !has("patch213")
                             if !exists("s:needpatch213")
                              unsilent echomsg "***sorry*** this version of netrw requires vim v7.4 with patch 213"
                             endif
                             let s:needpatch213= 1
                             finish
                            endif
    1              0.000003 let g:loaded_netrw = "v156"
    1              0.000002 if !exists("s:NOTE")
    1              0.000002  let s:NOTE    = 0
    1              0.000002  let s:WARNING = 1
    1              0.000001  let s:ERROR   = 2
    1              0.000001 endif
                            
    1              0.000004 let s:keepcpo= &cpo
    1              0.000007 setl cpo&vim
                            "let g:dechofuncname= 1
                            "DechoRemOn
                            "call Decho("doing autoload/netrw.vim version ".g:loaded_netrw,'~'.expand("<slnum>"))
                            
                            " ======================
                            "  Netrw Variables: {{{1
                            " ======================
                            
                            " ---------------------------------------------------------------------
                            " netrw#ErrorMsg: {{{2
                            "   0=note     = s:NOTE
                            "   1=warning  = s:WARNING
                            "   2=error    = s:ERROR
                            "   Usage: netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,"some message",error-number)
                            "          netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,["message1","message2",...],error-number)
                            "          (this function can optionally take a list of messages)
                            "  Jan 19, 2016 : max errnum currently is 103
    1              0.000003 fun! netrw#ErrorMsg(level,msg,errnum)
                            "  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)
                            
                              if a:level < g:netrw_errorlvl
                            "   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
                               return
                              endif
                            
                              if a:level == 1
                               let level= "**warning** (netrw) "
                              elseif a:level == 2
                               let level= "**error** (netrw) "
                              else
                               let level= "**note** (netrw) "
                              endif
                            "  call Decho("level=".level,'~'.expand("<slnum>"))
                            
                              if g:netrw_use_errorwindow
                               " (default) netrw creates a one-line window to show error/warning
                               " messages (reliably displayed)
                            
                               " record current window number
                               let s:winBeforeErr= winnr()
                            "   call Decho("s:winBeforeErr=".s:winBeforeErr,'~'.expand("<slnum>"))
                            
                               " getting messages out reliably is just plain difficult!
                               " This attempt splits the current window, creating a one line window.
                               if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
                            "    call Decho("write to NetrwMessage buffer",'~'.expand("<slnum>"))
                                exe bufwinnr("NetrwMessage")."wincmd w"
                            "    call Decho("setl ma noro",'~'.expand("<slnum>"))
                                setl ma noro
                                if type(a:msg) == 3
                                 for msg in a:msg
                                  NetrwKeepj call setline(line("$")+1,level.msg)
                                 endfor
                                else
                                 NetrwKeepj call setline(line("$")+1,level.a:msg)
                                endif
                                NetrwKeepj $
                               else
                            "    call Decho("create a NetrwMessage buffer window",'~'.expand("<slnum>"))
                                bo 1split
                                sil! call s:NetrwEnew()
                                sil! NetrwKeepj call s:NetrwSafeOptions()
                                setl bt=nofile
                                NetrwKeepj file NetrwMessage
                            "    call Decho("setl ma noro",'~'.expand("<slnum>"))
                                setl ma noro
                                if type(a:msg) == 3
                                 for msg in a:msg
                                  NetrwKeepj call setline(line("$")+1,level.msg)
                                 endfor
                                else
                                 NetrwKeepj call setline(line("$"),level.a:msg)
                                endif
                                NetrwKeepj $
                               endif
                            "   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr(),'~'.expand("<slnum>"))
                               if &fo !~ '[ta]'
                                syn clear
                                syn match netrwMesgNote	"^\*\*note\*\*"
                                syn match netrwMesgWarning	"^\*\*warning\*\*"
                                syn match netrwMesgError	"^\*\*error\*\*"
                                hi link netrwMesgWarning WarningMsg
                                hi link netrwMesgError   Error
                               endif
                            "   call Decho("setl noma ro bh=wipe",'~'.expand("<slnum>"))
                               setl ro nomod noma bh=wipe
                            
                              else
                               " (optional) netrw will show messages using echomsg.  Even if the
                               " message doesn't appear, at least it'll be recallable via :messages
                            "   redraw!
                               if a:level == s:WARNING
                                echohl WarningMsg
                               elseif a:level == s:ERROR
                                echohl Error
                               endif
                            
                               if type(a:msg) == 3
                                 for msg in a:msg
                                  unsilent echomsg level.msg
                                 endfor
                               else
                                unsilent echomsg level.a:msg
                               endif
                            
                            "   call Decho("echomsg ***netrw*** ".a:msg,'~'.expand("<slnum>"))
                               echohl None
                              endif
                            
                            "  call Dret("netrw#ErrorMsg")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwInit: initializes variables if they haven't been defined {{{2
                            "            Loosely,  varname = value.
    1              0.000003 fun s:NetrwInit(varname,value)
                            " call Decho("varname<".a:varname."> value=".a:value,'~'.expand("<slnum>"))
                              if !exists(a:varname)
                               if type(a:value) == 0
                                exe "let ".a:varname."=".a:value
                               elseif type(a:value) == 1 && a:value =~ '^[{[]'
                                exe "let ".a:varname."=".a:value
                               elseif type(a:value) == 1
                                exe "let ".a:varname."="."'".a:value."'"
                               else
                                exe "let ".a:varname."=".a:value
                               endif
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Netrw Constants: {{{2
    1   0.000043   0.000019 call s:NetrwInit("g:netrw_dirhist_cnt",0)
    1              0.000003 if !exists("s:LONGLIST")
    1   0.000023   0.000004  call s:NetrwInit("s:THINLIST",0)
    1   0.000021   0.000003  call s:NetrwInit("s:LONGLIST",1)
    1   0.000020   0.000004  call s:NetrwInit("s:WIDELIST",2)
    1   0.000020   0.000003  call s:NetrwInit("s:TREELIST",3)
    1   0.000020   0.000003  call s:NetrwInit("s:MAXLIST" ,4)
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Default values for netrw's global protocol variables {{{2
    1   0.000022   0.000004 call s:NetrwInit("g:netrw_use_errorwindow",1)
                            
    1              0.000003 if !exists("g:netrw_dav_cmd")
    1              0.000078  if executable("cadaver")
                              let g:netrw_dav_cmd	= "cadaver"
                             elseif executable("curl")
    1              0.000020   let g:netrw_dav_cmd	= "curl"
    1              0.000004  else
                              let g:netrw_dav_cmd   = ""
                             endif
    1              0.000027 endif
    1              0.000011 if !exists("g:netrw_fetch_cmd")
    1              0.000137  if executable("fetch")
                              let g:netrw_fetch_cmd	= "fetch -o"
                             else
    1              0.000004   let g:netrw_fetch_cmd	= ""
    1              0.000002  endif
    1              0.000001 endif
    1              0.000006 if !exists("g:netrw_file_cmd")
    1              0.000097  if executable("elinks")
                              call s:NetrwInit("g:netrw_file_cmd","elinks")
                             elseif executable("links")
                              call s:NetrwInit("g:netrw_file_cmd","links")
                             endif
    1              0.000001 endif
    1              0.000027 if !exists("g:netrw_ftp_cmd")
    1              0.000004   let g:netrw_ftp_cmd	= "ftp"
    1              0.000001 endif
    1              0.000004 let s:netrw_ftp_cmd= g:netrw_ftp_cmd
    1              0.000005 if !exists("g:netrw_ftp_options")
    1              0.000014  let g:netrw_ftp_options= "-i -n"
    1              0.000002 endif
    1              0.000005 if !exists("g:netrw_http_cmd")
    1              0.000101  if executable("elinks")
                              let g:netrw_http_cmd = "elinks"
                              call s:NetrwInit("g:netrw_http_xcmd","-source >")
                             elseif executable("links")
                              let g:netrw_http_cmd = "links"
                              call s:NetrwInit("g:netrw_http_xcmd","-source >")
                             elseif executable("curl")
    1              0.000005   let g:netrw_http_cmd	= "curl"
    1   0.000094   0.000028   call s:NetrwInit("g:netrw_http_xcmd","-o")
    1              0.000004  elseif executable("wget")
                              let g:netrw_http_cmd	= "wget"
                              call s:NetrwInit("g:netrw_http_xcmd","-q -O")
                             elseif executable("fetch")
                              let g:netrw_http_cmd	= "fetch"
                              call s:NetrwInit("g:netrw_http_xcmd","-o")
                             else
                              let g:netrw_http_cmd	= ""
                             endif
    1              0.000001 endif
    1   0.000052   0.000009 call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
    1   0.000060   0.000007 call s:NetrwInit("g:netrw_keepj","keepj")
    1   0.000045   0.000007 call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
    1   0.000044   0.000007 call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
    1              0.000004 if !exists("g:netrw_scp_cmd")
    1              0.000504  if executable("scp")
    1   0.000105   0.000030   call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
    1              0.000004  elseif executable("pscp")
                              if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable('c:\private.ppk')
                               call s:NetrwInit("g:netrw_scp_cmd", 'pscp -i c:\private.ppk')
                              else
                               call s:NetrwInit("g:netrw_scp_cmd", 'pscp -q')
                              endif
                             else
                              call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
                             endif
    1              0.000001 endif
                            
    1   0.000035   0.000006 call s:NetrwInit("g:netrw_sftp_cmd" , "sftp")
    1   0.000028   0.000005 call s:NetrwInit("g:netrw_ssh_cmd"  , "ssh")
                            
    1              0.000018 if (has("win32") || has("win95") || has("win64") || has("win16"))
                              \ && exists("g:netrw_use_nt_rcp")
                              \ && g:netrw_use_nt_rcp
                              \ && executable( $SystemRoot .'/system32/rcp.exe')
                             let s:netrw_has_nt_rcp = 1
                             let s:netrw_rcpmode    = '-b'
                            else
    1              0.000002  let s:netrw_has_nt_rcp = 0
    1              0.000002  let s:netrw_rcpmode    = ''
    1              0.000009 endif
                            
                            " ---------------------------------------------------------------------
                            " Default values for netrw's global variables {{{2
                            " Cygwin Detection ------- {{{3
    1              0.000004 if !exists("g:netrw_cygwin")
    1              0.000009  if has("win32") || has("win95") || has("win64") || has("win16")
                              if  has("win32unix") && &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
                               let g:netrw_cygwin= 1
                              else
                               let g:netrw_cygwin= 0
                              endif
                             else
    1              0.000002   let g:netrw_cygwin= 0
    1              0.000001  endif
    1              0.000001 endif
                            " Default values - a-c ---------- {{{3
    1   0.000032   0.000009 call s:NetrwInit("g:netrw_alto"        , &sb)
    1   0.000024   0.000005 call s:NetrwInit("g:netrw_altv"        , &spr)
    1   0.000022   0.000004 call s:NetrwInit("g:netrw_banner"      , 1)
    1   0.000022   0.000003 call s:NetrwInit("g:netrw_browse_split", 0)
    1   0.000038   0.000004 call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro nornu")
    1   0.000023   0.000005 call s:NetrwInit("g:netrw_chgwin"      , -1)
    1   0.000027   0.000004 call s:NetrwInit("g:netrw_compress"    , "gzip")
    1   0.000027   0.000005 call s:NetrwInit("g:netrw_ctags"       , "ctags")
    1              0.000005 if exists("g:netrw_cursorline") && !exists("g:netrw_cursor")
                             call netrw#ErrorMsg(s:NOTE,'g:netrw_cursorline is deprecated; use g:netrw_cursor instead',77)
                             let g:netrw_cursor= g:netrw_cursorline
                            endif
    1   0.000022   0.000003 call s:NetrwInit("g:netrw_cursor"      , 2)
    1              0.000004 let s:netrw_usercul = &cursorline
    1              0.000002 let s:netrw_usercuc = &cursorcolumn
    1   0.000036   0.000004 call s:NetrwInit("g:netrw_cygdrive","/cygdrive")
                            " Default values - d-g ---------- {{{3
    1   0.000024   0.000004 call s:NetrwInit("s:didstarstar",0)
    1   0.000019   0.000003 call s:NetrwInit("g:netrw_dirhist_cnt"      , 0)
    1   0.000034   0.000006 call s:NetrwInit("g:netrw_decompress"       , '{ ".gz" : "gunzip", ".bz2" : "bunzip2", ".zip" : "unzip", ".tar" : "tar -xf", ".xz" : "unxz" }')
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_dirhistmax"       , 10)
    1   0.000022   0.000004 call s:NetrwInit("g:netrw_errorlvl"  , s:NOTE)
    1   0.000022   0.000003 call s:NetrwInit("g:netrw_fastbrowse"       , 1)
    1   0.000034   0.000007 call s:NetrwInit("g:netrw_ftp_browse_reject", '^total\s\+\d\+$\|^Trying\s\+\d\+.*$\|^KERBEROS_V\d rejected\|^Security extensions not\|No such file\|: connect to address [0-9a-fA-F:]*: No route to host$')
    1              0.000003 if !exists("g:netrw_ftp_list_cmd")
    1              0.000004  if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
    1              0.000002   let g:netrw_ftp_list_cmd     = "ls -lF"
    1              0.000009   let g:netrw_ftp_timelist_cmd = "ls -tlF"
    1              0.000002   let g:netrw_ftp_sizelist_cmd = "ls -slF"
    1              0.000001  else
                              let g:netrw_ftp_list_cmd     = "dir"
                              let g:netrw_ftp_timelist_cmd = "dir"
                              let g:netrw_ftp_sizelist_cmd = "dir"
                             endif
    1              0.000001 endif
    1   0.000029   0.000005 call s:NetrwInit("g:netrw_ftpmode",'binary')
                            " Default values - h-lh ---------- {{{3
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_hide",1)
    1              0.000003 if !exists("g:netrw_ignorenetrc")
    1              0.000022  if &shell =~ '\c\<\%(cmd\|4nt\)\.exe$'
                              let g:netrw_ignorenetrc= 1
                             else
    1              0.000002   let g:netrw_ignorenetrc= 0
    1              0.000001  endif
    1              0.000001 endif
    1   0.000024   0.000005 call s:NetrwInit("g:netrw_keepdir",1)
    1              0.000002 if !exists("g:netrw_list_cmd")
    1              0.000006  if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
                              if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
                               " provide a pscp-based listing command
                               let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
                              endif
                              if exists("g:netrw_list_cmd_options")
                               let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME: ".g:netrw_list_cmd_options
                              else
                               let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
                              endif
                             elseif executable(g:netrw_ssh_cmd)
                              " provide a scp-based default listing command
    1              0.000009   if exists("g:netrw_list_cmd_options")
                               let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa ".g:netrw_list_cmd_options
                              else
    1              0.000006    let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
    1              0.000001   endif
    1              0.000014  else
                            "  call Decho(g:netrw_ssh_cmd." is not executable",'~'.expand("<slnum>"))
                              let g:netrw_list_cmd= ""
                             endif
    1              0.000001 endif
    1   0.000051   0.000013 call s:NetrwInit("g:netrw_list_hide","")
                            " Default values - lh-lz ---------- {{{3
    1              0.000003 if exists("g:netrw_local_copycmd")
                             let g:netrw_localcopycmd= g:netrw_local_copycmd
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_copycmd is deprecated in favor of g:netrw_localcopycmd",84)
                            endif
    1              0.000003 if !exists("g:netrw_localcmdshell")
    1              0.000002  let g:netrw_localcmdshell= ""
    1              0.000001 endif
    1              0.000002 if !exists("g:netrw_localcopycmd")
    1              0.000012  if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               let g:netrw_localcopycmd= "cp"
                              else
                               let g:netrw_localcopycmd= expand("$COMSPEC")." /c copy"
                              endif
                             elseif has("unix") || has("macunix")
    1              0.000002   let g:netrw_localcopycmd= "cp"
    1              0.000000  else
                              let g:netrw_localcopycmd= ""
                             endif
    1              0.000000 endif
    1              0.000003 if !exists("g:netrw_localcopydircmd")
    1              0.000017  if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               let g:netrw_localcopydircmd= "cp -R"
                              else
                               let g:netrw_localcopycmd= expand("$COMSPEC")." /c xcopy /e /c /h /i /k"
                              endif
                             elseif has("unix") || has("macunix")
    1              0.000002   let g:netrw_localcopydircmd= "cp -R"
    1              0.000001  else
                              let g:netrw_localcopycmd= ""
                             endif
    1              0.000000 endif
    1              0.000003 if exists("g:netrw_local_mkdir")
                             let g:netrw_localmkdir= g:netrw_local_mkdir
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
                            endif
    1              0.000011 if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               call s:NetrwInit("g:netrw_localmkdir","mkdir")
                              else
                               let g:netrw_localmkdir= expand("$COMSPEC")." /c mkdir"
                              endif
                            else
    1   0.000034   0.000005  call s:NetrwInit("g:netrw_localmkdir","mkdir")
    1              0.000001 endif
    1   0.000039   0.000013 call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
    1              0.000003 if exists("g:netrw_local_movecmd")
                             let g:netrw_localmovecmd= g:netrw_local_movecmd
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_movecmd is deprecated in favor of g:netrw_localmovecmd",88)
                            endif
    1              0.000002 if !exists("g:netrw_localmovecmd")
    1              0.000010  if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               let g:netrw_localmovecmd= "mv"
                              else
                               let g:netrw_localmovecmd= expand("$COMSPEC")." /c move"
                              endif
                             elseif has("unix") || has("macunix")
    1              0.000002   let g:netrw_localmovecmd= "mv"
    1              0.000000  else
                              let g:netrw_localmovecmd= ""
                             endif
    1              0.000001 endif
    1              0.000006 if v:version < 704 || !has("patch1109")
                             if exists("g:netrw_local_rmdir")
                              let g:netrw_localrmdir= g:netrw_local_rmdir
                              call netrw#ErrorMsg(s:NOTE,"g:netrw_local_rmdir is deprecated in favor of g:netrw_localrmdir",86)
                             endif
                             if has("win32") || has("win95") || has("win64") || has("win16")
                               if g:netrw_cygwin
                                call s:NetrwInit("g:netrw_localrmdir","rmdir")
                               else
                                let g:netrw_localrmdir= expand("$COMSPEC")." /c rmdir"
                               endif
                             else
                              call s:NetrwInit("g:netrw_localrmdir","rmdir")
                             endif
                            endif
    1   0.000027   0.000005 call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
                            " sanity checks
    1              0.000002 if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
                             let g:netrw_liststyle= s:THINLIST
                            endif
    1              0.000003 if g:netrw_liststyle == s:LONGLIST && g:netrw_scp_cmd !~ '^pscp'
                             let g:netrw_list_cmd= g:netrw_list_cmd." -l"
                            endif
                            " Default values - m-r ---------- {{{3
    1   0.000030   0.000004 call s:NetrwInit("g:netrw_markfileesc"   , '*./[\~')
    1   0.000024   0.000004 call s:NetrwInit("g:netrw_maxfilenamelen", 32)
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_menu"          , 1)
    1   0.000037   0.000005 call s:NetrwInit("g:netrw_mkdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME mkdir")
    1   0.000030   0.000011 call s:NetrwInit("g:netrw_mousemaps"     , (exists("+mouse") && &mouse =~# '[anh]'))
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_retmap"        , 0)
    1              0.000004 if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
    1   0.000029   0.000004  call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
    1              0.000004 elseif has("win32") || has("win95") || has("win64") || has("win16")
                             call s:NetrwInit("g:netrw_chgperm"       , "cacls FILENAME /e /p PERM")
                            else
                             call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
                            endif
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_preview"       , 0)
    1   0.000035   0.000004 call s:NetrwInit("g:netrw_scpport"       , "-P")
    1   0.000028   0.000004 call s:NetrwInit("g:netrw_servername"    , "NETRWSERVER")
    1   0.000026   0.000004 call s:NetrwInit("g:netrw_sshport"       , "-p")
    1   0.000029   0.000006 call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
    1   0.000036   0.000005 call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
    1   0.000028   0.000005 call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
    1   0.000028   0.000005 call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f ")
                            " Default values - q-s ---------- {{{3
    1   0.000023   0.000004 call s:NetrwInit("g:netrw_quickhelp",0)
    1              0.000013 let s:QuickHelp= ["-:go up dir  D:delete  R:rename  s:sort-by  x:special",
                               \              "(create new)  %:file  d:directory",
                               \              "(windows split&open) o:horz  v:vert  p:preview",
                               \              "i:style  qf:file info  O:obtain  r:reverse",
                               \              "(marks)  mf:mark file  mt:set target  mm:move  mc:copy",
                               \              "(bookmarks)  mb:make  mB:delete  qb:list  gb:go to",
                               \              "(history)  qb:list  u:go up  U:go down",
                               \              "(targets)  mt:target Tb:use bookmark  Th:use history"]
                            " g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
    1   0.000045   0.000012 call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
    1              0.000005 if !exists("g:netrw_keepj") || g:netrw_keepj == "keepj"
    1   0.000032   0.000008  call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
    1              0.000001 else
                             call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil " : " ")
                            endif
    1   0.000027   0.000004 call s:NetrwInit("g:netrw_sort_by"       , "name") " alternatives: date                                      , size
    1   0.000026   0.000004 call s:NetrwInit("g:netrw_sort_options"  , "")
    1   0.000035   0.000006 call s:NetrwInit("g:netrw_sort_direction", "normal") " alternative: reverse  (z y x ...)
    1              0.000003 if !exists("g:netrw_sort_sequence")
    1              0.000002  if has("unix")
    1              0.000004   let g:netrw_sort_sequence= '[\/]$,\<core\%(\.\d\+\)\=\>,\.h$,\.c$,\.cpp$,\~\=\*$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
    1              0.000001  else
                              let g:netrw_sort_sequence= '[\/]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
                             endif
    1              0.000001 endif
    1   0.000024   0.000005 call s:NetrwInit("g:netrw_special_syntax"   , 0)
    1   0.000028   0.000004 call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
    1   0.000022   0.000004 call s:NetrwInit("g:netrw_suppress_gx_mesg",  1)
    1   0.000022   0.000004 call s:NetrwInit("g:netrw_use_noswf"        , 1)
    1   0.000027   0.000004 call s:NetrwInit("g:netrw_sizestyle"        ,"b")
                            " Default values - t-w ---------- {{{3
    1   0.000034   0.000011 call s:NetrwInit("g:netrw_timefmt","%c")
    1              0.000003 if !exists("g:netrw_xstrlen")
    1              0.000003  if exists("g:Align_xstrlen")
                              let g:netrw_xstrlen= g:Align_xstrlen
                             elseif exists("g:drawit_xstrlen")
                              let g:netrw_xstrlen= g:drawit_xstrlen
                             elseif &enc == "latin1" || !has("multi_byte")
                              let g:netrw_xstrlen= 0
                             else
    1              0.000002   let g:netrw_xstrlen= 1
    1              0.000000  endif
    1              0.000000 endif
    1   0.000029   0.000005 call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
    1   0.000022   0.000003 call s:NetrwInit("g:netrw_win95ftp",1)
    1   0.000022   0.000003 call s:NetrwInit("g:netrw_winsize",50)
    1   0.000030   0.000011 call s:NetrwInit("g:netrw_wiw",1)
    1              0.000003 if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
                            " ---------------------------------------------------------------------
                            " Default values for netrw's script variables: {{{2
    1   0.000029   0.000004 call s:NetrwInit("g:netrw_fname_escape",' ?&;%')
    1              0.000011 if has("win32") || has("win95") || has("win64") || has("win16")
                             call s:NetrwInit("g:netrw_glob_escape",'*?`{[]$')
                            else
    1   0.000028   0.000004  call s:NetrwInit("g:netrw_glob_escape",'*[]?`{~$\')
    1              0.000001 endif
    1   0.000027   0.000004 call s:NetrwInit("g:netrw_menu_escape",'.&? \')
    1   0.000035   0.000011 call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
    1   0.000029   0.000005 call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
    1              0.000005 if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
                             let s:treedepthstring= "│ "
                            else
    1              0.000002  let s:treedepthstring= "| "
    1              0.000001 endif
    1   0.000028   0.000004 call s:NetrwInit("s:netrw_nbcd",'{}')
                            
                            " BufEnter event ignored by decho when following variable is true
                            "  Has a side effect that doau BufReadPost doesn't work, so
                            "  files read by network transfer aren't appropriately highlighted.
                            "let g:decho_bufenter = 1	"Decho
                            
                            " ======================
                            "  Netrw Initialization: {{{1
                            " ======================
    1              0.000008 if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
                            " call Decho("installed beval events",'~'.expand("<slnum>"))
                             let &l:bexpr = "netrw#BalloonHelp()"
                             au FileType netrw	setl beval
                             au WinLeave *		if &ft == "netrw" && exists("s:initbeval")|let &beval= s:initbeval|endif
                             au VimEnter * 		let s:initbeval= &beval
                            "else " Decho
                            " if v:version < 700           | call Decho("did not install beval events: v:version=".v:version." < 700","~".expand("<slnum>"))     | endif
                            " if !has("balloon_eval")      | call Decho("did not install beval events: does not have balloon_eval","~".expand("<slnum>"))        | endif
                            " if exists("s:initbeval")     | call Decho("did not install beval events: s:initbeval exists","~".expand("<slnum>"))                | endif
                            " if exists("g:netrw_nobeval") | call Decho("did not install beval events: g:netrw_nobeval exists","~".expand("<slnum>"))            | endif
                            " if !has("syntax")            | call Decho("did not install beval events: does not have syntax highlighting","~".expand("<slnum>")) | endif
                            " if exists("g:syntax_on")     | call Decho("did not install beval events: g:syntax_on exists","~".expand("<slnum>"))                | endif
                            endif
    1              0.000013 au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif
                            
    1              0.000004 if g:netrw_keepj =~# "keepj"
    1              0.000025  com! -nargs=*	NetrwKeepj	keepj <args>
    1              0.000001 else
                             let g:netrw_keepj= ""
                             com! -nargs=*	NetrwKeepj	<args>
                            endif
                            
                            " ==============================
                            "  Netrw Utility Functions: {{{1
                            " ==============================
                            
                            " ---------------------------------------------------------------------
                            " netrw#BalloonHelp: {{{2
    1              0.000007 if v:version >= 700 && has("balloon_eval") && has("syntax") && exists("g:syntax_on") && !exists("g:netrw_nobeval")
                            " call Decho("loading netrw#BalloonHelp()",'~'.expand("<slnum>"))
                             fun! netrw#BalloonHelp()
                               if &ft != "netrw"
                                return ""
                               endif
                               if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
                                let mesg= ""
                               elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
                                let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
                               elseif     getline(v:beval_lnum) =~ '^"\s*/'
                                let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
                               elseif     v:beval_text == "Sorted" || v:beval_text == "by"
                                let mesg = 's: sort by name, time, file size, extension   r: reverse sorting order   mt: mark target'
                               elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
                                let mesg = "S: edit sorting sequence"
                               elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
                                let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
                               elseif v:beval_text == "Quick" || v:beval_text == "Help"
                                let mesg = "Help: press <F1>"
                               elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
                                let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
                               else
                                let mesg= ""
                               endif
                               return mesg
                             endfun
                            "else " Decho
                            " if v:version < 700            |call Decho("did not load netrw#BalloonHelp(): vim version ".v:version." < 700 -","~".expand("<slnum>"))|endif
                            " if !has("balloon_eval")       |call Decho("did not load netrw#BalloonHelp(): does not have balloon eval","~".expand("<slnum>"))       |endif
                            " if !has("syntax")             |call Decho("did not load netrw#BalloonHelp(): syntax disabled","~".expand("<slnum>"))                  |endif
                            " if !exists("g:syntax_on")     |call Decho("did not load netrw#BalloonHelp(): g:syntax_on n/a","~".expand("<slnum>"))                  |endif
                            " if  exists("g:netrw_nobeval") |call Decho("did not load netrw#BalloonHelp(): g:netrw_nobeval exists","~".expand("<slnum>"))           |endif
                            endif
                            
                            " ------------------------------------------------------------------------
                            " netrw#Explore: launch the local browser in the directory of the current file {{{2
                            "          indx:  == -1: Nexplore
                            "                 == -2: Pexplore
                            "                 ==  +: this is overloaded:
                            "                      * If Nexplore/Pexplore is in use, then this refers to the
                            "                        indx'th item in the w:netrw_explore_list[] of items which
                            "                        matched the */pattern **/pattern *//pattern **//pattern
                            "                      * If Hexplore or Vexplore, then this will override
                            "                        g:netrw_winsize to specify the qty of rows or columns the
                            "                        newly split window should have.
                            "          dosplit==0: the window will be split iff the current file has been modified and hidden not set
                            "          dosplit==1: the window will be split before running the local browser
                            "          style == 0: Explore     style == 1: Explore!
                            "                == 2: Hexplore    style == 3: Hexplore!
                            "                == 4: Vexplore    style == 5: Vexplore!
                            "                == 6: Texplore
    1              0.000004 fun! netrw#Explore(indx,dosplit,style,...)
                            "  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%")." ft=".&ft)
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                              if !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                            "   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
                              endif
                            
                              " record current file for Rexplore's benefit
                              if &ft != "netrw"
                               let w:netrw_rexfile= expand("%:p")
                              endif
                            
                              " record current directory
                              let curdir     = simplify(b:netrw_curdir)
                              let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
                              if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                               let curdir= substitute(curdir,'\','/','g')
                              endif
                            "  call Decho("curdir<".curdir.">  curfiledir<".curfiledir.">",'~'.expand("<slnum>"))
                            
                              " using completion, directories with spaces in their names (thanks, Bill Gates, for a truly dumb idea)
                              " will end up with backslashes here.  Solution: strip off backslashes that precede white space and
                              " try Explore again.
                              if a:0 > 0
                            "   call Decho('considering retry: a:1<'.a:1.'>: '.
                                 \ ((a:1 =~ "\\\s")?                   'has backslash whitespace' : 'does not have backslash whitespace').', '.
                                 \ ((filereadable(s:NetrwFile(a:1)))?  'is readable'              : 'is not readable').', '.
                                 \ ((isdirectory(s:NetrwFile(a:1))))?  'is a directory'           : 'is not a directory',
                                 \ '~'.expand("<slnum>"))
                               if a:1 =~ "\\\s" && !filereadable(s:NetrwFile(a:1)) && !isdirectory(s:NetrwFile(a:1))
                            "    call Decho("re-trying Explore with <".substitute(a:1,'\\\(\s\)','\1','g').">",'~'.expand("<slnum>"))
                                call netrw#Explore(a:indx,a:dosplit,a:style,substitute(a:1,'\\\(\s\)','\1','g'))
                            "    call Dret("netrw#Explore : returning from retry")
                                return
                            "   else " Decho
                            "    call Decho("retry not needed",'~'.expand("<slnum>"))
                               endif
                              endif
                            
                              " save registers
                              if has("clipboard")
                               sil! let keepregstar = @*
                               sil! let keepregplus = @+
                              endif
                              sil! let keepregslash= @/
                            
                              " if   dosplit
                              " -or- file has been modified AND file not hidden when abandoned
                              " -or- Texplore used
                              if a:dosplit || (&modified && &hidden == 0 && &bufhidden != "hide") || a:style == 6
                            "   call Decho("case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified",'~'.expand("<slnum>"))
                               call s:SaveWinVars()
                               let winsz= g:netrw_winsize
                               if a:indx > 0
                                let winsz= a:indx
                               endif
                            
                               if a:style == 0      " Explore, Sexplore
                            "    call Decho("style=0: Explore or Sexplore",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "noswapfile ".winsz."wincmd s"
                            "    call Decho("exe noswapfile ".winsz."wincmd s",'~'.expand("<slnum>"))
                            
                               elseif a:style == 1  "Explore!, Sexplore!
                            "    call Decho("style=1: Explore! or Sexplore!",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "keepalt noswapfile ".winsz."wincmd v"
                            "    call Decho("exe keepalt noswapfile ".winsz."wincmd v",'~'.expand("<slnum>"))
                            
                               elseif a:style == 2  " Hexplore
                            "    call Decho("style=2: Hexplore",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "keepalt noswapfile bel ".winsz."wincmd s"
                            "    call Decho("exe keepalt noswapfile bel ".winsz."wincmd s",'~'.expand("<slnum>"))
                            
                               elseif a:style == 3  " Hexplore!
                            "    call Decho("style=3: Hexplore!",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "keepalt noswapfile abo ".winsz."wincmd s"
                            "    call Decho("exe keepalt noswapfile abo ".winsz."wincmd s",'~'.expand("<slnum>"))
                            
                               elseif a:style == 4  " Vexplore
                            "    call Decho("style=4: Vexplore",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "keepalt noswapfile lefta ".winsz."wincmd v"
                            "    call Decho("exe keepalt noswapfile lefta ".winsz."wincmd v",'~'.expand("<slnum>"))
                            
                               elseif a:style == 5  " Vexplore!
                            "    call Decho("style=5: Vexplore!",'~'.expand("<slnum>"))
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                if winsz == 0|let winsz= ""|endif
                                exe "keepalt noswapfile rightb ".winsz."wincmd v"
                            "    call Decho("exe keepalt noswapfile rightb ".winsz."wincmd v",'~'.expand("<slnum>"))
                            
                               elseif a:style == 6  " Texplore
                                call s:SaveBufVars()
                            "    call Decho("style  = 6: Texplore",'~'.expand("<slnum>"))
                                exe "keepalt tabnew ".fnameescape(curdir)
                            "    call Decho("exe keepalt tabnew ".fnameescape(curdir),'~'.expand("<slnum>"))
                                call s:RestoreBufVars()
                               endif
                               call s:RestoreWinVars()
                            "  else " Decho
                            "   call Decho("case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6",'~'.expand("<slnum>"))
                              endif
                              NetrwKeepj norm! 0
                            
                              if a:0 > 0
                            "   call Decho("case [a:0=".a:0."] > 0: a:1<".a:1.">",'~'.expand("<slnum>"))
                               if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
                            "    call Decho("..case a:1<".a:1.">: starts with ~ and unix or cygwin",'~'.expand("<slnum>"))
                                let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
                            "    call Decho("..using dirname<".dirname.">  (case: ~ && unix||cygwin)",'~'.expand("<slnum>"))
                               elseif a:1 == '.'
                            "    call Decho("..case a:1<".a:1.">: matches .",'~'.expand("<slnum>"))
                                let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
                                if dirname !~ '/$'
                                 let dirname= dirname."/"
                                endif
                            "    call Decho("..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")",'~'.expand("<slnum>"))
                               elseif a:1 =~ '\$'
                            "    call Decho("..case a:1<".a:1.">: matches ending $",'~'.expand("<slnum>"))
                                let dirname= simplify(expand(a:1))
                            "    call Decho("..using user-specified dirname<".dirname."> with $env-var",'~'.expand("<slnum>"))
                               elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
                            "    call Decho("..case a:1<".a:1.">: other, not pattern or filepattern",'~'.expand("<slnum>"))
                                let dirname= simplify(a:1)
                            "    call Decho("..using user-specified dirname<".dirname.">",'~'.expand("<slnum>"))
                               else
                            "    call Decho("..case a:1: pattern or filepattern",'~'.expand("<slnum>"))
                                let dirname= a:1
                               endif
                              else
                               " clear explore
                            "   call Decho("case a:0=".a:0.": clearing Explore list",'~'.expand("<slnum>"))
                               call s:NetrwClearExplore()
                            "   call Dret("netrw#Explore : cleared list")
                               return
                              endif
                            
                            "  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
                              if dirname =~ '\.\./\=$'
                               let dirname= simplify(fnamemodify(dirname,':p:h'))
                              elseif dirname =~ '\.\.' || dirname == '.'
                               let dirname= simplify(fnamemodify(dirname,':p'))
                              endif
                            "  call Decho("dirname<".dirname.">  (after simplify)",'~'.expand("<slnum>"))
                            
                              if dirname =~ '^\*//'
                               " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
                            "   call Decho("case starpat=1: Explore *//pattern",'~'.expand("<slnum>"))
                               let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
                               let starpat= 1
                            "   call Decho("..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))
                               if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                              elseif dirname =~ '^\*\*//'
                               " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
                            "   call Decho("case starpat=2: Explore **//pattern",'~'.expand("<slnum>"))
                               let pattern= substitute(dirname,'^\*\*//','','')
                               let starpat= 2
                            "   call Decho("..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))
                            
                              elseif dirname =~ '/\*\*/'
                               " handle .../**/.../filepat
                            "   call Decho("case starpat=4: Explore .../**/.../filepat",'~'.expand("<slnum>"))
                               let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
                               if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
                                let b:netrw_curdir = prefixdir
                               else
                                let b:netrw_curdir= getcwd().'/'.prefixdir
                               endif
                               let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
                               let starpat= 4
                            "   call Decho("..pwd<".getcwd()."> dirname<".dirname.">",'~'.expand("<slnum>"))
                            "   call Decho("..case Explore ../**/../filepat (starpat=".starpat.")",'~'.expand("<slnum>"))
                            
                              elseif dirname =~ '^\*/'
                               " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                               let starpat= 3
                            "   call Decho("case starpat=3: Explore */filepat (starpat=".starpat.")",'~'.expand("<slnum>"))
                            
                              elseif dirname=~ '^\*\*/'
                               " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                               let starpat= 4
                            "   call Decho("case starpat=4: Explore **/filepat (starpat=".starpat.")",'~'.expand("<slnum>"))
                            
                              else
                               let starpat= 0
                            "   call Decho("case starpat=0: default",'~'.expand("<slnum>"))
                              endif
                            
                              if starpat == 0 && a:indx >= 0
                               " [Explore Hexplore Vexplore Sexplore] [dirname]
                            "   call Decho("case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore",'~'.expand("<slnum>"))
                               if dirname == ""
                                let dirname= curfiledir
                            "    call Decho("..empty dirname, using current file's directory<".dirname.">",'~'.expand("<slnum>"))
                               endif
                               if dirname =~# '^scp://' || dirname =~ '^ftp://'
                                call netrw#Nread(2,dirname)
                               else
                                if dirname == ""
                                 let dirname= getcwd()
                                elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
                                 " Windows : check for a drive specifier, or else for a remote share name ('\\Foo' or '//Foo',
                                 " depending on whether backslashes have been converted to forward slashes by earlier code).
                                 if dirname !~ '^[a-zA-Z]:' && dirname !~ '^\\\\\w\+' && dirname !~ '^//\w\+'
                                  let dirname= b:netrw_curdir."/".dirname
                                 endif
                                elseif dirname !~ '^/'
                                 let dirname= b:netrw_curdir."/".dirname
                                endif
                            "    call Decho("..calling LocalBrowseCheck(dirname<".dirname.">)",'~'.expand("<slnum>"))
                                call netrw#LocalBrowseCheck(dirname)
                            "    call Decho(" modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                               endif
                               if exists("w:netrw_bannercnt")
                                " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
                                " If one wants to return the same place in the netrw window, use :Rex instead.
                                exe w:netrw_bannercnt
                               endif
                            
                            "   call Decho("curdir<".curdir.">",'~'.expand("<slnum>"))
                               " ---------------------------------------------------------------------
                               " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
                            "   if has("win32") || has("win95") || has("win64") || has("win16")
                            "    NetrwKeepj call search('\<'.substitute(curdir,'^.*[/\\]','','e').'\>','cW')
                            "   else
                            "    NetrwKeepj call search('\<'.substitute(curdir,'^.*/','','e').'\>','cW')
                            "   endif
                               " ---------------------------------------------------------------------
                            
                              " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
                              " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
                              " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                              " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                              elseif a:indx <= 0
                               " Nexplore, Pexplore, Explore: handle starpat
                            "   call Decho("case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx,'~'.expand("<slnum>"))
                               if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
                            "    call Decho("..set up <s-up> and <s-down> maps",'~'.expand("<slnum>"))
                                let s:didstarstar= 1
                                nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                                nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                               endif
                            
                               if has("path_extra")
                            "    call Decho("..starpat=".starpat.": has +path_extra",'~'.expand("<slnum>"))
                                if !exists("w:netrw_explore_indx")
                                 let w:netrw_explore_indx= 0
                                endif
                            
                                let indx = a:indx
                            "    call Decho("..starpat=".starpat.": set indx= [a:indx=".indx."]",'~'.expand("<slnum>"))
                            
                                if indx == -1
                                 " Nexplore
                            "     call Decho("..case Nexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
                                 if !exists("w:netrw_explore_list") " sanity check
                                  NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
                                  if has("clipboard")
                                   sil! let @* = keepregstar
                                   sil! let @+ = keepregstar
                                  endif
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore")
                                  return
                                 endif
                                 let indx= w:netrw_explore_indx
                                 if indx < 0                        | let indx= 0                           | endif
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                                 let curfile= w:netrw_explore_list[indx]
                            "     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
                                 while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
                                  let indx= indx + 1
                            "      call Decho("....indx=".indx." (Nexplore while loop)",'~'.expand("<slnum>"))
                                 endwhile
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                            "     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))
                            
                                elseif indx == -2
                                 " Pexplore
                            "     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
                                 if !exists("w:netrw_explore_list") " sanity check
                                  NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
                                  if has("clipboard")
                                   sil! let @* = keepregstar
                                   sil! let @+ = keepregstar
                                  endif
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore")
                                  return
                                 endif
                                 let indx= w:netrw_explore_indx
                                 if indx < 0                        | let indx= 0                           | endif
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                                 let curfile= w:netrw_explore_list[indx]
                            "     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
                                 while indx >= 0 && curfile == w:netrw_explore_list[indx]
                                  let indx= indx - 1
                            "      call Decho("....indx=".indx." (Pexplore while loop)",'~'.expand("<slnum>"))
                                 endwhile
                                 if indx < 0                        | let indx= 0                           | endif
                            "     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))
                            
                                else
                                 " Explore -- initialize
                                 " build list of files to Explore with Nexplore/Pexplore
                            "     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")",'~'.expand("<slnum>"))
                                 NetrwKeepj keepalt call s:NetrwClearExplore()
                                 let w:netrw_explore_indx= 0
                                 if !exists("b:netrw_curdir")
                                  let b:netrw_curdir= getcwd()
                                 endif
                            "     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                            
                                 " switch on starpat to build the w:netrw_explore_list of files
                                 if starpat == 1
                                  " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
                            "      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls,'~'.expand("<slnum>"))
                            "      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
                                  try
                                   exe "NetrwKeepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
                                  catch /^Vim\%((\a\+)\)\=:E480/
                                   keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
                            "       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
                                   return
                                  endtry
                                  let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
                                  if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                                 elseif starpat == 2
                                  " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
                            "      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)",'~'.expand("<slnum>"))
                            "      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
                                  try
                                   exe "sil NetrwKeepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
                                  catch /^Vim\%((\a\+)\)\=:E480/
                                   keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
                                   if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                                   if has("clipboard")
                                    sil! let @* = keepregstar
                                    sil! let @+ = keepregstar
                                   endif
                                   sil! let @/ = keepregslash
                            "       call Dret("netrw#Explore : no files matched pattern")
                                   return
                                  endtry
                                  let s:netrw_curdir       = b:netrw_curdir
                                  let w:netrw_explore_list = getqflist()
                                  let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
                                  if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                                 elseif starpat == 3
                                  " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                            "      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
                                  let filepat= substitute(dirname,'^\*/','','')
                                  let filepat= substitute(filepat,'^[%#<]','\\&','')
                            "      call Decho("....b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                            "      call Decho("....filepat<".filepat.">",'~'.expand("<slnum>"))
                                  let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
                                  if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif
                            
                                 elseif starpat == 4
                                  " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                            "      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
                                  let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
                                  if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
                                 endif " switch on starpat to build w:netrw_explore_list
                            
                                 let w:netrw_explore_listlen = len(w:netrw_explore_list)
                            "     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">",'~'.expand("<slnum>"))
                            "     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen,'~'.expand("<slnum>"))
                            
                                 if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
                                  keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
                                  if has("clipboard")
                                   sil! let @* = keepregstar
                                   sil! let @+ = keepregstar
                                  endif
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore : no files matched")
                                  return
                                 endif
                                endif  " if indx ... endif
                            
                                " NetrwStatusLine support - for exploring support
                                let w:netrw_explore_indx= indx
                            "    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen,'~'.expand("<slnum>"))
                            
                                " wrap the indx around, but issue a note
                                if indx >= w:netrw_explore_listlen || indx < 0
                            "     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")",'~'.expand("<slnum>"))
                                 let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
                                 let w:netrw_explore_indx= indx
                                 keepalt NetrwKeepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
                                endif
                            
                                exe "let dirfile= w:netrw_explore_list[".indx."]"
                            "    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">",'~'.expand("<slnum>"))
                                let newdir= substitute(dirfile,'/[^/]*$','','e')
                            "    call Decho("....newdir<".newdir.">",'~'.expand("<slnum>"))
                            
                            "    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)",'~'.expand("<slnum>"))
                                call netrw#LocalBrowseCheck(newdir)
                                if !exists("w:netrw_liststyle")
                                 let w:netrw_liststyle= g:netrw_liststyle
                                endif
                                if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
                                 keepalt NetrwKeepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
                                else
                                 keepalt NetrwKeepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
                                endif
                                let w:netrw_explore_mtchcnt = indx + 1
                                let w:netrw_explore_bufnr   = bufnr("%")
                                let w:netrw_explore_line    = line(".")
                                keepalt NetrwKeepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
                            "    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line,'~'.expand("<slnum>"))
                            
                               else
                            "    call Decho("..your vim does not have +path_extra",'~'.expand("<slnum>"))
                                if !exists("g:netrw_quiet")
                                 keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
                                endif
                                if has("clipboard")
                                 sil! let @* = keepregstar
                                 sil! let @+ = keepregstar
                                endif
                                sil! let @/ = keepregslash
                            "    call Dret("netrw#Explore : missing +path_extra")
                                return
                               endif
                            
                              else
                            "   call Decho("..default case: Explore newdir<".dirname.">",'~'.expand("<slnum>"))
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
                                sil! unlet w:netrw_treedict
                                sil! unlet w:netrw_treetop
                               endif
                               let newdir= dirname
                               if !exists("b:netrw_curdir")
                                NetrwKeepj call netrw#LocalBrowseCheck(getcwd())
                               else
                                NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
                               endif
                              endif
                            
                              " visual display of **/ **// */ Exploration files
                            "  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">",'~'.expand("<slnum>"))
                              if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
                            "   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"),'~'.expand("<slnum>"))
                               if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
                                " only update match list when current directory isn't the same as before
                            "    call Decho("only update match list when current directory not the same as before",'~'.expand("<slnum>"))
                                let s:explore_prvdir = b:netrw_curdir
                                let s:explore_match  = ""
                                let dirlen           = strlen(b:netrw_curdir)
                                if b:netrw_curdir !~ '/$'
                                 let dirlen= dirlen + 1
                                endif
                                let prvfname= ""
                                for fname in w:netrw_explore_list
                            "     call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                                 if fname =~ '^'.b:netrw_curdir
                                  if s:explore_match == ""
                                   let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
                                  else
                                   let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
                                  endif
                                 elseif fname !~ '^/' && fname != prvfname
                                  if s:explore_match == ""
                                   let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
                                  else
                                   let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
                                  endif
                                 endif
                                 let prvfname= fname
                                endfor
                            "    call Decho("explore_match<".s:explore_match.">",'~'.expand("<slnum>"))
                                exe "2match netrwMarkFile /".s:explore_match."/"
                               endif
                               echo "<s-up>==Pexplore  <s-down>==Nexplore"
                              else
                               2match none
                               if exists("s:explore_match")  | unlet s:explore_match  | endif
                               if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
                               echo " "
                            "   call Decho("cleared explore match list",'~'.expand("<slnum>"))
                              endif
                            
                              " since Explore may be used to initialize netrw's browser,
                              " there's no danger of a late FocusGained event on initialization.
                              " Consequently, set s:netrw_events to 2.
                              let s:netrw_events= 2
                              if has("clipboard")
                               sil! let @* = keepregstar
                               sil! let @+ = keepregstar
                              endif
                              sil! let @/ = keepregslash
                            "  call Dret("netrw#Explore : @/<".@/.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
    1              0.000004 fun! netrw#Lexplore(count,rightside,...)
                            "  call Dfunc("netrw#Lexplore(count=".a:count."rightside=".a:rightside.",...) a:0=".a:0." ft=".&ft)
                              let curwin= winnr()
                            
                              if a:0 > 0 && a:1 != ""
                               " if a netrw window is already on the left-side of the tab
                               " and a directory has been specified, explore with that
                               " directory.
                               let a1 = expand(a:1)
                            "   call Decho("a:1<".a:1.">  curwin#".curwin,'~'.expand("<slnum>"))
                               exe "1wincmd w"
                               if &ft == "netrw"
                            "    call Decho("exe Explore ".fnameescape(a:1),'~'.expand("<slnum>"))
                                exe "Explore ".fnameescape(a1)
                                exe curwin."wincmd w"
                                if exists("t:netrw_lexposn")
                            "     call Decho("forgetting t:netrw_lexposn",'~'.expand("<slnum>"))
                                 unlet t:netrw_lexposn
                                endif
                            "    call Dret("netrw#Lexplore")
                                return
                               endif
                               exe curwin."wincmd w"
                              else
                               let a1= ""
                              endif
                            
                              if exists("t:netrw_lexbufnr")
                               " check if t:netrw_lexbufnr refers to a netrw window
                               let lexwinnr = bufwinnr(t:netrw_lexbufnr)
                              else
                               let lexwinnr= 0
                              endif
                            
                              if lexwinnr > 0
                               " close down netrw explorer window
                            "  call Decho("t:netrw_lexbufnr#".t:netrw_lexbufnr.": close down netrw window",'~'.expand("<slnum>"))
                               exe lexwinnr."wincmd w"
                               let g:netrw_winsize = -winwidth(0)
                               let t:netrw_lexposn = winsaveview()
                            "   call Decho("saving posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
                            "   call Decho("saving t:netrw_lexposn",'~'.expand("<slnum>"))
                               close
                               if lexwinnr < curwin
                                let curwin= curwin - 1
                               endif
                               exe curwin."wincmd w"
                               unlet t:netrw_lexbufnr
                            
                              else
                               " open netrw explorer window
                            "   call Decho("t:netrw_lexbufnr<n/a>: open netrw explorer window",'~'.expand("<slnum>"))
                               exe "1wincmd w"
                               let keep_altv    = g:netrw_altv
                               let g:netrw_altv = 0
                               if a:count != 0
                                let netrw_winsize   = g:netrw_winsize
                                let g:netrw_winsize = a:count
                               endif
                               let curfile= expand("%")
                            "   call Decho("curfile<".curfile.">",'~'.expand("<slnum>"))
                               exe (a:rightside? "botright" : "topleft")." vertical ".((g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize) . " new"
                               if a:0 > 0 && a1 != ""
                            "    call Decho("case 1: Explore ".a1,'~'.expand("<slnum>"))
                                exe "Explore ".fnameescape(a1)
                               elseif curfile =~ '^\a\{3,}://'
                            "    call Decho("case 2: Explore ".substitute(curfile,'[^/\\]*$','',''),'~'.expand("<slnum>"))
                                exe "Explore ".substitute(curfile,'[^/\\]*$','','')
                               else
                            "    call Decho("case 3: Explore .",'~'.expand("<slnum>"))
                                Explore .
                               endif
                               if a:count != 0
                                let g:netrw_winsize = netrw_winsize
                               endif
                               setlocal winfixwidth
                               let g:netrw_altv     = keep_altv
                               let t:netrw_lexbufnr = bufnr("%")
                               if exists("t:netrw_lexposn")
                            "    call Decho("restoring to t:netrw_lexposn",'~'.expand("<slnum>"))
                            "    call Decho("restoring posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
                                call winrestview(t:netrw_lexposn)
                                unlet t:netrw_lexposn
                               endif
                              endif
                            
                              " set up default window for editing via <cr>
                              if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
                               if a:rightside
                                let g:netrw_chgwin= 1
                               else
                                let g:netrw_chgwin= 2
                               endif
                              endif
                            
                            "  call Dret("netrw#Lexplore")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Clean: remove netrw {{{2
                            " supports :NetrwClean  -- remove netrw from first directory on runtimepath
                            "          :NetrwClean! -- remove netrw from all directories on runtimepath
    1              0.000002 fun! netrw#Clean(sys)
                            "  call Dfunc("netrw#Clean(sys=".a:sys.")")
                            
                              if a:sys
                               let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
                              else
                               let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
                              endif
                            "  call Decho("choice=".choice,'~'.expand("<slnum>"))
                              let diddel= 0
                              let diddir= ""
                            
                              if choice == 1
                               for dir in split(&rtp,',')
                                if filereadable(dir."/plugin/netrwPlugin.vim")
                            "     call Decho("removing netrw-related files from ".dir,'~'.expand("<slnum>"))
                                 if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
                                 if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
                                 if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
                                 if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
                                 if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
                                 if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
                                 let diddir= dir
                                 let diddel= diddel + 1
                                 if !a:sys|break|endif
                                endif
                               endfor
                              endif
                            
                               echohl WarningMsg
                              if diddel == 0
                               echomsg "netrw is either not installed or not removable"
                              elseif diddel == 1
                               echomsg "removed one copy of netrw from <".diddir.">"
                              else
                               echomsg "removed ".diddel." copies of netrw"
                              endif
                               echohl None
                            
                            "  call Dret("netrw#Clean")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#MakeTgt: make a target out of the directory name provided {{{2
    1              0.000002 fun! netrw#MakeTgt(dname)
                            "  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
                               " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
                              let svpos               = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let s:netrwmftgt_islocal= (a:dname !~ '^\a\{3,}://')
                            "  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
                              if s:netrwmftgt_islocal
                               let netrwmftgt= simplify(a:dname)
                              else
                               let netrwmftgt= a:dname
                              endif
                              if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
                               " re-selected target, so just clear it
                               unlet s:netrwmftgt s:netrwmftgt_islocal
                              else
                               let s:netrwmftgt= netrwmftgt
                              endif
                              if g:netrw_fastbrowse <= 1
                               call s:NetrwRefresh((b:netrw_curdir !~ '\a\{3,}://'),b:netrw_curdir)
                              endif
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
                              call winrestview(svpos)
                            "  call Dret("netrw#MakeTgt")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Obtain: {{{2
                            "   netrw#Obtain(islocal,fname[,tgtdirectory])
                            "     islocal=0  obtain from remote source
                            "            =1  obtain from local source
                            "     fname  :   a filename or a list of filenames
                            "     tgtdir :   optional place where files are to go  (not present, uses getcwd())
    1              0.000002 fun! netrw#Obtain(islocal,fname,...)
                            "  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
                              " NetrwStatusLine support - for obtaining support
                            
                              if type(a:fname) == 1
                               let fnamelist= [ a:fname ]
                              elseif type(a:fname) == 3
                               let fnamelist= a:fname
                              else
                               call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
                            "   call Dret("netrw#Obtain")
                               return
                              endif
                            "  call Decho("fnamelist<".string(fnamelist).">",'~'.expand("<slnum>"))
                              if a:0 > 0
                               let tgtdir= a:1
                              else
                               let tgtdir= getcwd()
                              endif
                            "  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))
                            
                              if exists("b:netrw_islocal") && b:netrw_islocal
                               " obtain a file from local b:netrw_curdir to (local) tgtdir
                            "   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
                               if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
                                let topath= s:ComposePath(tgtdir,"")
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 " transfer files one at time
                            "     call Decho("transfer files one at a time",'~'.expand("<slnum>"))
                                 for fname in fnamelist
                            "      call Decho("system(".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
                                  call system(g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
                                  if v:shell_error != 0
                                   call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
                            "       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
                                   return
                                  endif
                                 endfor
                                else
                                 " transfer files with one command
                            "     call Decho("transfer files with one command",'~'.expand("<slnum>"))
                                 let filelist= join(map(deepcopy(fnamelist),"s:ShellEscape(v:val)"))
                            "     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
                                 call system(g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
                                 if v:shell_error != 0
                                  call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
                            "      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
                                  return
                                 endif
                                endif
                               elseif !exists("b:netrw_curdir")
                                call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
                               else
                                call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
                               endif
                            
                              else
                               " obtain files from remote b:netrw_curdir to local tgtdir
                            "   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
                               if type(a:fname) == 1
                                call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
                               endif
                               call s:NetrwMethod(b:netrw_curdir)
                            
                               if b:netrw_method == 4
                                " obtain file using scp
                            "    call Decho("obtain via scp (method#4)",'~'.expand("<slnum>"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                                if b:netrw_fname =~ '/'
                                 let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
                                else
                                 let path= ""
                                endif
                                let filelist= join(map(deepcopy(fnamelist),'s:ShellEscape(g:netrw_machine.":".path.v:val,1)'))
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".filelist." ".s:ShellEscape(tgtdir,1))
                            
                               elseif b:netrw_method == 2
                                " obtain file using ftp + .netrc
                            "     call Decho("obtain via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
                                 call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
                                 let tmpbufnr= bufnr("%")
                                 setl ff=unix
                                 if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                  NetrwKeepj put =g:netrw_ftpmode
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 if exists("b:netrw_fname") && b:netrw_fname != ""
                                  call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 if exists("g:netrw_ftpextracmd")
                                  NetrwKeepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                                 for fname in fnamelist
                                  call setline(line("$")+1,'get "'.fname.'"')
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endfor
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
                                 else
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep= &debug
                                  setl debug=msg
                                  call netrw#ErrorMsg(s:ERROR,getline(1),4)
                                  let &debug= debugkeep
                                 endif
                            
                               elseif b:netrw_method == 3
                                " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
                            "    call Decho("obtain via ftp+mipf (method #3)",'~'.expand("<slnum>"))
                                call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
                                let tmpbufnr= bufnr("%")
                                setl ff=unix
                            
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                else
                                 NetrwKeepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                endif
                            
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  NetrwKeepj put =g:netrw_uid
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 elseif exists("s:netrw_passwd")
                                  NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                                endif
                            
                                if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                 NetrwKeepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                endif
                            
                                if exists("b:netrw_fname") && b:netrw_fname != ""
                                 NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                endif
                            
                                if exists("g:netrw_ftpextracmd")
                                 NetrwKeepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                endif
                            
                                if exists("g:netrw_ftpextracmd")
                                 NetrwKeepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                endif
                                for fname in fnamelist
                                 NetrwKeepj call setline(line("$")+1,'get "'.fname.'"')
                                endfor
                            "    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                NetrwKeepj norm! 1Gdd
                                call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                            "     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
                                 if !exists("g:netrw_quiet")
                                  NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
                                 endif
                                endif
                            
                               elseif b:netrw_method == 9
                                " obtain file using sftp
                            "    call Decho("obtain via sftp (method #9)",'~'.expand("<slnum>"))
                                if a:fname =~ '/'
                                 let localfile= substitute(a:fname,'^.*/','','')
                                else
                                 let localfile= a:fname
                                endif
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1).s:ShellEscape(localfile)." ".s:ShellEscape(tgtdir))
                            
                               elseif !exists("b:netrw_method") || b:netrw_method < 0
                                " probably a badly formed url; protocol not recognized
                            "    call Dret("netrw#Obtain : unsupported method")
                                return
                            
                               else
                                " protocol recognized but not supported for Obtain (yet?)
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
                                endif
                            "    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
                                return
                               endif
                            
                               " restore status line
                               if type(a:fname) == 1 && exists("s:netrw_users_stl")
                                NetrwKeepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
                               endif
                            
                              endif
                            
                              " cleanup
                              if exists("tmpbufnr")
                               if bufnr("%") != tmpbufnr
                                exe tmpbufnr."bw!"
                               else
                                q!
                               endif
                              endif
                            
                            "  call Dret("netrw#Obtain")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
    1              0.000002 fun! netrw#Nread(mode,fname)
                            "  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call netrw#NetRead(a:mode,a:fname)
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call winrestview(svpos)
                            
                              if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
                               if exists("w:netrw_bannercnt")
                                " start with cursor just after the banner
                                exe w:netrw_bannercnt
                               endif
                              endif
                            "  call Dret("netrw#Nread")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwOptionRestore: restore options (based on prior s:NetrwOptionSave) {{{2
    1              0.000003 fun! s:NetrwOptionRestore(vt)
                            "  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                              if !exists("{a:vt}netrw_optionsave")
                               call s:RestorePosn(s:netrw_nbcd)
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
                               return
                              endif
                              unlet {a:vt}netrw_optionsave
                            
                              if exists("+acd")
                               if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                                let curdir = getcwd()
                                let &l:acd = {a:vt}netrw_acdkeep
                                unlet {a:vt}netrw_acdkeep
                                if &l:acd
                                 call s:NetrwLcd(curdir)
                                endif
                               endif
                              endif
                              if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
                              if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
                              if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
                              if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
                              if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
                              if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
                              if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
                              if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
                              if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
                              if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
                              if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
                              if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
                              if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
                              if exists("g:netrw_ffkep") && g:netrw_ffkeep
                               if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
                              endif
                              if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
                              if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
                              if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
                              if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
                              if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
                              if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
                              if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
                              if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
                              if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
                              if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
                              if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
                              if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
                              if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
                              if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
                              if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
                              if has("clipboard")
                               if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
                              endif
                              " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                            "  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
                              if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
                              if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
                              if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
                              if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
                              if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
                              if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory= getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                if !g:netrw_use_noswf
                                 " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                 sil! let &l:swf= {a:vt}netrw_swfkeep
                                endif
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
                              if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
                               let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
                               if exists("{a:vt}netrw_dirkeep")
                                call s:NetrwLcd(dirkeep)
                                unlet {a:vt}netrw_dirkeep
                               endif
                              endif
                              if has("clipboard")
                               if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
                              endif
                              if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
                              call s:RestorePosn(s:netrw_nbcd)
                            
                            "  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
                              if &ft != "netrw"
                            "   call Decho("filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
                               filetype detect
                              endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
                            "             Options get restored by s:NetrwOptionRestore()
                            "  06/08/07 : removed call to NetrwSafeOptions(), either placed
                            "             immediately after NetrwOptionSave() calls in NetRead
                            "             and NetWrite, or after the s:NetrwEnew() call in
                            "             NetrwBrowse.
                            "             vt: normally its "w:" or "s:" (a variable type)
    1              0.000002 fun! s:NetrwOptionSave(vt)
                            "  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            
                              if !exists("{a:vt}netrw_optionsave")
                               let {a:vt}netrw_optionsave= 1
                              else
                            "   call Dret("s:NetrwOptionSave : options already saved")
                               return
                              endif
                            "  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
                              let s:yykeep          = @@
                              if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
                              let {a:vt}netrw_aikeep    = &l:ai
                              let {a:vt}netrw_awkeep    = &l:aw
                              let {a:vt}netrw_bhkeep    = &l:bh
                              let {a:vt}netrw_blkeep    = &l:bl
                              let {a:vt}netrw_btkeep    = &l:bt
                              let {a:vt}netrw_bombkeep  = &l:bomb
                              let {a:vt}netrw_cedit     = &cedit
                              let {a:vt}netrw_cikeep    = &l:ci
                              let {a:vt}netrw_cinkeep   = &l:cin
                              let {a:vt}netrw_cinokeep  = &l:cino
                              let {a:vt}netrw_comkeep   = &l:com
                              let {a:vt}netrw_cpokeep   = &l:cpo
                              let {a:vt}netrw_diffkeep  = &l:diff
                              let {a:vt}netrw_fenkeep   = &l:fen
                              if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
                               let {a:vt}netrw_ffkeep    = &l:ff
                              endif
                              let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
                              let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
                              let {a:vt}netrw_hidkeep   = &l:hidden
                              let {a:vt}netrw_imkeep    = &l:im
                              let {a:vt}netrw_iskkeep   = &l:isk
                              let {a:vt}netrw_lskeep    = &l:ls
                              let {a:vt}netrw_makeep    = &l:ma
                              let {a:vt}netrw_magickeep = &l:magic
                              let {a:vt}netrw_modkeep   = &l:mod
                              let {a:vt}netrw_nukeep    = &l:nu
                              let {a:vt}netrw_rnukeep   = &l:rnu
                              let {a:vt}netrw_repkeep   = &l:report
                              let {a:vt}netrw_rokeep    = &l:ro
                              let {a:vt}netrw_selkeep   = &l:sel
                              let {a:vt}netrw_spellkeep = &l:spell
                              if !g:netrw_use_noswf
                               let {a:vt}netrw_swfkeep  = &l:swf
                              endif
                              if has("clipboard")
                               let {a:vt}netrw_starkeep = @*
                              endif
                              let {a:vt}netrw_tskeep    = &l:ts
                              let {a:vt}netrw_twkeep    = &l:tw           " textwidth
                              let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
                              let {a:vt}netrw_wrapkeep  = &l:wrap
                              let {a:vt}netrw_writekeep = &l:write
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
                              if g:netrw_keepdir
                               let {a:vt}netrw_dirkeep  = getcwd()
                              endif
                              if has("clipboard")
                               if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
                              endif
                              sil! let {a:vt}netrw_regslash= @/
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwSafeOptions: sets options to help netrw do its job {{{2
                            "                     Use  s:NetrwSaveOptions() to save user settings
                            "                     Use  s:NetrwOptionRestore() to restore user settings
    1              0.000002 fun! s:NetrwSafeOptions()
                            "  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
                            "  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                              if exists("+acd") | setl noacd | endif
                              setl noai
                              setl noaw
                              setl nobl
                              setl nobomb
                              setl bt=nofile
                              setl noci
                              setl nocin
                              setl bh=hide
                              setl cino=
                              setl com=
                              setl cpo-=a
                              setl cpo-=A
                              setl fo=nroql2
                              setl nohid
                              setl noim
                              setl isk+=@ isk+=* isk+=/
                              setl magic
                              if g:netrw_use_noswf
                               setl noswf
                              endif
                              setl report=10000
                              setl sel=inclusive
                              setl nospell
                              setl tw=0
                              setl wig=
                              setl cedit&
                              call s:NetrwCursor()
                            
                              " allow the user to override safe options
                            "  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
                              if &ft == "netrw"
                            "   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
                               sil! keepalt NetrwKeepj doau FileType netrw
                              endif
                            
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwSafeOptions")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{2
    1              0.000001 fun! NetrwStatusLine()
                            
                            " vvv NetrwStatusLine() debugging vvv
                            "  let g:stlmsg=""
                            "  if !exists("w:netrw_explore_bufnr")
                            "   let g:stlmsg="!X<explore_bufnr>"
                            "  elseif w:netrw_explore_bufnr != bufnr("%")
                            "   let g:stlmsg="explore_bufnr!=".bufnr("%")
                            "  endif
                            "  if !exists("w:netrw_explore_line")
                            "   let g:stlmsg=" !X<explore_line>"
                            "  elseif w:netrw_explore_line != line(".")
                            "   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
                            "  endif
                            "  if !exists("w:netrw_explore_list")
                            "   let g:stlmsg=" !X<explore_list>"
                            "  endif
                            " ^^^ NetrwStatusLine() debugging ^^^
                            
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               " restore user's status line
                               let &stl        = s:netrw_users_stl
                               let &laststatus = s:netrw_users_ls
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Netrw Transfer Functions: {{{1
                            " ===============================
                            
                            " ------------------------------------------------------------------------
                            " netrw#NetRead: responsible for reading a file over the net {{{2
                            "   mode: =0 read remote file and insert before current line
                            "         =1 read remote file and insert after current line
                            "         =2 replace with remote file
                            "         =3 obtain file, but leave in temporary format
    1              0.000002 fun! netrw#NetRead(mode,...)
                            "  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))
                            
                              " NetRead: save options {{{3
                              call s:NetrwOptionSave("w:")
                              call s:NetrwSafeOptions()
                              call s:RestoreCursorline()
                              " NetrwSafeOptions sets a buffer up for a netrw listing, which includes buflisting off.
                              " However, this setting is not wanted for a remote editing session.  The buffer should be "nofile", still.
                              setl bl
                            "  call Decho("(netrw#NetRead) buf#".bufnr("%")."<".bufname("%")."> bl=".&bl." bt=".&bt." bh=".&bh,'~'.expand("<slnum>"))
                            
                              " NetRead: interpret mode into a readcmd {{{3
                              if     a:mode == 0 " read remote file before current line
                               let readcmd = "0r"
                              elseif a:mode == 1 " read file after current line
                               let readcmd = "r"
                              elseif a:mode == 2 " replace with remote file
                               let readcmd = "%r"
                              elseif a:mode == 3 " skip read of file (leave as temporary)
                               let readcmd = "t"
                              else
                               exe a:mode
                               let readcmd = "r"
                              endif
                              let ichoice = (a:0 == 0)? 0 : 1
                            "  call Decho("readcmd<".readcmd."> ichoice=".ichoice,'~'.expand("<slnum>"))
                            
                              " NetRead: get temporary filename {{{3
                              let tmpfile= s:GetTempfile("")
                              if tmpfile == ""
                            "   call Dret("netrw#NetRead : unable to get a tempfile!")
                               return
                              endif
                            
                              while ichoice <= a:0
                            
                               " attempt to repeat with previous host-file-etc
                               if exists("b:netrw_lastfile") && a:0 == 0
                            "    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
                                let choice = b:netrw_lastfile
                                let ichoice= ichoice + 1
                            
                               else
                                exe "let choice= a:" . ichoice
                            "    call Decho("no lastfile: choice<" . choice . ">",'~'.expand("<slnum>"))
                            
                                if match(choice,"?") == 0
                                 " give help
                                 echomsg 'NetRead Usage:'
                                 echomsg ':Nread machine:path                         uses rcp'
                                 echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
                                 echomsg ':Nread "machine id password path"           uses ftp'
                                 echomsg ':Nread dav://machine[:port]/path            uses cadaver'
                                 echomsg ':Nread fetch://machine/path                 uses fetch'
                                 echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
                                 echomsg ':Nread http://[user@]machine/path           uses http  wget'
                                 echomsg ':Nread file:///path           		  uses elinks'
                                 echomsg ':Nread https://[user@]machine/path          uses http  wget'
                                 echomsg ':Nread rcp://[user@]machine/path            uses rcp'
                                 echomsg ':Nread rsync://machine[:port]/path          uses rsync'
                                 echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
                                 echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
                                 sleep 4
                                 break
                            
                                elseif match(choice,'^"') != -1
                                 " Reconstruct Choice if choice starts with '"'
                            "     call Decho("reconstructing choice",'~'.expand("<slnum>"))
                                 if match(choice,'"$') != -1
                                  " case "..."
                                  let choice= strpart(choice,1,strlen(choice)-2)
                                 else
                                   "  case "... ... ..."
                                  let choice      = strpart(choice,1,strlen(choice)-1)
                                  let wholechoice = ""
                            
                                  while match(choice,'"$') == -1
                                   let wholechoice = wholechoice . " " . choice
                                   let ichoice     = ichoice + 1
                                   if ichoice > a:0
                                   	if !exists("g:netrw_quiet")
                            	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",3)
                            	endif
                            "        call Dret("netrw#NetRead :2 getcwd<".getcwd().">")
                                    return
                                   endif
                                   let choice= a:{ichoice}
                                  endwhile
                                  let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
                                 endif
                                endif
                               endif
                            
                            "   call Decho("choice<" . choice . ">",'~'.expand("<slnum>"))
                               let ichoice= ichoice + 1
                            
                               " NetRead: Determine method of read (ftp, rcp, etc) {{{3
                               call s:NetrwMethod(choice)
                               if !exists("b:netrw_method") || b:netrw_method < 0
                            "    call Dfunc("netrw#NetRead : unsupported method")
                                return
                               endif
                               let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix
                            
                               " Check whether or not NetrwBrowse() should be handling this request
                            "   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">",'~'.expand("<slnum>"))
                               if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
                            "    call Decho("yes, choice matches '^.*[\/]$'",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwBrowse(0,choice)
                            "    call Dret("netrw#NetRead :3 getcwd<".getcwd().">")
                                return
                               endif
                            
                               " ============
                               " NetRead: Perform Protocol-Based Read {{{3
                               " ===========================
                               if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
                                echo "(netrw) Processing your read request..."
                               endif
                            
                               ".........................................
                               " NetRead: (rcp)  NetRead Method #1 {{{3
                               if  b:netrw_method == 1 " read with rcp
                            "    call Decho("read via rcp (method #1)",'~'.expand("<slnum>"))
                               " ER: nothing done with g:netrw_uid yet?
                               " ER: on Win2K" rcp machine[.user]:file tmpfile
                               " ER: when machine contains '.' adding .user is required (use $USERNAME)
                               " ER: the tmpfile is full path: rcp sees C:\... as host C
                               if s:netrw_has_nt_rcp == 1
                                if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_machine .'.'. g:netrw_uid
                                else
                                 " Any way needed it machine contains a '.'
                                 let uid_machine = g:netrw_machine .'.'. $USERNAME
                                endif
                               else
                                if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                else
                                 let uid_machine = g:netrw_machine
                                endif
                               endif
                               call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
                               let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                               let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (ftp + <.netrc>)  NetRead Method #2 {{{3
                               elseif b:netrw_method  == 2		" read with ftp + <.netrc>
                            "     call Decho("read via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
                                 let netrw_fname= b:netrw_fname
                                 NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
                                 let filtbuf= bufnr("%")
                                 setl ff=unix
                                 NetrwKeepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
                                 if exists("g:netrw_ftpextracmd")
                                  NetrwKeepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
                                 endif
                                 call setline(line("$")+1,'get "'.netrw_fname.'" '.tmpfile)
                            "     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
                                 else
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep = &debug
                                  setl debug=msg
                                  NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),4)
                                  let &debug    = debugkeep
                                 endif
                                 call s:SaveBufVars()
                                 keepj bd!
                                 if bufname("%") == "" && getline("$") == "" && line('$') == 1
                                  " needed when one sources a file in a nolbl setting window via ftp
                                  q!
                                 endif
                                 call s:RestoreBufVars()
                                 let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                 let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (ftp + machine,id,passwd,filename)  NetRead Method #3 {{{3
                               elseif b:netrw_method == 3		" read with ftp + machine, id, passwd, and fname
                                " Construct execution string (four lines) which will be passed through filter
                            "    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
                                let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
                                let filtbuf= bufnr("%")
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                else
                                 NetrwKeepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                endif
                            
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  NetrwKeepj put =g:netrw_uid
                            "       call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                  if exists("s:netrw_passwd")
                                   NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                 elseif exists("s:netrw_passwd")
                                  NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                 endif
                                endif
                            
                                if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                 NetrwKeepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                endif
                                if exists("g:netrw_ftpextracmd")
                                 NetrwKeepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                endif
                                NetrwKeepj put ='get \"'.netrw_fname.'\" '.tmpfile
                            "    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                NetrwKeepj norm! 1Gdd
                                call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                            "     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
                                 if !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,getline(1),5)
                                 endif
                                endif
                                call s:SaveBufVars()|keepj bd!|call s:RestoreBufVars()
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (scp) NetRead Method #4 {{{3
                               elseif     b:netrw_method  == 4	" read with scp
                            "    call Decho("read via scp (method #4)",'~'.expand("<slnum>"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                                " 'C' in 'C:\path\to\file' is handled as hostname on windows.
                                " This is workaround to avoid mis-handle windows local-path:
                                if g:netrw_scp_cmd =~ '^scp' && (has("win32") || has("win95") || has("win64") || has("win16"))
                                  let tmpfile_get = substitute(tr(tmpfile, '\', '/'), '^\(\a\):[/\\]\(.*\)$', '/\1/\2', '')
                                else
                                  let tmpfile_get = tmpfile
                                endif
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile_get,1))
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (http) NetRead Method #5 (wget) {{{3
                               elseif     b:netrw_method  == 5
                            "    call Decho("read via http (method #5)",'~'.expand("<slnum>"))
                                if g:netrw_http_cmd == ""
                                 if !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,"neither the wget nor the fetch command is available",6)
                                 endif
                            "     call Dret("netrw#NetRead :4 getcwd<".getcwd().">")
                                 return
                                endif
                            
                                if match(b:netrw_fname,"#") == -1 || exists("g:netrw_http_xcmd")
                                 " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
                            "     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)",'~'.expand("<slnum>"))
                                 if exists("g:netrw_http_xcmd")
                                  call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".s:ShellEscape(tmpfile,1))
                                 else
                                  call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1))
                                 endif
                                 let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                            
                                else
                                 " wget/curl/fetch plus a jump to an in-page marker (ie. http://abc/def.html#aMarker)
                            "     call Decho("wget/curl plus jump (# in b:netrw_fname<".b:netrw_fname.">)",'~'.expand("<slnum>"))
                                 let netrw_html= substitute(b:netrw_fname,"#.*$","","")
                                 let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
                            "     call Decho("netrw_html<".netrw_html.">",'~'.expand("<slnum>"))
                            "     call Decho("netrw_tag <".netrw_tag.">",'~'.expand("<slnum>"))
                                 call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.netrw_html,1))
                                 let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                            "     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/','~'.expand("<slnum>"))
                                 exe 'NetrwKeepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
                                endif
                                let b:netrw_lastfile = choice
                            "    call Decho("setl ro",'~'.expand("<slnum>"))
                                setl ro nomod
                            
                               ".........................................
                               " NetRead: (dav) NetRead Method #6 {{{3
                               elseif     b:netrw_method  == 6
                            "    call Decho("read via cadaver (method #6)",'~'.expand("<slnum>"))
                            
                                if !executable(g:netrw_dav_cmd)
                                 call netrw#ErrorMsg(s:ERROR,g:netrw_dav_cmd." is not executable",73)
                            "     call Dret("netrw#NetRead : ".g:netrw_dav_cmd." not executable")
                                 return
                                endif
                                if g:netrw_dav_cmd =~ "curl"
                                 call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_dav_cmd." ".s:ShellEscape("dav://".g:netrw_machine.b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
                                else
                                 " Construct execution string (four lines) which will be passed through filter
                                 let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                 new
                                 setl ff=unix
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                 else
                                  NetrwKeepj put ='open '.g:netrw_machine
                                 endif
                                 if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
                                  NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
                                 endif
                                 NetrwKeepj put ='get '.netrw_fname.' '.tmpfile
                                 NetrwKeepj put ='quit'
                            
                                 " perform cadaver operation:
                                 NetrwKeepj norm! 1Gdd
                                 call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)
                                 keepj bd!
                                endif
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (rsync) NetRead Method #7 {{{3
                               elseif     b:netrw_method  == 7
                            "    call Decho("read via rsync (method #7)",'~'.expand("<slnum>"))
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
                                let result		 = s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (fetch) NetRead Method #8 {{{3
                               "    fetch://[user@]host[:http]/path
                               elseif     b:netrw_method  == 8
                            "    call Decho("read via fetch (method #8)",'~'.expand("<slnum>"))
                                if g:netrw_fetch_cmd == ""
                                 if !exists("g:netrw_quiet")
                                  NetrwKeepj call netrw#ErrorMsg(s:ERROR,"fetch command not available",7)
                                 endif
                            "     call Dret("NetRead")
                                 return
                                endif
                                if exists("g:netrw_option") && g:netrw_option =~ ":https\="
                                 let netrw_option= "http"
                                else
                                 let netrw_option= "ftp"
                                endif
                            "    call Decho("read via fetch for ".netrw_option,'~'.expand("<slnum>"))
                            
                                if exists("g:netrw_uid") && g:netrw_uid != "" && exists("s:netrw_passwd") && s:netrw_passwd != ""
                                 call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1))
                                else
                                 call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1))
                                endif
                            
                                let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            "    call Decho("setl ro",'~'.expand("<slnum>"))
                                setl ro nomod
                            
                               ".........................................
                               " NetRead: (sftp) NetRead Method #9 {{{3
                               elseif     b:netrw_method  == 9
                            "    call Decho("read via sftp (method #9)",'~'.expand("<slnum>"))
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile)
                                let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (file) NetRead Method #10 {{{3
                              elseif      b:netrw_method == 10 && exists("g:netrw_file_cmd")
                            "   "    call Decho("read via ".b:netrw_file_cmd." (method #10)",'~'.expand("<slnum>"))
                               call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_file_cmd." ".s:ShellEscape(b:netrw_fname,1)." ".tmpfile)
                               let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                               let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: Complain {{{3
                               else
                                call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",8)
                               endif
                              endwhile
                            
                              " NetRead: cleanup {{{3
                              if exists("b:netrw_method")
                            "   call Decho("cleanup b:netrw_method and b:netrw_fname",'~'.expand("<slnum>"))
                               unlet b:netrw_method
                               unlet b:netrw_fname
                              endif
                              if s:FileReadable(tmpfile) && tmpfile !~ '.tar.bz2$' && tmpfile !~ '.tar.gz$' && tmpfile !~ '.zip' && tmpfile !~ '.tar' && readcmd != 't' && tmpfile !~ '.tar.xz$' && tmpfile !~ '.txz'
                            "   call Decho("cleanup by deleting tmpfile<".tmpfile.">",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwDelete(tmpfile)
                              endif
                              NetrwKeepj call s:NetrwOptionRestore("w:")
                            
                            "  call Dret("netrw#NetRead :5 getcwd<".getcwd().">")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " netrw#NetWrite: responsible for writing a file over the net {{{2
    1              0.000003 fun! netrw#NetWrite(...) range
                            "  call Dfunc("netrw#NetWrite(a:0=".a:0.") ".g:loaded_netrw)
                            
                              " NetWrite: option handling {{{3
                              let mod= 0
                              call s:NetrwOptionSave("w:")
                              call s:NetrwSafeOptions()
                            
                              " NetWrite: Get Temporary Filename {{{3
                              let tmpfile= s:GetTempfile("")
                              if tmpfile == ""
                            "   call Dret("netrw#NetWrite : unable to get a tempfile!")
                               return
                              endif
                            
                              if a:0 == 0
                               let ichoice = 0
                              else
                               let ichoice = 1
                              endif
                            
                              let curbufname= expand("%")
                            "  call Decho("curbufname<".curbufname.">",'~'.expand("<slnum>"))
                              if &binary
                               " For binary writes, always write entire file.
                               " (line numbers don't really make sense for that).
                               " Also supports the writing of tar and zip files.
                            "   call Decho("(write entire file) sil exe w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
                               exe "sil NetrwKeepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
                              elseif g:netrw_cygwin
                               " write (selected portion of) file to temporary
                               let cygtmpfile= substitute(tmpfile,g:netrw_cygdrive.'/\(.\)','\1:','')
                            "   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile),'~'.expand("<slnum>"))
                               exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
                              else
                               " write (selected portion of) file to temporary
                            "   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
                               exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
                              endif
                            
                              if curbufname == ""
                               " when the file is [No Name], and one attempts to Nwrite it, the buffer takes
                               " on the temporary file's name.  Deletion of the temporary file during
                               " cleanup then causes an error message.
                               0file!
                              endif
                            
                              " NetWrite: while choice loop: {{{3
                              while ichoice <= a:0
                            
                               " Process arguments: {{{4
                               " attempt to repeat with previous host-file-etc
                               if exists("b:netrw_lastfile") && a:0 == 0
                            "    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
                                let choice = b:netrw_lastfile
                                let ichoice= ichoice + 1
                               else
                                exe "let choice= a:" . ichoice
                            
                                " Reconstruct Choice when choice starts with '"'
                                if match(choice,"?") == 0
                                 echomsg 'NetWrite Usage:"'
                                 echomsg ':Nwrite machine:path                        uses rcp'
                                 echomsg ':Nwrite "machine path"                      uses ftp with <.netrc>'
                                 echomsg ':Nwrite "machine id password path"          uses ftp'
                                 echomsg ':Nwrite dav://[user@]machine/path           uses cadaver'
                                 echomsg ':Nwrite fetch://[user@]machine/path         uses fetch'
                                 echomsg ':Nwrite ftp://machine[#port]/path           uses ftp  (autodetects <.netrc>)'
                                 echomsg ':Nwrite rcp://machine/path                  uses rcp'
                                 echomsg ':Nwrite rsync://[user@]machine/path         uses rsync'
                                 echomsg ':Nwrite scp://[user@]machine[[:#]port]/path uses scp'
                                 echomsg ':Nwrite sftp://[user@]machine/path          uses sftp'
                                 sleep 4
                                 break
                            
                                elseif match(choice,"^\"") != -1
                                 if match(choice,"\"$") != -1
                                   " case "..."
                                  let choice=strpart(choice,1,strlen(choice)-2)
                                 else
                                  "  case "... ... ..."
                                  let choice      = strpart(choice,1,strlen(choice)-1)
                                  let wholechoice = ""
                            
                                  while match(choice,"\"$") == -1
                                   let wholechoice= wholechoice . " " . choice
                                   let ichoice    = ichoice + 1
                                   if choice > a:0
                                   	if !exists("g:netrw_quiet")
                            	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",13)
                            	endif
                            "        call Dret("netrw#NetWrite")
                                    return
                                   endif
                                   let choice= a:{ichoice}
                                  endwhile
                                  let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
                                 endif
                                endif
                               endif
                               let ichoice= ichoice + 1
                            "   call Decho("choice<" . choice . "> ichoice=".ichoice,'~'.expand("<slnum>"))
                            
                               " Determine method of write (ftp, rcp, etc) {{{4
                               NetrwKeepj call s:NetrwMethod(choice)
                               if !exists("b:netrw_method") || b:netrw_method < 0
                            "    call Dfunc("netrw#NetWrite : unsupported method")
                                return
                               endif
                            
                               " =============
                               " NetWrite: Perform Protocol-Based Write {{{3
                               " ============================
                               if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
                                echo "(netrw) Processing your write request..."
                            "    call Decho("(netrw) Processing your write request...",'~'.expand("<slnum>"))
                               endif
                            
                               ".........................................
                               " NetWrite: (rcp) NetWrite Method #1 {{{3
                               if  b:netrw_method == 1
                            "    call Decho("write via rcp (method #1)",'~'.expand("<slnum>"))
                                if s:netrw_has_nt_rcp == 1
                                 if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                  let uid_machine = g:netrw_machine .'.'. g:netrw_uid
                                 else
                                  let uid_machine = g:netrw_machine .'.'. $USERNAME
                                 endif
                                else
                                 if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                  let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                 else
                                  let uid_machine = g:netrw_machine
                                 endif
                                endif
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1))
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (ftp + <.netrc>) NetWrite Method #2 {{{3
                               elseif b:netrw_method == 2
                            "    call Decho("write via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
                                let netrw_fname = b:netrw_fname
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let bhkeep      = &l:bh
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepj keepalt enew
                            
                            "    call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
                                setl ff=unix
                                NetrwKeepj put =g:netrw_ftpmode
                            "    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                if exists("g:netrw_ftpextracmd")
                                 NetrwKeepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
                                endif
                                NetrwKeepj call setline(line("$")+1,'put "'.tmpfile.'" "'.netrw_fname.'"')
                            "    call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
                                else
                            "     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
                                 call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
                                endif
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                                 if !exists("g:netrw_quiet")
                                  NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),14)
                                 endif
                                 let mod=1
                                endif
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                            
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (ftp + machine, id, passwd, filename) NetWrite Method #3 {{{3
                               elseif b:netrw_method == 3
                                " Construct execution string (three or more lines) which will be passed through filter
                            "    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
                                let netrw_fname = b:netrw_fname
                                let bhkeep      = &l:bh
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepj keepalt enew
                                setl ff=unix
                            
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                else
                                 NetrwKeepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                endif
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  NetrwKeepj put =g:netrw_uid
                            "      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                 elseif exists("s:netrw_passwd") && s:netrw_passwd != ""
                                  NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                 endif
                                endif
                                NetrwKeepj put =g:netrw_ftpmode
                            "    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                if exists("g:netrw_ftpextracmd")
                                 NetrwKeepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
                                endif
                                NetrwKeepj put ='put \"'.tmpfile.'\" \"'.netrw_fname.'\"'
                            "    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                " save choice/id/password for future use
                                let b:netrw_lastfile = choice
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                NetrwKeepj norm! 1Gdd
                                call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                                 if  !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,getline(1),15)
                                 endif
                                 let mod=1
                                endif
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh= bhkeep
                                exe filtbuf."bw!"
                            
                               ".........................................
                               " NetWrite: (scp) NetWrite Method #4 {{{3
                               elseif     b:netrw_method == 4
                            "    call Decho("write via scp (method #4)",'~'.expand("<slnum>"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".fnameescape(g:netrw_port)
                                else
                                 let useport= ""
                                endif
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1))
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (http) NetWrite Method #5 {{{3
                               elseif     b:netrw_method == 5
                            "    call Decho("write via http (method #5)",'~'.expand("<slnum>"))
                                let curl= substitute(g:netrw_http_put_cmd,'\s\+.*$',"","")
                                if executable(curl)
                                 let url= g:netrw_choice
                                 call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(url,1) )
                                elseif !exists("g:netrw_quiet")
                                 call netrw#ErrorMsg(s:ERROR,"can't write to http using <".g:netrw_http_put_cmd".">".",16)
                                endif
                            
                               ".........................................
                               " NetWrite: (dav) NetWrite Method #6 (cadaver) {{{3
                               elseif     b:netrw_method == 6
                            "    call Decho("write via cadaver (method #6)",'~'.expand("<slnum>"))
                            
                                " Construct execution string (four lines) which will be passed through filter
                                let netrw_fname = escape(b:netrw_fname,g:netrw_fname_escape)
                                let bhkeep      = &l:bh
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepj keepalt enew
                            
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                else
                                 NetrwKeepj put ='open '.g:netrw_machine
                                endif
                                if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
                                 NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
                                endif
                                NetrwKeepj put ='put '.tmpfile.' '.netrw_fname
                            
                                " perform cadaver operation:
                                NetrwKeepj norm! 1Gdd
                                call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                            
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (rsync) NetWrite Method #7 {{{3
                               elseif     b:netrw_method == 7
                            "    call Decho("write via rsync (method #7)",'~'.expand("<slnum>"))
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1))
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (sftp) NetWrite Method #9 {{{3
                               elseif     b:netrw_method == 9
                            "    call Decho("write via sftp (method #9)",'~'.expand("<slnum>"))
                                let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                else
                                 let uid_machine = g:netrw_machine
                                endif
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let bhkeep = &l:bh
                                let curbuf = bufnr("%")
                                setl bh=hide
                                keepj keepalt enew
                            
                                setl ff=unix
                                call setline(1,'put "'.escape(tmpfile,'\').'" '.netrw_fname)
                            "    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                                let sftpcmd= substitute(g:netrw_sftp_cmd,"%TEMPFILE%",escape(tmpfile,'\'),"g")
                                call s:NetrwExe(s:netrw_silentxfer."%!".sftpcmd.' '.s:ShellEscape(uid_machine,1))
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: Complain {{{3
                               else
                                call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",17)
                                let leavemod= 1
                               endif
                              endwhile
                            
                              " NetWrite: Cleanup: {{{3
                            "  call Decho("cleanup",'~'.expand("<slnum>"))
                              if s:FileReadable(tmpfile)
                            "   call Decho("tmpfile<".tmpfile."> readable, will now delete it",'~'.expand("<slnum>"))
                               call s:NetrwDelete(tmpfile)
                              endif
                              call s:NetrwOptionRestore("w:")
                            
                              if a:firstline == 1 && a:lastline == line("$")
                               " restore modifiability; usually equivalent to set nomod
                               let &mod= mod
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                              elseif !exists("leavemod")
                               " indicate that the buffer has not been modified since last written
                            "   call Decho("set nomod",'~'.expand("<slnum>"))
                               setl nomod
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                              endif
                            
                            "  call Dret("netrw#NetWrite")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetSource: source a remotely hosted vim script {{{2
                            " uses NetRead to get a copy of the file into a temporarily file,
                            "              then sources that file,
                            "              then removes that file.
    1              0.000001 fun! netrw#NetSource(...)
                            "  call Dfunc("netrw#NetSource() a:0=".a:0)
                              if a:0 > 0 && a:1 == '?'
                               " give help
                               echomsg 'NetSource Usage:'
                               echomsg ':Nsource dav://machine[:port]/path            uses cadaver'
                               echomsg ':Nsource fetch://machine/path                 uses fetch'
                               echomsg ':Nsource ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
                               echomsg ':Nsource http[s]://[user@]machine/path        uses http  wget'
                               echomsg ':Nsource rcp://[user@]machine/path            uses rcp'
                               echomsg ':Nsource rsync://machine[:port]/path          uses rsync'
                               echomsg ':Nsource scp://[user@]machine[[:#]port]/path  uses scp'
                               echomsg ':Nsource sftp://[user@]machine[[:#]port]/path uses sftp'
                               sleep 4
                              else
                               let i= 1
                               while i <= a:0
                                call netrw#NetRead(3,a:{i})
                            "    call Decho("s:netread_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))
                                if s:FileReadable(s:netrw_tmpfile)
                            "     call Decho("exe so ".fnameescape(s:netrw_tmpfile),'~'.expand("<slnum>"))
                                 exe "so ".fnameescape(s:netrw_tmpfile)
                            "     call Decho("delete(".s:netrw_tmpfile.")",'~'.expand("<slnum>"))
                                 if delete(s:netrw_tmpfile)
                                  call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".s:netrw_tmpfile.">!",103)
                                 endif
                                 unlet s:netrw_tmpfile
                                else
                                 call netrw#ErrorMsg(s:ERROR,"unable to source <".a:{i}.">!",48)
                                endif
                                let i= i + 1
                               endwhile
                              endif
                            "  call Dret("netrw#NetSource")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#SetTreetop: resets the tree top to the current directory/specified directory {{{2
                            "                   (implements the :Ntree command)
    1              0.000007 fun! netrw#SetTreetop(...)
                            "  call Dfunc("netrw#SetTreetop(".((a:0 > 0)? a:1 : "").") a:0=".a:0)
                            
                              " clear out the current tree
                              if exists("w:netrw_treetop")
                            "   call Decho("clearing out current tree",'~'.expand("<slnum>"))
                               let inittreetop= w:netrw_treetop
                               unlet w:netrw_treetop
                              endif
                              if exists("w:netrw_treedict")
                            "   call Decho("freeing w:netrw_treedict",'~'.expand("<slnum>"))
                               unlet w:netrw_treedict
                              endif
                            
                              if a:1 == "" && exists("inittreetop")
                               let treedir= s:NetrwTreePath(inittreetop)
                            "   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                              else
                               if isdirectory(s:NetrwFile(a:1))
                            "    call Decho("a:1<".a:1."> is a directory",'~'.expand("<slnum>"))
                                let treedir= a:1
                               elseif exists("b:netrw_curdir") && (isdirectory(s:NetrwFile(b:netrw_curdir."/".a:1)) || a:1 =~ '^\a\{3,}://')
                                let treedir= b:netrw_curdir."/".a:1
                            "    call Decho("a:1<".a:1."> is NOT a directory, trying treedir<".treedir.">",'~'.expand("<slnum>"))
                               else
                                " normally the cursor is left in the message window.
                                " However, here this results in the directory being listed in the message window, which is not wanted.
                                let netrwbuf= bufnr("%")
                                call netrw#ErrorMsg(s:ERROR,"sorry, ".a:1." doesn't seem to be a directory!",95)
                                exe bufwinnr(netrwbuf)."wincmd w"
                                let treedir= "."
                               endif
                              endif
                            "  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                              let islocal= expand("%") !~ '^\a\{3,}://'
                            "  call Decho("islocal=".islocal,'~'.expand("<slnum>"))
                              if islocal
                               call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(islocal,treedir))
                              else
                               call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,treedir))
                              endif
                            "  call Dret("netrw#SetTreetop")
                            endfun
                            
                            " ===========================================
                            " s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
                            "    readcmd == %r : replace buffer with newly read file
                            "            == 0r : read file at top of buffer
                            "            == r  : read file after current line
                            "            == t  : leave file in temporary form (ie. don't read into buffer)
    1              0.000003 fun! s:NetrwGetFile(readcmd, tfile, method)
                            "  call Dfunc("NetrwGetFile(readcmd<".a:readcmd.">,tfile<".a:tfile."> method<".a:method.">)")
                            
                              " readcmd=='t': simply do nothing
                              if a:readcmd == 't'
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("NetrwGetFile : skip read of <".a:tfile.">")
                               return
                              endif
                            
                              " get name of remote filename (ie. url and all)
                              let rfile= bufname("%")
                            "  call Decho("rfile<".rfile.">",'~'.expand("<slnum>"))
                            
                              if exists("*NetReadFixup")
                               " for the use of NetReadFixup (not otherwise used internally)
                               let line2= line("$")
                              endif
                            
                              if a:readcmd[0] == '%'
                              " get file into buffer
                            "   call Decho("get file into buffer",'~'.expand("<slnum>"))
                            
                               " rename the current buffer to the temp file (ie. tfile)
                               if g:netrw_cygwin
                                let tfile= substitute(a:tfile,g:netrw_cygdrive.'/\(.\)','\1:','')
                               else
                                let tfile= a:tfile
                               endif
                            "   call Decho("exe sil! keepalt file ".fnameescape(tfile),'~'.expand("<slnum>"))
                               exe "sil! keepalt file ".fnameescape(tfile)
                            
                               " edit temporary file (ie. read the temporary file in)
                               if     rfile =~ '\.zip$'
                            "    call Decho("handling remote zip file with zip#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
                                call zip#Browse(tfile)
                               elseif rfile =~ '\.tar$'
                            "    call Decho("handling remote tar file with tar#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.gz$'
                            "    call Decho("handling remote gzip-compressed tar file",'~'.expand("<slnum>"))
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.bz2$'
                            "    call Decho("handling remote bz2-compressed tar file",'~'.expand("<slnum>"))
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.xz$'
                            "    call Decho("handling remote xz-compressed tar file",'~'.expand("<slnum>"))
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.txz$'
                            "    call Decho("handling remote xz-compressed tar file (.txz)",'~'.expand("<slnum>"))
                                call tar#Browse(tfile)
                               else
                            "    call Decho("edit temporary file",'~'.expand("<slnum>"))
                                NetrwKeepj e!
                               endif
                            
                               " rename buffer back to remote filename
                            "   call Decho("exe sil! keepalt file ".fnameescape(rfile),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj keepalt file ".fnameescape(rfile)
                            
                               " Detect filetype of local version of remote file.
                               " Note that isk must not include a "/" for scripts.vim
                               " to process this detection correctly.
                            "   call Decho("detect filetype of local version of remote file",'~'.expand("<slnum>"))
                               let iskkeep= &l:isk
                               setl isk-=/
                               let &l:isk= iskkeep
                            "   call Dredir("renamed buffer back to remote filename<".rfile."> : expand(%)<".expand("%").">","ls!")
                               let line1 = 1
                               let line2 = line("$")
                            
                              elseif !&ma
                               " attempting to read a file after the current line in the file, but the buffer is not modifiable
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"attempt to read<".a:tfile."> into a non-modifiable buffer!",94)
                            "   call Dret("NetrwGetFile : attempt to read<".a:tfile."> into a non-modifiable buffer!")
                               return
                            
                              elseif s:FileReadable(a:tfile)
                               " read file after current line
                            "   call Decho("read file<".a:tfile."> after current line",'~'.expand("<slnum>"))
                               let curline = line(".")
                               let lastline= line("$")
                            "   call Decho("exe<".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile).">  line#".curline,'~'.expand("<slnum>"))
                               exe "NetrwKeepj ".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile)
                               let line1= curline + 1
                               let line2= line("$") - lastline + 1
                            
                              else
                               " not readable
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Decho("tfile<".a:tfile."> not readable",'~'.expand("<slnum>"))
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"file <".a:tfile."> not readable",9)
                            "   call Dret("NetrwGetFile : tfile<".a:tfile."> not readable")
                               return
                              endif
                            
                              " User-provided (ie. optional) fix-it-up command
                              if exists("*NetReadFixup")
                            "   call Decho("calling NetReadFixup(method<".a:method."> line1=".line1." line2=".line2.")",'~'.expand("<slnum>"))
                               NetrwKeepj call NetReadFixup(a:method, line1, line2)
                            "  else " Decho
                            "   call Decho("NetReadFixup() not called, doesn't exist  (line1=".line1." line2=".line2.")",'~'.expand("<slnum>"))
                              endif
                            
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               " update the Buffers menu
                               NetrwKeepj call s:UpdateBuffersMenu()
                              endif
                            
                            "  call Decho("readcmd<".a:readcmd."> cmdarg<".v:cmdarg."> tfile<".a:tfile."> readable=".s:FileReadable(a:tfile),'~'.expand("<slnum>"))
                            
                             " make sure file is being displayed
                            "  redraw!
                            
                            "  call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("NetrwGetFile")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwMethod:  determine method of transfer {{{2
                            " Input:
                            "   choice = url   [protocol:]//[userid@]hostname[:port]/[path-to-file]
                            " Output:
                            "  b:netrw_method= 1: rcp
                            "                  2: ftp + <.netrc>
                            "	           3: ftp + machine, id, password, and [path]filename
                            "	           4: scp
                            "	           5: http[s] (wget)
                            "	           6: dav
                            "	           7: rsync
                            "	           8: fetch
                            "	           9: sftp
                            "	          10: file
                            "  g:netrw_machine= hostname
                            "  b:netrw_fname  = filename
                            "  g:netrw_port   = optional port number (for ftp)
                            "  g:netrw_choice = copy of input url (choice)
    1              0.000002 fun! s:NetrwMethod(choice)
                            "   call Dfunc("NetrwMethod(a:choice<".a:choice.">)")
                            
                               " sanity check: choice should have at least three slashes in it
                               if strlen(substitute(a:choice,'[^/]','','g')) < 3
                                call netrw#ErrorMsg(s:ERROR,"not a netrw-style url; netrw uses protocol://[user@]hostname[:port]/[path])",78)
                                let b:netrw_method = -1
                            "    call Dret("NetrwMethod : incorrect url format<".a:choice.">")
                                return
                               endif
                            
                               " record current g:netrw_machine, if any
                               " curmachine used if protocol == ftp and no .netrc
                               if exists("g:netrw_machine")
                                let curmachine= g:netrw_machine
                            "    call Decho("curmachine<".curmachine.">",'~'.expand("<slnum>"))
                               else
                                let curmachine= "N O T A HOST"
                               endif
                               if exists("g:netrw_port")
                                let netrw_port= g:netrw_port
                               endif
                            
                               " insure that netrw_ftp_cmd starts off every method determination
                               " with the current g:netrw_ftp_cmd
                               let s:netrw_ftp_cmd= g:netrw_ftp_cmd
                            
                              " initialization
                              let b:netrw_method  = 0
                              let g:netrw_machine = ""
                              let b:netrw_fname   = ""
                              let g:netrw_port    = ""
                              let g:netrw_choice  = a:choice
                            
                              " Patterns:
                              " mipf     : a:machine a:id password filename	     Use ftp
                              " mf	    : a:machine filename		     Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
                              " ftpurm   : ftp://[user@]host[[#:]port]/filename  Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
                              " rcpurm   : rcp://[user@]host/filename	     Use rcp
                              " rcphf    : [user@]host:filename		     Use rcp
                              " scpurm   : scp://[user@]host[[#:]port]/filename  Use scp
                              " httpurm  : http[s]://[user@]host/filename	     Use wget
                              " davurm   : dav[s]://host[:port]/path             Use cadaver/curl
                              " rsyncurm : rsync://host[:port]/path              Use rsync
                              " fetchurm : fetch://[user@]host[:http]/filename   Use fetch (defaults to ftp, override for http)
                              " sftpurm  : sftp://[user@]host/filename  Use scp
                              " fileurm  : file://[user@]host/filename	     Use elinks or links
                              let mipf     = '^\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)$'
                              let mf       = '^\(\S\+\)\s\+\(\S\+\)$'
                              let ftpurm   = '^ftp://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
                              let rcpurm   = '^rcp://\%(\([^/]*\)@\)\=\([^/]\{-}\)/\(.*\)$'
                              let rcphf    = '^\(\(\h\w*\)@\)\=\(\h\w*\):\([^@]\+\)$'
                              let scpurm   = '^scp://\([^/#:]\+\)\%([#:]\(\d\+\)\)\=/\(.*\)$'
                              let httpurm  = '^https\=://\([^/]\{-}\)\(/.*\)\=$'
                              let davurm   = '^davs\=://\([^/]\+\)/\(.*/\)\([-_.~[:alnum:]]\+\)$'
                              let rsyncurm = '^rsync://\([^/]\{-}\)/\(.*\)\=$'
                              let fetchurm = '^fetch://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
                              let sftpurm  = '^sftp://\([^/]\{-}\)/\(.*\)\=$'
                              let fileurm  = '^file\=://\(.*\)$'
                            
                            "  call Decho("determine method:",'~'.expand("<slnum>"))
                              " Determine Method
                              " Method#1: rcp://user@hostname/...path-to-file {{{3
                              if match(a:choice,rcpurm) == 0
                            "   call Decho("rcp://...",'~'.expand("<slnum>"))
                               let b:netrw_method  = 1
                               let userid          = substitute(a:choice,rcpurm,'\1',"")
                               let g:netrw_machine = substitute(a:choice,rcpurm,'\2',"")
                               let b:netrw_fname   = substitute(a:choice,rcpurm,'\3',"")
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                              " Method#4: scp://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,scpurm) == 0
                            "   call Decho("scp://...",'~'.expand("<slnum>"))
                               let b:netrw_method  = 4
                               let g:netrw_machine = substitute(a:choice,scpurm,'\1',"")
                               let g:netrw_port    = substitute(a:choice,scpurm,'\2',"")
                               let b:netrw_fname   = substitute(a:choice,scpurm,'\3',"")
                            
                              " Method#5: http[s]://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,httpurm) == 0
                            "   call Decho("http[s]://...",'~'.expand("<slnum>"))
                               let b:netrw_method = 5
                               let g:netrw_machine= substitute(a:choice,httpurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,httpurm,'\2',"")
                               let b:netrw_http   = (a:choice =~ '^https:')? "https" : "http"
                            
                              " Method#6: dav://hostname[:port]/..path-to-file.. {{{3
                              elseif match(a:choice,davurm) == 0
                            "   call Decho("dav://...",'~'.expand("<slnum>"))
                               let b:netrw_method= 6
                               if a:choice =~ 'davs:'
                                let g:netrw_machine= 'https://'.substitute(a:choice,davurm,'\1/\2',"")
                               else
                                let g:netrw_machine= 'http://'.substitute(a:choice,davurm,'\1/\2',"")
                               endif
                               let b:netrw_fname  = substitute(a:choice,davurm,'\3',"")
                            
                               " Method#7: rsync://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,rsyncurm) == 0
                            "   call Decho("rsync://...",'~'.expand("<slnum>"))
                               let b:netrw_method = 7
                               let g:netrw_machine= substitute(a:choice,rsyncurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,rsyncurm,'\2',"")
                            
                               " Methods 2,3: ftp://[user@]hostname[[:#]port]/...path-to-file {{{3
                              elseif match(a:choice,ftpurm) == 0
                            "   call Decho("ftp://...",'~'.expand("<slnum>"))
                               let userid	      = substitute(a:choice,ftpurm,'\2',"")
                               let g:netrw_machine= substitute(a:choice,ftpurm,'\3',"")
                               let g:netrw_port   = substitute(a:choice,ftpurm,'\4',"")
                               let b:netrw_fname  = substitute(a:choice,ftpurm,'\5',"")
                            "   call Decho("g:netrw_machine<".g:netrw_machine.">",'~'.expand("<slnum>"))
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                               if curmachine != g:netrw_machine
                                if exists("s:netwr_hup[".g:netrw_machine."]")
                                 call NetUserPass("ftp:".g:netrw_machine)
                                elseif exists("s:netrw_passwd")
                                 " if there's a change in hostname, require password re-entry
                                 unlet s:netrw_passwd
                                endif
                                if exists("netrw_port")
                                 unlet netrw_port
                                endif
                               endif
                            
                               if exists("g:netrw_uid") && exists("s:netrw_passwd")
                                let b:netrw_method = 3
                               else
                                let host= substitute(g:netrw_machine,'\..*$','','')
                                if exists("s:netrw_hup[host]")
                                 call NetUserPass("ftp:".host)
                            
                                elseif (has("win32") || has("win95") || has("win64") || has("win16")) && s:netrw_ftp_cmd =~# '-[sS]:'
                            "     call Decho("has -s: : s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
                            "     call Decho("          g:netrw_ftp_cmd<".g:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
                                 if g:netrw_ftp_cmd =~# '-[sS]:\S*MACHINE\>'
                                  let s:netrw_ftp_cmd= substitute(g:netrw_ftp_cmd,'\<MACHINE\>',g:netrw_machine,'')
                            "      call Decho("s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">",'~'.expand("<slnum>"))
                                 endif
                                 let b:netrw_method= 2
                                elseif s:FileReadable(expand("$HOME/.netrc")) && !g:netrw_ignorenetrc
                            "     call Decho("using <".expand("$HOME/.netrc")."> (readable)",'~'.expand("<slnum>"))
                                 let b:netrw_method= 2
                                else
                                 if !exists("g:netrw_uid") || g:netrw_uid == ""
                                  call NetUserPass()
                                 elseif !exists("s:netrw_passwd") || s:netrw_passwd == ""
                                  call NetUserPass(g:netrw_uid)
                                " else just use current g:netrw_uid and s:netrw_passwd
                                 endif
                                 let b:netrw_method= 3
                                endif
                               endif
                            
                              " Method#8: fetch {{{3
                              elseif match(a:choice,fetchurm) == 0
                            "   call Decho("fetch://...",'~'.expand("<slnum>"))
                               let b:netrw_method = 8
                               let g:netrw_userid = substitute(a:choice,fetchurm,'\2',"")
                               let g:netrw_machine= substitute(a:choice,fetchurm,'\3',"")
                               let b:netrw_option = substitute(a:choice,fetchurm,'\4',"")
                               let b:netrw_fname  = substitute(a:choice,fetchurm,'\5',"")
                            
                               " Method#3: Issue an ftp : "machine id password [path/]filename" {{{3
                              elseif match(a:choice,mipf) == 0
                            "   call Decho("(ftp) host id pass file",'~'.expand("<slnum>"))
                               let b:netrw_method  = 3
                               let g:netrw_machine = substitute(a:choice,mipf,'\1',"")
                               let g:netrw_uid     = substitute(a:choice,mipf,'\2',"")
                               let s:netrw_passwd  = substitute(a:choice,mipf,'\3',"")
                               let b:netrw_fname   = substitute(a:choice,mipf,'\4',"")
                               call NetUserPass(g:netrw_machine,g:netrw_uid,s:netrw_passwd)
                            
                              " Method#3: Issue an ftp: "hostname [path/]filename" {{{3
                              elseif match(a:choice,mf) == 0
                            "   call Decho("(ftp) host file",'~'.expand("<slnum>"))
                               if exists("g:netrw_uid") && exists("s:netrw_passwd")
                                let b:netrw_method  = 3
                                let g:netrw_machine = substitute(a:choice,mf,'\1',"")
                                let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
                            
                               elseif s:FileReadable(expand("$HOME/.netrc"))
                                let b:netrw_method  = 2
                                let g:netrw_machine = substitute(a:choice,mf,'\1',"")
                                let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
                               endif
                            
                              " Method#9: sftp://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,sftpurm) == 0
                            "   call Decho("sftp://...",'~'.expand("<slnum>"))
                               let b:netrw_method = 9
                               let g:netrw_machine= substitute(a:choice,sftpurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,sftpurm,'\2',"")
                            
                              " Method#1: Issue an rcp: hostname:filename"  (this one should be last) {{{3
                              elseif match(a:choice,rcphf) == 0
                            "   call Decho("(rcp) [user@]host:file) rcphf<".rcphf.">",'~'.expand("<slnum>"))
                               let b:netrw_method  = 1
                               let userid          = substitute(a:choice,rcphf,'\2',"")
                               let g:netrw_machine = substitute(a:choice,rcphf,'\3',"")
                               let b:netrw_fname   = substitute(a:choice,rcphf,'\4',"")
                            "   call Decho('\1<'.substitute(a:choice,rcphf,'\1',"").">",'~'.expand("<slnum>"))
                            "   call Decho('\2<'.substitute(a:choice,rcphf,'\2',"").">",'~'.expand("<slnum>"))
                            "   call Decho('\3<'.substitute(a:choice,rcphf,'\3',"").">",'~'.expand("<slnum>"))
                            "   call Decho('\4<'.substitute(a:choice,rcphf,'\4',"").">",'~'.expand("<slnum>"))
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                               " Method#10: file://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,fileurm) == 0 && exists("g:netrw_file_cmd")
                            "   call Decho("http[s]://...",'~'.expand("<slnum>"))
                               let b:netrw_method = 10
                               let b:netrw_fname  = substitute(a:choice,fileurm,'\1',"")
                            "   call Decho('\1<'.substitute(a:choice,fileurm,'\1',"").">",'~'.expand("<slnum>"))
                            
                              " Cannot Determine Method {{{3
                              else
                               if !exists("g:netrw_quiet")
                                call netrw#ErrorMsg(s:WARNING,"cannot determine method (format: protocol://[user@]hostname[:port]/[path])",45)
                               endif
                               let b:netrw_method  = -1
                              endif
                              "}}}3
                            
                              if g:netrw_port != ""
                               " remove any leading [:#] from port number
                               let g:netrw_port = substitute(g:netrw_port,'[#:]\+','','')
                              elseif exists("netrw_port")
                               " retain port number as implicit for subsequent ftp operations
                               let g:netrw_port= netrw_port
                              endif
                            
                            "  call Decho("a:choice       <".a:choice.">",'~'.expand("<slnum>"))
                            "  call Decho("b:netrw_method <".b:netrw_method.">",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_machine<".g:netrw_machine.">",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_port   <".g:netrw_port.">",'~'.expand("<slnum>"))
                            "  if exists("g:netrw_uid")		"Decho
                            "   call Decho("g:netrw_uid    <".g:netrw_uid.">",'~'.expand("<slnum>"))
                            "  endif					"Decho
                            "  if exists("s:netrw_passwd")		"Decho
                            "   call Decho("s:netrw_passwd <".s:netrw_passwd.">",'~'.expand("<slnum>"))
                            "  endif					"Decho
                            "  call Decho("b:netrw_fname  <".b:netrw_fname.">",'~'.expand("<slnum>"))
                            "  call Dret("NetrwMethod : b:netrw_method=".b:netrw_method." g:netrw_port=".g:netrw_port)
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetReadFixup: this sort of function is typically written by the user {{{2
                            "               to handle extra junk that their system's ftp dumps
                            "               into the transfer.  This function is provided as an
                            "               example and as a fix for a Windows 95 problem: in my
                            "               experience, win95's ftp always dumped four blank lines
                            "               at the end of the transfer.
    1              0.000007 if has("win95") && exists("g:netrw_win95ftp") && g:netrw_win95ftp
                             fun! NetReadFixup(method, line1, line2)
                            "   call Dfunc("NetReadFixup(method<".a:method."> line1=".a:line1." line2=".a:line2.")")
                            
                               " sanity checks -- attempt to convert inputs to integers
                               let method = a:method + 0
                               let line1  = a:line1 + 0
                               let line2  = a:line2 + 0
                               if type(method) != 0 || type(line1) != 0 || type(line2) != 0 || method < 0 || line1 <= 0 || line2 <= 0
                            "    call Dret("NetReadFixup")
                                return
                               endif
                            
                               if method == 3   " ftp (no <.netrc>)
                                let fourblanklines= line2 - 3
                                if fourblanklines >= line1
                                 exe "sil NetrwKeepj ".fourblanklines.",".line2."g/^\s*$/d"
                                 call histdel("/",-1)
                                endif
                               endif
                            
                            "   call Dret("NetReadFixup")
                             endfun
                            endif
                            
                            " ---------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{2
                            "   Usage:  :call NetUserPass()		               -- will prompt for userid and password
                            "	    :call NetUserPass("uid")	               -- will prompt for password
                            "	    :call NetUserPass("uid","password")        -- sets global userid and password
                            "	    :call NetUserPass("ftp:host")              -- looks up userid and password using hup dictionary
                            "	    :call NetUserPass("host","uid","password") -- sets hup dictionary with host, userid, password
    1              0.000001 fun! NetUserPass(...)
                            
                            " call Dfunc("NetUserPass() a:0=".a:0)
                            
                             if !exists('s:netrw_hup')
                              let s:netrw_hup= {}
                             endif
                            
                             if a:0 == 0
                              " case: no input arguments
                            
                              " change host and username if not previously entered; get new password
                              if !exists("g:netrw_machine")
                               let g:netrw_machine= input('Enter hostname: ')
                              endif
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " get username (user-id) via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                              " get password via prompting
                              let s:netrw_passwd= inputsecret("Enter Password: ")
                            
                              " set up hup database
                              let host = substitute(g:netrw_machine,'\..*$','','')
                              if !exists('s:netrw_hup[host]')
                               let s:netrw_hup[host]= {}
                              endif
                              let s:netrw_hup[host].uid    = g:netrw_uid
                              let s:netrw_hup[host].passwd = s:netrw_passwd
                            
                             elseif a:0 == 1
                              " case: one input argument
                            
                              if a:1 =~ '^ftp:'
                               " get host from ftp:... url
                               " access userid and password from hup (host-user-passwd) dictionary
                            "   call Decho("case a:0=1: a:1<".a:1."> (get host from ftp:... url)",'~'.expand("<slnum>"))
                               let host = substitute(a:1,'^ftp:','','')
                               let host = substitute(host,'\..*','','')
                               if exists("s:netrw_hup[host]")
                                let g:netrw_uid    = s:netrw_hup[host].uid
                                let s:netrw_passwd = s:netrw_hup[host].passwd
                            "    call Decho("get s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">",'~'.expand("<slnum>"))
                            "    call Decho("get s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">",'~'.expand("<slnum>"))
                               else
                                let g:netrw_uid    = input("Enter UserId: ")
                                let s:netrw_passwd = inputsecret("Enter Password: ")
                               endif
                            
                              else
                               " case: one input argument, not an url.  Using it as a new user-id.
                            "   call Decho("case a:0=1: a:1<".a:1."> (get host from input argument, not an url)",'~'.expand("<slnum>"))
                               if exists("g:netrw_machine")
                                if g:netrw_machine =~ '[0-9.]\+'
                                 let host= g:netrw_machine
                                else
                                 let host= substitute(g:netrw_machine,'\..*$','','')
                                endif
                               else
                                let g:netrw_machine= input('Enter hostname: ')
                               endif
                               let g:netrw_uid = a:1
                            "   call Decho("set g:netrw_uid= <".g:netrw_uid.">",'~'.expand("<slnum>"))
                               if exists("g:netrw_passwd")
                                " ask for password if one not previously entered
                                let s:netrw_passwd= g:netrw_passwd
                               else
                                let s:netrw_passwd = inputsecret("Enter Password: ")
                               endif
                              endif
                            
                            "  call Decho("host<".host.">",'~'.expand("<slnum>"))
                              if exists("host")
                               if !exists('s:netrw_hup[host]')
                                let s:netrw_hup[host]= {}
                               endif
                               let s:netrw_hup[host].uid    = g:netrw_uid
                               let s:netrw_hup[host].passwd = s:netrw_passwd
                              endif
                            
                             elseif a:0 == 2
                              let g:netrw_uid    = a:1
                              let s:netrw_passwd = a:2
                            
                             elseif a:0 == 3
                              " enter hostname, user-id, and password into the hup dictionary
                              let host = substitute(a:1,'^\a\+:','','')
                              let host = substitute(host,'\..*$','','')
                              if !exists('s:netrw_hup[host]')
                               let s:netrw_hup[host]= {}
                              endif
                              let s:netrw_hup[host].uid    = a:2
                              let s:netrw_hup[host].passwd = a:3
                              let g:netrw_uid              = s:netrw_hup[host].uid
                              let s:netrw_passwd           = s:netrw_hup[host].passwd
                            "  call Decho("set s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">",'~'.expand("<slnum>"))
                            "  call Decho("set s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">",'~'.expand("<slnum>"))
                             endif
                            
                            " call Dret("NetUserPass : uid<".g:netrw_uid."> passwd<".s:netrw_passwd.">")
                            endfun
                            
                            " ===========================================
                            "  Shared Browsing Support:    {{{1
                            " ===========================================
                            
                            " ---------------------------------------------------------------------
                            " s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
    1              0.000002 fun! s:ExplorePatHls(pattern)
                            "  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
                              let repat= substitute(a:pattern,'^**/\{1,2}','','')
                            "  call Decho("repat<".repat.">",'~'.expand("<slnum>"))
                              let repat= escape(repat,'][.\')
                            "  call Decho("repat<".repat.">",'~'.expand("<slnum>"))
                              let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
                            "  call Dret("s:ExplorePatHls repat<".repat.">")
                              return repat
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwBookHistHandler: {{{2
                            "    0: (user: <mb>)   bookmark current directory
                            "    1: (user: <gb>)   change to the bookmarked directory
                            "    2: (user: <qb>)   list bookmarks
                            "    3: (browsing)     records current directory history
                            "    4: (user: <u>)    go up   (previous) directory, using history
                            "    5: (user: <U>)    go down (next)     directory, using history
                            "    6: (user: <mB>)   delete bookmark
    1              0.000002 fun! s:NetrwBookHistHandler(chg,curdir)
                            "  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                            
                              let ykeep    = @@
                              let curbufnr = bufnr("%")
                            
                              if a:chg == 0
                               " bookmark the current directory
                            "   call Decho("(user: <b>) bookmark the current directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(0)
                                echo "bookmarked marked files"
                               else
                                call s:MakeBookmark(a:curdir)
                                echo "bookmarked the current directory"
                               endif
                            
                              elseif a:chg == 1
                               " change to the bookmarked directory
                            "   call Decho("(user: <".v:count."gb>) change to the bookmarked directory",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist[v:count-1]")
                            "    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
                               else
                                echomsg "Sorry, bookmark#".v:count." doesn't exist!"
                               endif
                            
                              elseif a:chg == 2
                            "   redraw!
                               let didwork= 0
                               " list user's bookmarks
                            "   call Decho("(user: <q>) list user's bookmarks",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist")
                            "    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks','~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1],'~'.expand("<slnum>"))
                                 echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
                                 let didwork = 1
                                 let cnt     = cnt + 1
                                endfor
                               endif
                            
                               " list directory history
                               let cnt     = g:netrw_dirhist_cnt
                               let first   = 1
                               let histcnt = 0
                               if g:netrw_dirhistmax > 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                            "    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt,'~'.expand("<slnum>"))
                                 if exists("g:netrw_dirhist_{cnt}")
                            "     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt},'~'.expand("<slnum>"))
                                  echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
                                  let didwork= 1
                                 endif
                                 let histcnt = histcnt + 1
                                 let first   = 0
                                 let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if didwork
                                call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               endif
                            
                              elseif a:chg == 3
                               " saves most recently visited directories (when they differ)
                            "   call Decho("(browsing) record curdir history",'~'.expand("<slnum>"))
                               if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                 let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
                                endif
                            "    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
                               endif
                            
                              elseif a:chg == 4
                               " u: change to the previous directory stored on the history list
                            "   call Decho("(user: <u>) chg to prev dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
                                if g:netrw_dirhist_cnt < 0
                                 let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                 setl ma noro
                            "     call Decho("setl ma noro",'~'.expand("<slnum>"))
                                 sil! NetrwKeepj %d _
                                 setl nomod
                            "     call Decho("setl nomod",'~'.expand("<slnum>"))
                            "     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                               else
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
                                else
                                 let g:netrw_dirhist_cnt= 0
                                endif
                                echo "Sorry, no predecessor directory exists yet"
                               endif
                            
                              elseif a:chg == 5
                               " U: change to the subsequent directory stored on the history list
                            "   call Decho("(user: <U>) chg to next dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
                                 if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                            "      call Decho("setl ma noro",'~'.expand("<slnum>"))
                                  setl ma noro
                                  sil! NetrwKeepj %d _
                            "      call Decho("removed all lines from buffer (%d)",'~'.expand("<slnum>"))
                            "      call Decho("setl nomod",'~'.expand("<slnum>"))
                                  setl nomod
                            "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
                                 exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                                else
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
                                 if g:netrw_dirhist_cnt < 0
                                  let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                 endif
                                 echo "Sorry, no successor directory exists yet"
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                                echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
                               endif
                            
                              elseif a:chg == 6
                            "   call Decho("(user: <mB>) delete bookmark'd directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(1)
                                echo "removed marked files from bookmarks"
                               else
                                " delete the v:count'th bookmark
                                let iremove = v:count
                                let dremove = g:netrw_bookmarklist[iremove - 1]
                            "    call Decho("delete bookmark#".iremove."<".g:netrw_bookmarklist[iremove - 1].">",'~'.expand("<slnum>"))
                                call s:MergeBookmarks()
                            "    call Decho("remove g:netrw_bookmarklist[".(iremove-1)."]<".g:netrw_bookmarklist[(iremove-1)].">",'~'.expand("<slnum>"))
                                NetrwKeepj call remove(g:netrw_bookmarklist,iremove-1)
                                echo "removed ".dremove." from g:netrw_bookmarklist"
                            "    call Decho("g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                               endif
                            "   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                              endif
                              call s:NetrwBookmarkMenu()
                              call s:NetrwTgtMenu()
                              let @@= ykeep
                            "  call Dret("s:NetrwBookHistHandler")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookHistRead: this function reads bookmarks and history {{{2
                            "  Will source the history file (.netrwhist) only if the g:netrw_disthistmax is > 0.
                            "                      Sister function: s:NetrwBookHistSave()
    1              0.000002 fun! s:NetrwBookHistRead()
                            "  call Dfunc("s:NetrwBookHistRead()")
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                              let ykeep= @@
                              if !exists("s:netrw_initbookhist")
                               let home    = s:NetrwHome()
                               let savefile= home."/.netrwbook"
                               if filereadable(s:NetrwFile(savefile))
                            "    call Decho("sourcing .netrwbook",'~'.expand("<slnum>"))
                                exe "keepalt NetrwKeepj so ".savefile
                               endif
                               if g:netrw_dirhistmax > 0
                                let savefile= home."/.netrwhist"
                                if filereadable(s:NetrwFile(savefile))
                            "    call Decho("sourcing .netrwhist",'~'.expand("<slnum>"))
                                 exe "keepalt NetrwKeepj so ".savefile
                                endif
                                let s:netrw_initbookhist= 1
                                au VimLeave * call s:NetrwBookHistSave()
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwBookHistRead")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookHistSave: this function saves bookmarks and history {{{2
                            "                      Sister function: s:NetrwBookHistRead()
                            "                      I used to do this via viminfo but that appears to
                            "                      be unreliable for long-term storage
                            "                      If g:netrw_dirhistmax is <= 0, no history or bookmarks
                            "                      will be saved.
    1              0.000002 fun! s:NetrwBookHistSave()
                            "  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
                               return
                              endif
                            
                              let savefile= s:NetrwHome()."/.netrwhist"
                              1split
                              call s:NetrwEnew()
                              if g:netrw_use_noswf
                               setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
                              else
                               setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000
                              endif
                              setl nocin noai noci magic nospell nohid wig= noaw
                              setl ma noro write
                              if exists("+acd") | setl noacd | endif
                              sil! NetrwKeepj keepalt %d _
                            
                              " save .netrwhist -- no attempt to merge
                              sil! keepalt file .netrwhist
                              call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
                              call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
                              let lastline = line("$")
                              let cnt      = 1
                              while cnt <= g:netrw_dirhist_cnt
                               call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
                               let cnt= cnt + 1
                              endwhile
                              exe "sil! w! ".savefile
                            
                              sil NetrwKeepj %d _
                              if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
                               " merge and write .netrwbook
                               let savefile= s:NetrwHome()."/.netrwbook"
                            
                               if filereadable(s:NetrwFile(savefile))
                                let booklist= deepcopy(g:netrw_bookmarklist)
                                exe "sil NetrwKeepj keepalt so ".savefile
                                for bdm in booklist
                                 if index(g:netrw_bookmarklist,bdm) == -1
                                  call add(g:netrw_bookmarklist,bdm)
                                 endif
                                endfor
                                call sort(g:netrw_bookmarklist)
                               endif
                            
                               " construct and save .netrwbook
                               call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
                               exe "sil! w! ".savefile
                              endif
                              let bgone= bufnr("%")
                              q!
                              exe "keepalt ".bgone."bwipe!"
                            
                            "  call Dret("s:NetrwBookHistSave")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBrowse: This function uses the command in g:netrw_list_cmd to provide a {{{2
                            "  list of the contents of a local or remote directory.  It is assumed that the
                            "  g:netrw_list_cmd has a string, USEPORT HOSTNAME, that needs to be substituted
                            "  with the requested remote hostname first.
                            "    Often called via:  Explore/e dirname/etc -> netrw#LocalBrowseCheck() -> s:NetrwBrowse()
    1              0.000002 fun! s:NetrwBrowse(islocal,dirname)
                              if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                            "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
                            "  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dredir("ls!")
                            
                              " save alternate-file's filename if w:netrw_rexlocal doesn't exist
                              " This is useful when one edits a local file, then :e ., then :Rex
                              if a:islocal && !exists("w:netrw_rexfile") && bufname("#") != ""
                               let w:netrw_rexfile= bufname("#")
                            "   call Decho("setting w:netrw_rexfile<".w:netrw_rexfile."> win#".winnr(),'~'.expand("<slnum>"))
                              endif
                            
                              " s:NetrwBrowse : initialize history {{{3
                              if !exists("s:netrw_initbookhist")
                               NetrwKeepj call s:NetrwBookHistRead()
                              endif
                            
                              " s:NetrwBrowse : simplify the dirname (especially for ".."s in dirnames) {{{3
                              if a:dirname !~ '^\a\{3,}://'
                               let dirname= simplify(a:dirname)
                              else
                               let dirname= a:dirname
                              endif
                            
                              if exists("s:netrw_skipbrowse")
                               unlet s:netrw_skipbrowse
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
                               return
                              endif
                            
                              " s:NetrwBrowse : sanity checks: {{{3
                              if !exists("*shellescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
                            "   call Dret("s:NetrwBrowse : missing shellescape()")
                               return
                              endif
                              if !exists("*fnameescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
                            "   call Dret("s:NetrwBrowse : missing fnameescape()")
                               return
                              endif
                            
                              " s:NetrwBrowse : save options: {{{3
                              call s:NetrwOptionSave("w:")
                            
                              " s:NetrwBrowse : re-instate any marked files {{{3
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("clearing marked files",'~'.expand("<slnum>"))
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              endif
                            
                              if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
                               " s:NetrwBrowse : set up "safe" options for local directory/file {{{3
                            "   call Decho("handle w:netrw_acdkeep:",'~'.expand("<slnum>"))
                            "   call Decho("NetrwKeepj lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")",'~'.expand("<slnum>"))
                               call s:NetrwLcd(dirname)
                               call s:NetrwSafeOptions()
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            
                              elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
                               " s:NetrwBrowse :  remote regular file handler {{{3
                            "   call Decho("handle remote regular file: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if bufname(dirname) != ""
                            "    call Decho("edit buf#".bufname(dirname)." in win#".winnr(),'~'.expand("<slnum>"))
                                exe "NetrwKeepj b ".bufname(dirname)
                               else
                                " attempt transfer of remote regular file
                            "    call Decho("attempt transfer as regular file<".dirname.">",'~'.expand("<slnum>"))
                            
                                " remove any filetype indicator from end of dirname, except for the
                                " "this is a directory" indicator (/).
                                " There shouldn't be one of those here, anyway.
                                let path= substitute(dirname,'[*=@|]\r\=$','','e')
                            "    call Decho("new path<".path.">",'~'.expand("<slnum>"))
                                call s:RemotePathAnalysis(dirname)
                            
                                " s:NetrwBrowse : remote-read the requested file into current buffer {{{3
                                call s:NetrwEnew(dirname)
                                call s:NetrwSafeOptions()
                                setl ma noro
                            "    call Decho("setl ma noro",'~'.expand("<slnum>"))
                                let b:netrw_curdir = dirname
                                let url            = s:method."://".((s:user == "")? "" : s:user."@").s:machine.(s:port ? ":".s:port : "")."/".s:path
                            "    call Decho("exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")",'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj keepalt file ".fnameescape(url)
                                exe "sil! NetrwKeepj keepalt doau BufReadPre ".fnameescape(s:fname)
                                sil call netrw#NetRead(2,url)
                                " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
                            "    call Decho("url<".url.">",'~'.expand("<slnum>"))
                            "    call Decho("s:path<".s:path.">",'~'.expand("<slnum>"))
                            "    call Decho("s:fname<".s:fname.">",'~'.expand("<slnum>"))
                                if s:path =~ '.bz2'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
                                else
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(s:fname)
                                endif
                               endif
                            
                               " s:NetrwBrowse : save certain window-oriented variables into buffer-oriented variables {{{3
                               call s:SetBufWinVars()
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("setl ma nomod",'~'.expand("<slnum>"))
                               setl ma nomod noro
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            
                            "   call Dret("s:NetrwBrowse : file<".s:fname.">")
                               return
                              endif
                            
                              " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
                              call s:UseBufWinVars()
                            
                              " set up some variables {{{3
                              let b:netrw_browser_active = 1
                              let dirname                = dirname
                              let s:last_sort_by         = g:netrw_sort_by
                            
                              " set up menu {{{3
                              NetrwKeepj call s:NetrwMenu(1)
                            
                              " get/set-up buffer {{{3
                            "  call Decho("saving position across a buffer refresh",'~'.expand("<slnum>"))
                              let svpos  = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let reusing= s:NetrwGetBuffer(a:islocal,dirname)
                            
                              " maintain markfile highlighting
                              if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("bufnr(%)=".bufnr('%'),'~'.expand("<slnum>"))
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("2match none",'~'.expand("<slnum>"))
                               2match none
                              endif
                              if reusing && line("$") > 1
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                               setl noma nomod nowrap
                            "   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : re-using not-cleared buffer")
                               return
                              endif
                            
                              " set b:netrw_curdir to the new directory name {{{3
                            "  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")",'~'.expand("<slnum>"))
                              let b:netrw_curdir= dirname
                              if b:netrw_curdir =~ '[/\\]$'
                               let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
                              endif
                              if b:netrw_curdir =~ '\a:$' && (has("win32") || has("win95") || has("win64") || has("win16"))
                               let b:netrw_curdir= b:netrw_curdir."/"
                              endif
                              if b:netrw_curdir == ''
                               if has("amiga")
                                " On the Amiga, the empty string connotes the current directory
                                let b:netrw_curdir= getcwd()
                               else
                                " under unix, when the root directory is encountered, the result
                                " from the preceding substitute is an empty string.
                                let b:netrw_curdir= '/'
                               endif
                              endif
                              if !a:islocal && b:netrw_curdir !~ '/$'
                               let b:netrw_curdir= b:netrw_curdir.'/'
                              endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                            
                              " ------------
                              " (local only) {{{3
                              " ------------
                              if a:islocal
                            "   call Decho("local only:",'~'.expand("<slnum>"))
                            
                               " Set up ShellCmdPost handling.  Append current buffer to browselist
                               call s:LocalFastBrowser()
                            
                              " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
                               if !g:netrw_keepdir
                            "    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"),'~'.expand("<slnum>"))
                                if !exists("&l:acd") || !&l:acd
                                 call s:NetrwLcd(b:netrw_curdir)
                                endif
                               endif
                            
                              " --------------------------------
                              " remote handling: {{{3
                              " --------------------------------
                              else
                            "   call Decho("remote only:",'~'.expand("<slnum>"))
                            
                               " analyze dirname and g:netrw_list_cmd {{{3
                            "   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">",'~'.expand("<slnum>"))
                               if dirname =~# "^NetrwTreeListing\>"
                                let dirname= b:netrw_curdir
                            "    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">",'~'.expand("<slnum>"))
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                let dirname= substitute(b:netrw_curdir,'\\','/','g')
                                if dirname !~ '/$'
                                 let dirname= dirname.'/'
                                endif
                                let b:netrw_curdir = dirname
                            "    call Decho("(liststyle is TREELIST) dirname<".dirname.">",'~'.expand("<slnum>"))
                               else
                                let dirname = substitute(dirname,'\\','/','g')
                            "    call Decho("(normal) dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                            
                               let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
                               if dirname !~ dirpat
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
                                endif
                                NetrwKeepj call s:NetrwOptionRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                setl noma nomod nowrap
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
                                return
                               endif
                               let b:netrw_curdir= dirname
                            "   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)",'~'.expand("<slnum>"))
                              endif  " (additional remote handling)
                            
                              " -----------------------
                              " Directory Listing: {{{3
                              " -----------------------
                              NetrwKeepj call s:NetrwMaps(a:islocal)
                              NetrwKeepj call s:NetrwCommands(a:islocal)
                              NetrwKeepj call s:PerformListing(a:islocal)
                            
                              " restore option(s)
                              call s:NetrwOptionRestore("w:")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                              " If there is a rexposn: restore position with rexposn
                              " Otherwise            : set rexposn
                              if exists("s:rexposn_".bufnr("%"))
                            "   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
                               if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                                NetrwKeepj exe w:netrw_bannercnt
                               endif
                              else
                               NetrwKeepj call s:SetRexDir(a:islocal,b:netrw_curdir)
                              endif
                              if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
                               let &l:bexpr= "netrw#BalloonHelp()"
                            "   call Decho("set up balloon help: l:bexpr=".&l:bexpr,'~'.expand("<slnum>"))
                               setl beval
                              endif
                            
                              " restore position
                              if reusing
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               call winrestview(svpos)
                              endif
                            
                              " The s:LocalBrowseRefresh() function is called by an autocmd
                              " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
                              " However, s:NetrwBrowse() causes the FocusGained event to fire the firstt time.
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
                              return
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwFile: because of g:netrw_keepdir, isdirectory(), type(), etc may or {{{2
                            " may not apply correctly; ie. netrw's idea of the current directory may
                            " differ from vim's.  This function insures that netrw's idea of the current
                            " directory is used.
    1              0.000002 fun! s:NetrwFile(fname)
                            "  call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
                            "  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            
                              " clean up any leading treedepthstring
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
                            "   call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
                              else
                               let fname= a:fname
                              endif
                            
                              if g:netrw_keepdir
                               " vim's idea of the current directory possibly may differ from netrw's
                               if !exists("b:netrw_curdir")
                                let b:netrw_curdir= getcwd()
                               endif
                            
                               if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                                if fname =~ '^\' || fname =~ '^\a:\'
                                 " windows, but full path given
                                 let ret= fname
                            "     call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                else
                                 " windows, relative path given
                                 let ret= s:ComposePath(b:netrw_curdir,fname)
                            "     call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                endif
                            
                               elseif fname =~ '^/'
                                " not windows, full path given
                                let ret= fname
                            "    call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               else
                                " not windows, relative path given
                                let ret= s:ComposePath(b:netrw_curdir,fname)
                            "    call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               endif
                              else
                               " vim and netrw agree on the current directory
                               let ret= fname
                            "   call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
                            "   call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
                            "   call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
                              endif
                            
                            "  call Dret("s:NetrwFile ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwFileInfo: supports qf (query for file information) {{{2
    1              0.000007 fun! s:NetrwFileInfo(islocal,fname)
                            "  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">) b:netrw_curdir<".b:netrw_curdir.">")
                              let ykeep= @@
                              if a:islocal
                               let lsopt= "-lsad"
                               if g:netrw_sizestyle =~# 'H'
                                let lsopt= "-lsadh"
                               elseif g:netrw_sizestyle =~# 'h'
                                let lsopt= "-lsadh --si"
                               endif
                               if (has("unix") || has("macunix")) && executable("/bin/ls")
                            
                                if getline(".") == "../"
                                 echo system("/bin/ls ".lsopt." ".s:ShellEscape(".."))
                            "     call Decho("#1: echo system(/bin/ls -lsad ".s:ShellEscape(..).")",'~'.expand("<slnum>"))
                            
                                elseif w:netrw_liststyle == s:TREELIST && getline(".") !~ '^'.s:treedepthstring
                                 echo system("/bin/ls ".lsopt." ".s:ShellEscape(b:netrw_curdir))
                            "     call Decho("#2: echo system(/bin/ls -lsad ".s:ShellEscape(b:netrw_curdir).")",'~'.expand("<slnum>"))
                            
                                elseif exists("b:netrw_curdir")
                                  echo system("/bin/ls ".lsopt." ".s:ShellEscape(s:ComposePath(b:netrw_curdir,a:fname)))
                            "      call Decho("#3: echo system(/bin/ls -lsad ".s:ShellEscape(b:netrw_curdir.a:fname).")",'~'.expand("<slnum>"))
                            
                                else
                            "     call Decho('using ls '.a:fname." using cwd<".getcwd().">",'~'.expand("<slnum>"))
                                 echo system("/bin/ls ".lsopt." ".s:ShellEscape(s:NetrwFile(a:fname)))
                            "     call Decho("#5: echo system(/bin/ls -lsad ".s:ShellEscape(a:fname).")",'~'.expand("<slnum>"))
                                endif
                               else
                                " use vim functions to return information about file below cursor
                            "    call Decho("using vim functions to query for file info",'~'.expand("<slnum>"))
                                if !isdirectory(s:NetrwFile(a:fname)) && !filereadable(s:NetrwFile(a:fname)) && a:fname =~ '[*@/]'
                                 let fname= substitute(a:fname,".$","","")
                                else
                                 let fname= a:fname
                                endif
                                let t  = getftime(s:NetrwFile(fname))
                                let sz = getfsize(s:NetrwFile(fname))
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                echo a:fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(s:NetrwFile(fname)))
                            "    call Decho("fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)),'~'.expand("<slnum>"))
                               endif
                              else
                               echo "sorry, \"qf\" not supported yet for remote files"
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwFileInfo")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwFullPath: returns the full path to a directory and/or file {{{2
    1              0.000002 fun! s:NetrwFullPath(filename)
                            "  " call Dfunc("s:NetrwFullPath(filename<".a:filename.">)")
                              let filename= a:filename
                              if filename !~ '^/'
                               let filename= resolve(getcwd().'/'.filename)
                              endif
                              if filename != "/" && filename =~ '/$'
                               let filename= substitute(filename,'/$','','')
                              endif
                            "  " call Dret("s:NetrwFullPath <".filename.">")
                              return filename
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGetBuffer: {{{2
                            "   returns 0=cleared buffer
                            "           1=re-used buffer (buffer not cleared)
    1              0.000002 fun! s:NetrwGetBuffer(islocal,dirname)
                            "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
                              let dirname= a:dirname
                            
                              " re-use buffer if possible {{{3
                            "  call Decho("--re-use a buffer if possible--",'~'.expand("<slnum>"))
                              if !exists("s:netrwbuf")
                               let s:netrwbuf= {}
                              endif
                              if has_key(s:netrwbuf,s:NetrwFullPath(dirname))
                               let bufnum= s:netrwbuf[s:NetrwFullPath(dirname)]
                            "   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnum)
                               if !bufexists(bufnum)
                                call remove(s:netrwbuf,s:NetrwFullPath(dirname))
                                let bufnum= -1
                               endif
                              else
                            "   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."] not a key")
                               let bufnum= -1
                              endif
                            
                              " get enew buffer and name it -or- re-use buffer {{{3
                              if bufnum < 0      " get enew buffer and name it
                            "   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)",'~'.expand("<slnum>"))
                               call s:NetrwEnew(dirname)
                            "   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)",'~'.expand("<slnum>"))
                               " name the buffer
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                " Got enew buffer; transform into a NetrwTreeListing
                            "    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --",'~'.expand("<slnum>"))
                                if !exists("s:netrw_treelistnum")
                                 let s:netrw_treelistnum= 1
                                else
                                 let s:netrw_treelistnum= s:netrw_treelistnum + 1
                                endif
                                let w:netrw_treebufnr= bufnr("%")
                            "    call Decho("  exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum),'~'.expand("<slnum>"))
                                exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
                                if g:netrw_use_noswf
                                 setl nobl bt=nofile noswf
                                else
                                 setl nobl bt=nofile
                                endif
                                nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[[')<cr>
                                nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']]')<cr>
                                nnoremap <silent> <buffer> []       :sil call <SID>TreeListMove('[]')<cr>
                                nnoremap <silent> <buffer> ][       :sil call <SID>TreeListMove('][')<cr>
                            "    call Decho("  tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr,'~'.expand("<slnum>"))
                               else
                            "    let v:errmsg   = "" " Decho
                                let escdirname = fnameescape(dirname)
                            "    call Decho("  errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
                            "    call Decho('  exe sil! keepalt file '.escdirname,'~'.expand("<slnum>"))
                            "    let v:errmsg= "" " Decho
                                exe 'sil! keepj keepalt file '.escdirname
                            "    call Decho("  errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
                                " enter the new buffer into the s:netrwbuf dictionary
                                let s:netrwbuf[s:NetrwFullPath(dirname)]= bufnr("%")
                            "    call Decho("update netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnr("%"),'~'.expand("<slnum>"))
                            "    call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
                               endif
                            "   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              else " Re-use the buffer
                            "   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)",'~'.expand("<slnum>"))
                               let eikeep= &ei
                               setl ei=all
                               if getline(2) =~# '^" Netrw Directory Listing'
                            "    call Decho("  getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum,'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
                               else
                            "    call Decho("  getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum,'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
                               endif
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
                               if bufname("%") == '.'
                            "    call Decho("exe sil! keepalt file ".fnameescape(getcwd()),'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj keepalt file ".fnameescape(getcwd())
                               endif
                               let &ei= eikeep
                            
                               if line("$") <= 1 && getline(1) == ""
                                " empty buffer
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
                                return 0
                            
                               elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
                            "    call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse." a:islocal=".a:islocal.": clear buffer",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                                sil NetrwKeepj %d _
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
                                return 0
                            
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "    call Decho("--re-use tree listing--",'~'.expand("<slnum>"))
                            "    call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                                sil NetrwKeepj %d _
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
                                return 0
                            
                               else
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 1<buffer not cleared>")
                                return 1
                               endif
                              endif
                            
                              " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
                              "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
                              "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
                              "  med    1         D      H
                              "  fast   2         H      H
                            "  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--",'~'.expand("<slnum>"))
                              let fname= expand("%")
                              NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "  call Decho("exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
                              exe "sil! NetrwKeepj keepalt file ".fnameescape(fname)
                            
                              " delete all lines from buffer {{{3
                            "  call Decho("--delete all lines from buffer--",'~'.expand("<slnum>"))
                            "  call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                              sil! keepalt NetrwKeepj %d _
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwGetBuffer 0<cleared buffer>")
                              return 0
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGetcwd: get the current directory. {{{2
                            "   Change backslashes to forward slashes, if any.
                            "   If doesc is true, escape certain troublesome characters
    1              0.000002 fun! s:NetrwGetcwd(doesc)
                            "  call Dfunc("NetrwGetcwd(doesc=".a:doesc.")")
                              let curdir= substitute(getcwd(),'\\','/','ge')
                              if curdir !~ '[\/]$'
                               let curdir= curdir.'/'
                              endif
                              if a:doesc
                               let curdir= fnameescape(curdir)
                              endif
                            "  call Dret("NetrwGetcwd <".curdir.">")
                              return curdir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwGetWord: it gets the directory/file named under the cursor {{{2
    1              0.000002 fun! s:NetrwGetWord()
                            "  call Dfunc("s:NetrwGetWord() liststyle=".s:ShowStyle()." virtcol=".virtcol("."))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                              let keepsol= &l:sol
                              setl nosol
                            
                              call s:UseBufWinVars()
                            
                              " insure that w:netrw_liststyle is set up
                              if !exists("w:netrw_liststyle")
                               if exists("g:netrw_liststyle")
                                let w:netrw_liststyle= g:netrw_liststyle
                               else
                                let w:netrw_liststyle= s:THINLIST
                               endif
                            "   call Decho("w:netrw_liststyle=".w:netrw_liststyle,'~'.expand("<slnum>"))
                              endif
                            
                              if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                               " Active Banner support
                            "   call Decho("active banner handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= "./"
                               let curline= getline('.')
                            
                               if curline =~# '"\s*Sorted by\s'
                                NetrwKeepj norm s
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "s" also works'
                            
                               elseif curline =~# '"\s*Sort sequence:'
                                let s:netrw_skipbrowse= 1
                                echo 'Press "S" to edit sorting sequence'
                            
                               elseif curline =~# '"\s*Quick Help:'
                                NetrwKeepj norm ?
                                let s:netrw_skipbrowse= 1
                            
                               elseif curline =~# '"\s*\%(Hiding\|Showing\):'
                                NetrwKeepj norm a
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "a" also works'
                            
                               elseif line("$") > w:netrw_bannercnt
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt
                               endif
                            
                              elseif w:netrw_liststyle == s:THINLIST
                            "   call Decho("thin column handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= substitute(getline('.'),'\t -->.*$','','')
                            
                              elseif w:netrw_liststyle == s:LONGLIST
                            "   call Decho("long column handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Decho("treelist handling",'~'.expand("<slnum>"))
                               let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
                               let dirname= substitute(dirname,'\t -->.*$','','')
                            
                              else
                            "   call Decho("obtain word from wide listing",'~'.expand("<slnum>"))
                               let dirname= getline('.')
                            
                               if !exists("b:netrw_cpf")
                                let b:netrw_cpf= 0
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                call histdel("/",-1)
                            "   "call Decho("computed cpf=".b:netrw_cpf,'~'.expand("<slnum>"))
                               endif
                            
                            "   call Decho("buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                               let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
                            "   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                            "   call Decho("1: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if filestart == 0
                                NetrwKeepj norm! 0ma
                               else
                                call cursor(line("."),filestart+1)
                                NetrwKeepj norm! ma
                               endif
                               let rega= @a
                               let eofname= filestart + b:netrw_cpf + 1
                               if eofname <= col("$")
                                call cursor(line("."),filestart+b:netrw_cpf+1)
                                NetrwKeepj norm! "ay`a
                               else
                                NetrwKeepj norm! "ay$
                               endif
                               let dirname = @a
                               let @a      = rega
                            "   call Decho("2: dirname<".dirname.">",'~'.expand("<slnum>"))
                               let dirname= substitute(dirname,'\s\+$','','e')
                            "   call Decho("3: dirname<".dirname.">",'~'.expand("<slnum>"))
                              endif
                            
                              " symlinks are indicated by a trailing "@".  Remove it before further processing.
                              let dirname= substitute(dirname,"@$","","")
                            
                              " executables are indicated by a trailing "*".  Remove it before further processing.
                              let dirname= substitute(dirname,"\*$","","")
                            
                              let &l:sol= keepsol
                            
                            "  call Dret("s:NetrwGetWord <".dirname.">")
                              return dirname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwListSettings: make standard settings for a netrw listing {{{2
    1              0.000002 fun! s:NetrwListSettings(islocal)
                            "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                              let fname= bufname("%")
                            "  "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro nornu",'~'.expand("<slnum>"))
                              setl bt=nofile nobl ma nonu nowrap noro nornu
                            "  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
                              exe "sil! keepalt file ".fnameescape(fname)
                              if g:netrw_use_noswf
                               setl noswf
                              endif
                            "  call Dredir("ls!")
                            "  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
                              exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              setl isk+=.,~,-
                              if g:netrw_fastbrowse > a:islocal
                               setl bh=hide
                              else
                               setl bh=delete
                              endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwListSettings")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwListStyle: {{{2
                            "  islocal=0: remote browsing
                            "         =1: local browsing
    1              0.000002 fun! s:NetrwListStyle(islocal)
                            "  call Dfunc("NetrwListStyle(islocal=".a:islocal.") w:netrw_liststyle=".w:netrw_liststyle)
                            
                              let ykeep             = @@
                              let fname             = s:NetrwGetWord()
                              if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                              let svpos            = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let w:netrw_liststyle = (w:netrw_liststyle + 1) % s:MAXLIST
                            "  call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                            "  call Decho("chgd w:netrw_liststyle to ".w:netrw_liststyle,'~'.expand("<slnum>"))
                            "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))
                            
                              if w:netrw_liststyle == s:THINLIST
                               " use one column listing
                            "   call Decho("use one column list",'~'.expand("<slnum>"))
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              elseif w:netrw_liststyle == s:LONGLIST
                               " use long list
                            "   call Decho("use long list",'~'.expand("<slnum>"))
                               let g:netrw_list_cmd = g:netrw_list_cmd." -l"
                            
                              elseif w:netrw_liststyle == s:WIDELIST
                               " give wide list
                            "   call Decho("use wide list",'~'.expand("<slnum>"))
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Decho("use tree list",'~'.expand("<slnum>"))
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"bad value for g:netrw_liststyle (=".w:netrw_liststyle.")",46)
                               let g:netrw_liststyle = s:THINLIST
                               let w:netrw_liststyle = g:netrw_liststyle
                               let g:netrw_list_cmd  = substitute(g:netrw_list_cmd,' -l','','ge')
                              endif
                              setl ma noro
                            "  call Decho("setl ma noro",'~'.expand("<slnum>"))
                            
                              " clear buffer - this will cause NetrwBrowse/LocalBrowseCheck to do a refresh
                            "  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                              sil! NetrwKeepj %d _
                              " following prevents tree listing buffer from being marked "modified"
                            "  call Decho("setl nomod",'~'.expand("<slnum>"))
                              setl nomod
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            
                              " refresh the listing
                            "  call Decho("refresh the listing",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              NetrwKeepj call s:NetrwCursor()
                            
                              " restore position; keep cursor on the filename
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetrwListStyle".(exists("w:netrw_liststyle")? ' : w:netrw_liststyle='.w:netrw_liststyle : ""))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBannerCtrl: toggles the display of the banner {{{2
    1              0.000002 fun! s:NetrwBannerCtrl(islocal)
                            "  call Dfunc("s:NetrwBannerCtrl(islocal=".a:islocal.") g:netrw_banner=".g:netrw_banner)
                            
                              let ykeep= @@
                              " toggle the banner (enable/suppress)
                              let g:netrw_banner= !g:netrw_banner
                            
                              " refresh the listing
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            
                              " keep cursor on the filename
                              let fname= s:NetrwGetWord()
                              sil NetrwKeepj $
                              let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
                            "  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'),'~'.expand("<slnum>"))
                              if result <= 0 && exists("w:netrw_bannercnt")
                               exe "NetrwKeepj ".w:netrw_bannercnt
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwBannerCtrl : g:netrw_banner=".g:netrw_banner)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookmark: supports :NetrwMB[!] [file]s                 {{{2
                            "
                            "  No bang: enters files/directories into Netrw's bookmark system
                            "   No argument and in netrw buffer:
                            "     if there are marked files: bookmark marked files
                            "     otherwise                : bookmark file/directory under cursor
                            "   No argument and not in netrw buffer: bookmarks current open file
                            "   Has arguments: globs them individually and bookmarks them
                            "
                            "  With bang: deletes files/directories from Netrw's bookmark system
    1              0.000002 fun! s:NetrwBookmark(del,...)
                            "  call Dfunc("s:NetrwBookmark(del=".a:del.",...) a:0=".a:0)
                              if a:0 == 0
                               if &ft == "netrw"
                                let curbufnr = bufnr("%")
                            
                                if exists("s:netrwmarkfilelist_{curbufnr}")
                                 " for every filename in the marked list
                            "     call Decho("bookmark every filename in marked list",'~'.expand("<slnum>"))
                                 let svpos  = winsaveview()
                            "     call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                 let islocal= expand("%") !~ '^\a\{3,}://'
                                 for fname in s:netrwmarkfilelist_{curbufnr}
                                  if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
                                 endfor
                                 let curdir  = exists("b:netrw_curdir")? b:netrw_curdir : getcwd()
                                 call s:NetrwUnmarkList(curbufnr,curdir)
                                 NetrwKeepj call s:NetrwRefresh(islocal,s:NetrwBrowseChgDir(islocal,'./'))
                            "     call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                 NetrwKeepj call winrestview(svpos)
                                else
                                 let fname= s:NetrwGetWord()
                                 if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
                                endif
                            
                               else
                                " bookmark currently open file
                            "    call Decho("bookmark currently open file",'~'.expand("<slnum>"))
                                let fname= expand("%")
                                if a:del|call s:DeleteBookmark(fname)|else|call s:MakeBookmark(fname)|endif
                               endif
                            
                              else
                               " bookmark specified files
                               "  attempts to infer if working remote or local
                               "  by deciding if the current file begins with an url
                               "  Globbing cannot be done remotely.
                               let islocal= expand("%") !~ '^\a\{3,}://'
                            "   call Decho("bookmark specified file".((a:0>1)? "s" : ""),'~'.expand("<slnum>"))
                               let i = 1
                               while i <= a:0
                                if islocal
                                 if v:version > 704 || (v:version == 704 && has("patch656"))
                                  let mbfiles= glob(fnameescape(a:{i}),0,1,1)
                                 else
                                  let mbfiles= glob(fnameescape(a:{i}),0,1)
                                 endif
                                else
                                 let mbfiles= [a:{i}]
                                endif
                            "    call Decho("mbfiles".string(mbfiles),'~'.expand("<slnum>"))
                                for mbfile in mbfiles
                            "     call Decho("mbfile<".mbfile.">",'~'.expand("<slnum>"))
                                 if a:del|call s:DeleteBookmark(mbfile)|else|call s:MakeBookmark(mbfile)|endif
                                endfor
                                let i= i + 1
                               endwhile
                              endif
                            
                              " update the menu
                              call s:NetrwBookmarkMenu()
                            
                            "  call Dret("s:NetrwBookmark")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookmarkMenu: Uses menu priorities {{{2
                            "                      .2.[cnt] for bookmarks, and
                            "                      .3.[cnt] for history
                            "                      (see s:NetrwMenu())
    1              0.000002 fun! s:NetrwBookmarkMenu()
                              if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " show bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd,'~'.expand("<slnum>"))
                                 let bmd= escape(bmd,g:netrw_menu_escape)
                            
                                 " show bookmarks for goto menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"
                            
                                 " show bookmarks for deletion menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
                                 let cnt= cnt + 1
                                endfor
                            
                               endif
                            
                               " show directory browsing history
                               if g:netrw_dirhistmax > 0
                                let cnt     = g:netrw_dirhist_cnt
                                let first   = 1
                                let histcnt = 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                                 let histcnt  = histcnt + 1
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{cnt}")
                                  let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir,'~'.expand("<slnum>"))
                                  exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
                                 endif
                                 let first = 0
                                 let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               endif
                            
                              endif
                            "  call Dret("NetrwBookmarkMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwBrowseChgDir: constructs a new directory based on the current {{{2
                            "                       directory and a new directory name.  Also, if the
                            "                       "new directory name" is actually a file,
                            "                       NetrwBrowseChgDir() edits the file.
    1              0.000003 fun! s:NetrwBrowseChgDir(islocal,newdir,...)
                            "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                              let ykeep= @@
                              if !exists("b:netrw_curdir")
                               " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
                               " and the current window is the NetrwMessage window.
                               let @@= ykeep
                            "   call Decho("b:netrw_curdir doesn't exist!",'~'.expand("<slnum>"))
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            "   call Dredir("ls!")
                            "   call Dret("s:NetrwBrowseChgDir")
                               return
                              endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " NetrwBrowseChgDir: save options and initialize {{{3
                            "  call Decho("saving options",'~'.expand("<slnum>"))
                              call s:SavePosn(s:netrw_nbcd)
                              NetrwKeepj call s:NetrwOptionSave("s:")
                              NetrwKeepj call s:NetrwSafeOptions()
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                               let dirname = substitute(b:netrw_curdir,'\\','/','ge')
                              else
                               let dirname = b:netrw_curdir
                              endif
                              let newdir    = a:newdir
                              let dolockout = 0
                              let dorestore = 1
                            "  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
                            
                              " ignore <cr>s when done in the banner
                            "  call Decho('ignore [return]s when done in banner (g:netrw_banner='.g:netrw_banner.")",'~'.expand("<slnum>"))
                              if g:netrw_banner
                            "   call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"),'~'.expand("<slnum>"))
                               if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
                                if getline(".") =~# 'Quick Help'
                            "     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
                            "     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 setl ma noro nowrap
                                 NetrwKeepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
                                 setl noma nomod nowrap
                                 call s:RestorePosn(s:netrw_nbcd)
                                 NetrwKeepj call s:NetrwOptionRestore("s:")
                            "     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
                               endif
                            "  else " Decho
                            "   call Decho("(s:NetrwBrowseChgdir) g:netrw_banner=".g:netrw_banner." (no banner)",'~'.expand("<slnum>"))
                              endif
                            
                              " set up o/s-dependent directory recognition pattern
                              if has("amiga")
                               let dirpat= '[\/:]$'
                              else
                               let dirpat= '[\/]$'
                              endif
                            "  call Decho("set up o/s-dependent directory recognition pattern: dirname<".dirname.">  dirpat<".dirpat.">",'~'.expand("<slnum>"))
                            
                              if dirname !~ dirpat
                               " apparently vim is "recognizing" that it is in a directory and
                               " is removing the trailing "/".  Bad idea, so let's put it back.
                               let dirname= dirname.'/'
                            "   call Decho("adjusting dirname<".dirname.'>  (put trailing "/" back)','~'.expand("<slnum>"))
                              endif
                            
                            "  call Decho("[newdir<".newdir."> ".((newdir =~ dirpat)? "=~" : "!~")." dirpat<".dirpat.">] && [islocal=".a:islocal."] && [newdir is ".(isdirectory(s:NetrwFile(newdir))? "" : "not ")."a directory]",'~'.expand("<slnum>"))
                              if newdir !~ dirpat && !(a:islocal && isdirectory(s:NetrwFile(s:ComposePath(dirname,newdir))))
                               " ------------------------------
                               " NetrwBrowseChgDir: edit a file {{{3
                               " ------------------------------
                            "   call Decho('edit-a-file: case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">",'~'.expand("<slnum>"))
                            
                               " save position for benefit of Rexplore
                               let s:rexposn_{bufnr("%")}= winsaveview()
                            "   call Decho("edit-a-file: saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">",'~'.expand("<slnum>"))
                            
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: newdir<".newdir.">",'~'.expand("<slnum>"))
                                let dirname= s:NetrwTreeDir(a:islocal)
                                if dirname =~ '/$'
                                 let dirname= dirname.newdir
                                else
                                 let dirname= dirname."/".newdir
                                endif
                            "    call Decho("edit-a-file: dirname<".dirname.">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: tree listing",'~'.expand("<slnum>"))
                               elseif newdir =~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle an url or path starting with /: <".newdir.">",'~'.expand("<slnum>"))
                                let dirname= newdir
                               else
                                let dirname= s:ComposePath(dirname,newdir)
                               endif
                            "   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")",'~'.expand("<slnum>"))
                               " this lets netrw#BrowseX avoid the edit
                               if a:0 < 1
                            "    call Decho("edit-a-file: (a:0=".a:0."<1) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"),'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwOptionRestore("s:")
                                let curdir= b:netrw_curdir
                                if !exists("s:didsplit")
                            "     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".string(g:netrw_browse_split)." win#".winnr(),'~'.expand("<slnum>"))
                                 if type(g:netrw_browse_split) == 3
                                  " open file in server
                                  " Note that g:netrw_browse_split is a List: [servername,tabnr,winnr]
                            "      call Decho("edit-a-file: open file in server",'~'.expand("<slnum>"))
                                  call s:NetrwServerEdit(a:islocal,dirname)
                            "      call Dret("s:NetrwBrowseChgDir")
                                  return
                                 elseif g:netrw_browse_split == 1
                                  " horizontally splitting the window first
                            "      call Decho("edit-a-file: horizontally splitting window prior to edit",'~'.expand("<slnum>"))
                                  keepalt new
                                  if !&ea
                                   keepalt wincmd _
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 2
                                  " vertically splitting the window first
                            "      call Decho("edit-a-file: vertically splitting window prior to edit",'~'.expand("<slnum>"))
                                  keepalt rightb vert new
                                  if !&ea
                                   keepalt wincmd |
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 3
                                  " open file in new tab
                            "      call Decho("edit-a-file: opening new tab prior to edit",'~'.expand("<slnum>"))
                                  keepalt tabnew
                                  if !exists("b:netrw_curdir")
                                   let b:netrw_curdir= getcwd()
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 4
                                  " act like "P" (ie. open previous window)
                            "      call Decho("edit-a-file: use previous window for edit",'~'.expand("<slnum>"))
                                  if s:NetrwPrevWinOpen(2) == 3
                                   let @@= ykeep
                            "       call Dret("s:NetrwBrowseChgDir")
                                   return
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 else
                                  " handling a file, didn't split, so remove menu
                            "      call Decho("edit-a-file: handling a file+didn't split, so remove menu",'~'.expand("<slnum>"))
                                  call s:NetrwMenu(0)
                                  " optional change to window
                                  if g:netrw_chgwin >= 1
                            "       call Decho("edit-a-file: changing window to #".g:netrw_chgwin,'~'.expand("<slnum>"))
                                   if winnr("$")+1 == g:netrw_chgwin
                            	" if g:netrw_chgwin is set to one more than the last window, then
                            	" vertically split the last window to make that window available.
                            	let curwin= winnr()
                            	exe "NetrwKeepj keepalt ".winnr("$")."wincmd w"
                            	vs
                            	exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd ".curwin
                                   endif
                                   exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd w"
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 endif
                                endif
                            
                                " the point where netrw actually edits the (local) file
                                " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
                                " no keepalt to support  :e #  to return to a directory listing
                                if a:islocal
                            "     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname),'~'.expand("<slnum>"))
                                 " some like c-^ to return to the last edited file
                                 " others like c-^ to return to the netrw buffer
                                 if exists("g:netrw_altfile") && g:netrw_altfile
                                  exe "NetrwKeepj keepalt e! ".fnameescape(dirname)
                                 else
                                  exe "NetrwKeepj e! ".fnameescape(dirname)
                                 endif
                            "     call Decho("edit-a-file: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod,'~'.expand("<slnum>"))
                                 call s:NetrwCursor()
                                 if &hidden || &bufhidden == "hide"
                                  " file came from vim's hidden storage.  Don't "restore" options with it.
                                  let dorestore= 0
                                 endif
                                else
                            "     call Decho("edit-a-file: remote file: NetrwBrowse will edit it",'~'.expand("<slnum>"))
                                endif
                                let dolockout= 1
                            
                                " handle g:Netrw_funcref -- call external-to-netrw functions
                                "   This code will handle g:Netrw_funcref as an individual function reference
                                "   or as a list of function references.  It will ignore anything that's not
                                "   a function reference.  See  :help Funcref  for information about function references.
                                if exists("g:Netrw_funcref")
                            "     call Decho("edit-a-file: handle optional Funcrefs",'~'.expand("<slnum>"))
                                 if type(g:Netrw_funcref) == 2
                            "      call Decho("edit-a-file: handling a g:Netrw_funcref",'~'.expand("<slnum>"))
                                  NetrwKeepj call g:Netrw_funcref()
                                 elseif type(g:Netrw_funcref) == 3
                            "      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs",'~'.expand("<slnum>"))
                                  for Fncref in g:Netrw_funcref
                                   if type(FncRef) == 2
                                    NetrwKeepj call FncRef()
                                   endif
                                  endfor
                                 endif
                                endif
                               endif
                            
                              elseif newdir =~ '^/'
                               " ----------------------------------------------------
                               " NetrwBrowseChgDir: just go to the new directory spec {{{3
                               " ----------------------------------------------------
                            "   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>','~'.expand("<slnum>"))
                               let dirname = newdir
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               NetrwKeepj call s:NetrwOptionRestore("s:")
                               norm! m`
                            
                              elseif newdir == './'
                               " ---------------------------------------------
                               " NetrwBrowseChgDir: refresh the directory list {{{3
                               " ---------------------------------------------
                            "   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"','~'.expand("<slnum>"))
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               norm! m`
                            
                              elseif newdir == '../'
                               " --------------------------------------
                               " NetrwBrowseChgDir: go up one directory {{{3
                               " --------------------------------------
                            "   call Decho('go-up: case "go up one directory": newdir == "../"','~'.expand("<slnum>"))
                            
                               if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                                " force a refresh
                            "    call Decho("go-up: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                            "    call Decho("go-up: setl noro ma",'~'.expand("<slnum>"))
                                setl noro ma
                                NetrwKeepj %d _
                               endif
                            
                               if has("amiga")
                                " amiga
                            "    call Decho('go-up: case "go up one directory": newdir == "../" and amiga','~'.expand("<slnum>"))
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
                                 let dirname= substitute(dirname,'/$','','')
                                else
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
                                endif
                            "    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                " windows
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                                if dirname =~ '^\a:$'
                                 let dirname= dirname.'/'
                                endif
                            "    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               else
                                " unix or cygwin
                            "    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin','~'.expand("<slnum>"))
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                            "    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               norm m`
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " --------------------------------------
                               " NetrwBrowseChgDir: Handle Tree Listing {{{3
                               " --------------------------------------
                            "   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists','~'.expand("<slnum>"))
                               " force a refresh (for TREELIST, NetrwTreeDir() will force the refresh)
                            "   call Decho("tree-list: setl noro ma",'~'.expand("<slnum>"))
                               setl noro ma
                               if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
                            "    call Decho("tree-list: clear buffer<".expand("%")."> with :%d  (force refresh)",'~'.expand("<slnum>"))
                                NetrwKeepj %d _
                               endif
                               let treedir      = s:NetrwTreeDir(a:islocal)
                            "   call Decho("tree-list: treedir<".treedir.">",'~'.expand("<slnum>"))
                               let s:treecurpos = winsaveview()
                               let haskey       = 0
                            "   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                            
                               " search treedict for tree dir as-is
                            "   call Decho("tree-list: search treedict for tree dir as-is",'~'.expand("<slnum>"))
                               if has_key(w:netrw_treedict,treedir)
                            "    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!','~'.expand("<slnum>"))
                                let haskey= 1
                               else
                            "    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                               endif
                            
                               " search treedict for treedir with a [/@] appended
                            "   call Decho("tree-list: search treedict for treedir with a [/@] appended",'~'.expand("<slnum>"))
                               if !haskey && treedir !~ '[/@]$'
                                if has_key(w:netrw_treedict,treedir."/")
                                 let treedir= treedir."/"
                            "     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                               " search treedict for treedir with any trailing / elided
                            "   call Decho("tree-list: search treedict for treedir with any trailing / elided",'~'.expand("<slnum>"))
                               if !haskey && treedir =~ '/$'
                                let treedir= substitute(treedir,'/$','','')
                                if has_key(w:netrw_treedict,treedir)
                            "     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                            "   call Decho("haskey=".haskey,'~'.expand("<slnum>"))
                               if haskey
                                " close tree listing for selected subdirectory
                            "    call Decho("tree-list: closing selected subdirectory<".dirname.">",'~'.expand("<slnum>"))
                                call remove(w:netrw_treedict,treedir)
                            "    call Decho("tree-list: removed     entry<".treedir."> from treedict",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                                let dirname= w:netrw_treetop
                               else
                                " go down one directory
                                let dirname= substitute(treedir,'/*$','/','')
                            "    call Decho("tree-list: go down one dir: treedir<".treedir.">",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: ...            : dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                            "   call Decho("setting s:treeforceredraw to true",'~'.expand("<slnum>"))
                               let s:treeforceredraw = 1
                            
                              else
                               " ----------------------------------------
                               " NetrwBrowseChgDir: Go down one directory {{{3
                               " ----------------------------------------
                               let dirname    = s:ComposePath(dirname,newdir)
                            "   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">",'~'.expand("<slnum>"))
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               norm m`
                              endif
                            
                             " --------------------------------------
                             " NetrwBrowseChgDir: Restore and Cleanup {{{3
                             " --------------------------------------
                              if dorestore
                               " dorestore is zero'd when a local file was hidden or bufhidden;
                               " in such a case, we want to keep whatever settings it may have.
                            "   call Decho("doing option restore (dorestore=".dorestore.")",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwOptionRestore("s:")
                            "  else " Decho
                            "   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod,'~'.expand("<slnum>"))
                              endif
                              call s:RestorePosn(s:netrw_nbcd)
                              if dolockout && dorestore
                            "   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname),'~'.expand("<slnum>"))
                               if filewritable(dirname)
                            "    call Decho("restore: doing modification lockout settings: ma nomod noro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma noro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               else
                            "    call Decho("restore: doing modification lockout settings: ma nomod ro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma ro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               endif
                              endif
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
                              return dirname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBrowseUpDir: implements the "-" mappings {{{2
                            "    for thin, long, and wide: cursor placed just after banner
                            "    for tree, keeps cursor on current filename
    1              0.000003 fun! s:NetrwBrowseUpDir(islocal)
                            "  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
                              if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt-1
                               " this test needed because occasionally this function seems to be incorrectly called
                               " when multiple leftmouse clicks are taken when atop the one line help in the banner.
                               " I'm allowing the very bottom line to permit a "-" exit so that one may escape empty
                               " directories.
                            "   call Dret("s:NetrwBrowseUpDir : cursor not in file area")
                               return
                              endif
                            
                              if !exists("w:netrw_liststyle") || w:netrw_liststyle != s:TREELIST
                               call s:SavePosn(s:netrw_nbcd)
                              endif
                            
                              norm! 0
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                            "   call Decho("case: treestyle",'~'.expand("<slnum>"))
                               let curline= getline(".")
                               let swwline= winline() - 1
                               if exists("w:netrw_treetop")
                                let b:netrw_curdir= w:netrw_treetop
                               endif
                               let curdir= b:netrw_curdir
                               if a:islocal
                                call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
                               else
                                call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
                               endif
                               if !search('\c^'.s:treedepthstring.curline,'cw')
                                if !search('\c^'.curline,'cw')
                                 sil! NetrwKeepj 1
                                endif
                               endif
                               exe "sil! NetrwKeepj norm! z\<cr>"
                               while winline() < swwline
                                let curwinline= winline()
                                exe "sil! NetrwKeepj norm! \<c-y>"
                                if curwinline == winline()
                                 break
                                endif
                               endwhile
                              else
                            "   call Decho("case: not treestyle",'~'.expand("<slnum>"))
                               if exists("b:netrw_curdir")
                                let curdir= b:netrw_curdir
                               else
                                let curdir= expand(getcwd())
                               endif
                               if a:islocal
                                call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
                               else
                                call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
                               endif
                               if has_key(s:netrw_nbcd,bufnr("%"))
                                call s:RestorePosn(s:netrw_nbcd)
                               elseif exists("w:netrw_bannercnt")
                            "    call Decho("moving to line#".w:netrw_bannercnt,'~'.expand("<slnum>"))
                                exe w:netrw_bannercnt
                               else
                                1
                               endif
                              endif
                              let curdir= substitute(curdir,'^.*[\/]','','')
                              call search('\<'.curdir.'\>','wc')
                            "  call Dret("s:NetrwBrowseUpDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#BrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
                            "              given filename; typically this means given their extension.
                            "              0=local, 1=remote
    1              0.000002 fun! netrw#BrowseX(fname,remote)
                            "  call Dfunc("netrw#BrowseX(fname<".a:fname."> remote=".a:remote.")")
                            
                              " if its really just a directory, then do a "gf" instead
                              if (a:remote == 0 && isdirectory(a:fname)) || (a:remote == 1 && fname =~ '/$' && fname !~ '^https\=:')
                               norm! gf
                            "   call Dret("netrw#BrowseX : did gf instead")
                              endif
                            
                            
                              let ykeep      = @@
                              let screenposn = winsaveview()
                            "  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
                            
                              " need to save and restore aw setting as gx can invoke this function from non-netrw buffers
                              let awkeep     = &aw
                              set noaw
                            
                              " special core dump handler
                              if a:fname =~ '/core\(\.\d\+\)\=$'
                               if exists("g:Netrw_corehandler")
                                if type(g:Netrw_corehandler) == 2
                                 " g:Netrw_corehandler is a function reference (see :help Funcref)
                            "     call Decho("g:Netrw_corehandler is a funcref",'~'.expand("<slnum>"))
                                 call g:Netrw_corehandler(s:NetrwFile(a:fname))
                                elseif type(g:Netrw_corehandler) == 3
                                 " g:Netrw_corehandler is a List of function references (see :help Funcref)
                            "     call Decho("g:Netrw_corehandler is a List",'~'.expand("<slnum>"))
                                 for Fncref in g:Netrw_corehandler
                                  if type(FncRef) == 2
                                   call FncRef(a:fname)
                                  endif
                                 endfor
                                endif
                            "    call Decho("restoring posn to screenposn<".string(screenposn).">,'~'.expand("<slnum>"))"
                                call winrestview(screenposn)
                                let @@= ykeep
                                let &aw= awkeep
                            "    call Dret("netrw#BrowseX : coredump handler invoked")
                                return
                               endif
                              endif
                            
                              " set up the filename
                              " (lower case the extension, make a local copy of a remote file)
                              let exten= substitute(a:fname,'.*\.\(.\{-}\)','\1','e')
                              if has("win32") || has("win95") || has("win64") || has("win16")
                               let exten= substitute(exten,'^.*$','\L&\E','')
                              endif
                            "  call Decho("exten<".exten.">",'~'.expand("<slnum>"))
                            
                              if a:remote == 1
                               " create a local copy
                            "   call Decho("remote: a:remote=".a:remote.": create a local copy of <".a:fname.">",'~'.expand("<slnum>"))
                               setl bh=delete
                               call netrw#NetRead(3,a:fname)
                               " attempt to rename tempfile
                               let basename= substitute(a:fname,'^\(.*\)/\(.*\)\.\([^.]*\)$','\2','')
                               let newname = substitute(s:netrw_tmpfile,'^\(.*\)/\(.*\)\.\([^.]*\)$','\1/'.basename.'.\3','')
                            "   call Decho("basename<".basename.">",'~'.expand("<slnum>"))
                            "   call Decho("newname <".newname.">",'~'.expand("<slnum>"))
                               if rename(s:netrw_tmpfile,newname) == 0
                                " renaming succeeded
                                let fname= newname
                               else
                                " renaming failed
                                let fname= s:netrw_tmpfile
                               endif
                              else
                            "   call Decho("local: a:remote=".a:remote.": handling local copy of <".a:fname.">",'~'.expand("<slnum>"))
                               let fname= a:fname
                               " special ~ handler for local
                               if fname =~ '^\~' && expand("$HOME") != ""
                            "    call Decho('invoking special ~ handler','~'.expand("<slnum>"))
                                let fname= s:NetrwFile(substitute(fname,'^\~',expand("$HOME"),''))
                               endif
                              endif
                            "  call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                            "  call Decho("exten<".exten."> "."netrwFileHandlers#NFH_".exten."():exists=".exists("*netrwFileHandlers#NFH_".exten),'~'.expand("<slnum>"))
                            
                              " set up redirection (avoids browser messages)
                              " by default, g:netrw_suppress_gx_mesg is true
                              if g:netrw_suppress_gx_mesg
                               if &srr =~ "%s"
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 let redir= substitute(&srr,"%s","nul","")
                                else
                                 let redir= substitute(&srr,"%s","/dev/null","")
                                endif
                               elseif (has("win32") || has("win95") || has("win64") || has("win16"))
                                let redir= &srr . "nul"
                               else
                                let redir= &srr . "/dev/null"
                               endif
                              endif
                            "  call Decho("set up redirection: redir{".redir."} srr{".&srr."}",'~'.expand("<slnum>"))
                            
                              " extract any viewing options.  Assumes that they're set apart by quotes.
                            "  call Decho("extract any viewing options",'~'.expand("<slnum>"))
                              if exists("g:netrw_browsex_viewer")
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
                               if g:netrw_browsex_viewer =~ '\s'
                                let viewer  = substitute(g:netrw_browsex_viewer,'\s.*$','','')
                                let viewopt = substitute(g:netrw_browsex_viewer,'^\S\+\s*','','')." "
                                let oviewer = ''
                                let cnt     = 1
                                while !executable(viewer) && viewer != oviewer
                                 let viewer  = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\1','')
                                 let viewopt = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\3','')." "
                                 let cnt     = cnt + 1
                                 let oviewer = viewer
                            "     call Decho("!exe: viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
                                endwhile
                               else
                                let viewer  = g:netrw_browsex_viewer
                                let viewopt = ""
                               endif
                            "   call Decho("viewer<".viewer.">  viewopt<".viewopt.">",'~'.expand("<slnum>"))
                              endif
                            
                              " execute the file handler
                            "  call Decho("execute the file handler (if any)",'~'.expand("<slnum>"))
                              if exists("g:netrw_browsex_viewer") && g:netrw_browsex_viewer == '-'
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                            
                              elseif exists("g:netrw_browsex_viewer") && executable(viewer)
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">",'~'.expand("<slnum>"))
                               call s:NetrwExe("sil !".viewer." ".viewopt.s:ShellEscape(fname,1).redir)
                               let ret= v:shell_error
                            
                              elseif has("win32") || has("win64")
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               if executable("start")
                                call s:NetrwExe('sil! !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
                               elseif executable("rundll32")
                                call s:NetrwExe('sil! !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(fname,1))
                               else
                                call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
                               endif
                               call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               let ret= v:shell_error
                            
                              elseif has("win32unix")
                               let winfname= 'c:\cygwin'.substitute(fname,'/','\\','g')
                            "   call Decho("cygwin: winfname<".s:ShellEscape(winfname,1).">",'~'.expand("<slnum>"))
                               if executable("start")
                                call s:NetrwExe('sil !start rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
                               elseif executable("rundll32")
                                call s:NetrwExe('sil !rundll32 url.dll,FileProtocolHandler '.s:ShellEscape(winfname,1))
                               elseif executable("cygstart")
                                call s:NetrwExe('sil !cygstart '.s:ShellEscape(fname,1))
                               else
                                call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
                               endif
                               call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               let ret= v:shell_error
                            
                              elseif has("unix") && executable("kfmclient") && s:CheckIfKde()
                            "   call Decho("unix and kfmclient",'~'.expand("<slnum>"))
                               call s:NetrwExe("sil !kfmclient exec ".s:ShellEscape(fname,1)." ".redir)
                               let ret= v:shell_error
                            
                              elseif has("unix") && executable("exo-open") && executable("xdg-open") && executable("setsid")
                            "   call Decho("unix, exo-open, xdg-open",'~'.expand("<slnum>"))
                               call s:NetrwExe("sil !setsid xdg-open ".s:ShellEscape(fname,1).redir)
                               let ret= v:shell_error
                            
                              elseif has("unix") && executable("xdg-open")
                            "   call Decho("unix and xdg-open",'~'.expand("<slnum>"))
                               call s:NetrwExe("sil !xdg-open ".s:ShellEscape(fname,1).redir)
                               let ret= v:shell_error
                            
                              elseif has("macunix") && executable("open")
                            "   call Decho("macunix and open",'~'.expand("<slnum>"))
                               call s:NetrwExe("sil !open ".s:ShellEscape(fname,1)." ".redir)
                               let ret= v:shell_error
                            
                              else
                               " netrwFileHandlers#Invoke() always returns 0
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                              endif
                            
                              " if unsuccessful, attempt netrwFileHandlers#Invoke()
                              if ret
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                              endif
                            
                              " restoring redraw! after external file handlers
                              redraw!
                            
                              " cleanup: remove temporary file,
                              "          delete current buffer if success with handler,
                              "          return to prior buffer (directory listing)
                              "          Feb 12, 2008: had to de-activiate removal of
                              "          temporary file because it wasn't getting seen.
                            "  if a:remote == 1 && fname != a:fname
                            ""   call Decho("deleting temporary file<".fname.">",'~'.expand("<slnum>"))
                            "   call s:NetrwDelete(fname)
                            "  endif
                            
                              if a:remote == 1
                               setl bh=delete bt=nofile
                               if g:netrw_use_noswf
                                setl noswf
                               endif
                               exe "sil! NetrwKeepj norm! \<c-o>"
                            "   redraw!
                              endif
                            "  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
                              call winrestview(screenposn)
                              let @@ = ykeep
                              let &aw= awkeep
                            
                            "  call Dret("netrw#BrowseX")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#BrowseXVis: used by gx in visual mode to select a file for browsing {{{2
    1              0.000001 fun! netrw#BrowseXVis()
                            "  call Dfunc("netrw#BrowseXVis()")
                              let atkeep = @@
                              norm! gvy
                            "  call Decho("@@<".@@.">",'~'.expand("<slnum>"))
                              call netrw#BrowseX(@@,netrw#CheckIfRemote())
                              let @@     = atkeep
                            "  call Dret("netrw#BrowseXVis")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#CheckIfRemote: returns 1 if current file looks like an url, 0 else {{{2
    1              0.000002 fun! netrw#CheckIfRemote()
                            "  call Dfunc("netrw#CheckIfRemote()")
                              if expand("%") =~ '^\a\{3,}://'
                            "   call Dret("netrw#CheckIfRemote 1")
                               return 1
                              else
                            "   call Dret("netrw#CheckIfRemote 0")
                               return 0
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwChgPerm: (implements "gp") change file permission {{{2
    1              0.000002 fun! s:NetrwChgPerm(islocal,curdir)
                            "  call Dfunc("s:NetrwChgPerm(islocal=".a:islocal." curdir<".a:curdir.">)")
                              let ykeep  = @@
                              call inputsave()
                              let newperm= input("Enter new permission: ")
                              call inputrestore()
                              let chgperm= substitute(g:netrw_chgperm,'\<FILENAME\>',s:ShellEscape(expand("<cfile>")),'')
                              let chgperm= substitute(chgperm,'\<PERM\>',s:ShellEscape(newperm),'')
                            "  call Decho("chgperm<".chgperm.">",'~'.expand("<slnum>"))
                              call system(chgperm)
                              if v:shell_error != 0
                               NetrwKeepj call netrw#ErrorMsg(1,"changing permission on file<".expand("<cfile>")."> seems to have failed",75)
                              endif
                              if a:islocal
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwChgPerm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:CheckIfKde: checks if kdeinit is running {{{2
                            "    Returns 0: kdeinit not running
                            "            1: kdeinit is  running
    1              0.000002 fun! s:CheckIfKde()
                            "  call Dfunc("s:CheckIfKde()")
                              " seems kde systems often have gnome-open due to dependencies, even though
                              " gnome-open's subsidiary display tools are largely absent.  Kde systems
                              " usually have "kdeinit" running, though...  (tnx Mikolaj Machowski)
                              if !exists("s:haskdeinit")
                               if has("unix") && executable("ps") && !has("win32unix")
                                let s:haskdeinit= system("ps -e") =~ '\<kdeinit'
                                if v:shell_error
                                 let s:haskdeinit = 0
                                endif
                               else
                                let s:haskdeinit= 0
                               endif
                            "   call Decho("setting s:haskdeinit=".s:haskdeinit,'~'.expand("<slnum>"))
                              endif
                            
                            "  call Dret("s:CheckIfKde ".s:haskdeinit)
                              return s:haskdeinit
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwClearExplore: clear explore variables (if any) {{{2
    1              0.000002 fun! s:NetrwClearExplore()
                            "  call Dfunc("s:NetrwClearExplore()")
                              2match none
                              if exists("s:explore_match")        |unlet s:explore_match        |endif
                              if exists("s:explore_indx")         |unlet s:explore_indx         |endif
                              if exists("s:netrw_explore_prvdir") |unlet s:netrw_explore_prvdir |endif
                              if exists("s:dirstarstar")          |unlet s:dirstarstar          |endif
                              if exists("s:explore_prvdir")       |unlet s:explore_prvdir       |endif
                              if exists("w:netrw_explore_indx")   |unlet w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_listlen")|unlet w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_list")   |unlet w:netrw_explore_list   |endif
                              if exists("w:netrw_explore_bufnr")  |unlet w:netrw_explore_bufnr  |endif
                            "   redraw!
                              echo " "
                              echo " "
                            "  call Dret("s:NetrwClearExplore")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwExploreListUniq: {{{2
    1              0.000002 fun! s:NetrwExploreListUniq(explist)
                            "  call Dfunc("s:NetrwExploreListUniq(explist<".string(a:explist).">)")
                            
                              " this assumes that the list is already sorted
                              let newexplist= []
                              for member in a:explist
                               if !exists("uniqmember") || member != uniqmember
                                let uniqmember = member
                                let newexplist = newexplist + [ member ]
                               endif
                              endfor
                            
                            "  call Dret("s:NetrwExploreListUniq newexplist<".string(newexplist).">")
                              return newexplist
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwForceChgDir: (gd support) Force treatment as a directory {{{2
    1              0.000002 fun! s:NetrwForceChgDir(islocal,newdir)
                            "  call Dfunc("s:NetrwForceChgDir(islocal=".a:islocal." newdir<".a:newdir.">)")
                              let ykeep= @@
                              if a:newdir !~ '/$'
                               " ok, looks like force is needed to get directory-style treatment
                               if a:newdir =~ '@$'
                                let newdir= substitute(a:newdir,'@$','/','')
                               elseif a:newdir =~ '[*=|\\]$'
                                let newdir= substitute(a:newdir,'.$','/','')
                               else
                                let newdir= a:newdir.'/'
                               endif
                            "   call Decho("adjusting newdir<".newdir."> due to gd",'~'.expand("<slnum>"))
                              else
                               " should already be getting treatment as a directory
                               let newdir= a:newdir
                              endif
                              let newdir= s:NetrwBrowseChgDir(a:islocal,newdir)
                              call s:NetrwBrowse(a:islocal,newdir)
                              let @@= ykeep
                            "  call Dret("s:NetrwForceChgDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGlob: does glob() if local, remote listing otherwise {{{2
                            "     direntry: this is the name of the directory.  Will be fnameescape'd to prevent wildcard handling by glob()
                            "     expr    : this is the expression to follow the directory.  Will use s:ComposePath()
                            "     pare    =1: remove the current directory from the resulting glob() filelist
                            "             =0: leave  the current directory   in the resulting glob() filelist
    1              0.000002 fun! s:NetrwGlob(direntry,expr,pare)
                            "  call Dfunc("s:NetrwGlob(direntry<".a:direntry."> expr<".a:expr."> pare=".a:pare.")")
                              if netrw#CheckIfRemote()
                               keepalt 1sp
                               keepalt enew
                               let keep_liststyle    = w:netrw_liststyle
                               let w:netrw_liststyle = s:THINLIST
                               if s:NetrwRemoteListing() == 0
                                keepj keepalt %s@/@@
                                let filelist= getline(1,$)
                                q!
                               else
                                " remote listing error -- leave treedict unchanged
                                let filelist= w:netrw_treedict[a:direntry]
                               endif
                               let w:netrw_liststyle= keep_liststyle
                              elseif v:version > 704 || (v:version == 704 && has("patch656"))
                               let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1,1)
                               if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
                               endif
                              else
                               let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1)
                               if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
                               endif
                              endif
                            "  call Dret("s:NetrwGlob ".string(filelist))
                              return filelist
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwForceFile: (gf support) Force treatment as a file {{{2
    1              0.000001 fun! s:NetrwForceFile(islocal,newfile)
                            "  call Dfunc("s:NetrwForceFile(islocal=".a:islocal." newdir<".a:newfile.">)")
                              if a:newfile =~ '[/@*=|\\]$'
                               let newfile= substitute(a:newfile,'.$','','')
                              else
                               let newfile= a:newfile
                              endif
                              if a:islocal
                               call s:NetrwBrowseChgDir(a:islocal,newfile)
                              else
                               call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,newfile))
                              endif
                            "  call Dret("s:NetrwForceFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHide: this function is invoked by the "a" map for browsing {{{2
                            "          and switches the hiding mode.  The actual hiding is done by
                            "          s:NetrwListHide().
                            "             g:netrw_hide= 0: show all
                            "                           1: show not-hidden files
                            "                           2: show hidden files only
    1              0.000001 fun! s:NetrwHide(islocal)
                            "  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
                              let ykeep= @@
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
                            
                               " hide the files in the markfile list
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("match(g:netrw_list_hide<".g:netrw_list_hide.'> fname<\<'.fname.'\>>)='.match(g:netrw_list_hide,'\<'.fname.'\>')." l:isk=".&l:isk,'~'.expand("<slnum>"))
                                if match(g:netrw_list_hide,'\<'.fname.'\>') != -1
                                 " remove fname from hiding list
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,'..\<'.escape(fname,g:netrw_fname_escape).'\>..','','')
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,',,',',','g')
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,'^,\|,$','','')
                            "     call Decho("unhide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
                                else
                                 " append fname to hiding list
                                 if exists("g:netrw_list_hide") && g:netrw_list_hide != ""
                                  let g:netrw_list_hide= g:netrw_list_hide.',\<'.escape(fname,g:netrw_fname_escape).'\>'
                                 else
                                  let g:netrw_list_hide= '\<'.escape(fname,g:netrw_fname_escape).'\>'
                                 endif
                            "     call Decho("hide: g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
                                endif
                               endfor
                               NetrwKeepj call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                               let g:netrw_hide= 1
                            
                              else
                            
                               " switch between show-all/show-not-hidden/show-hidden
                               let g:netrw_hide=(g:netrw_hide+1)%3
                               exe "NetrwKeepj norm! 0"
                               if g:netrw_hide && g:netrw_list_hide == ""
                                NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your hiding list is empty!",49)
                                let @@= ykeep
                            "    call Dret("NetrwHide")
                                return
                               endif
                              endif
                            
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                              let @@= ykeep
                            "  call Dret("NetrwHide")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHideEdit: allows user to edit the file/directory hiding list {{{2
    1              0.000001 fun! s:NetrwHideEdit(islocal)
                            "  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " save current cursor position
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              " get new hiding list from user
                              call inputsave()
                              let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
                              call inputrestore()
                              let g:netrw_list_hide= newhide
                            "  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
                            
                              " refresh the listing
                              sil NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))
                            
                              " restore cursor position
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call winrestview(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetrwHideEdit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHidden: invoked by "gh" {{{2
    1              0.000002 fun! s:NetrwHidden(islocal)
                            "  call Dfunc("s:NetrwHidden()")
                              let ykeep= @@
                              "  save current position
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
                               " remove pattern from hiding list
                               let g:netrw_list_hide= substitute(g:netrw_list_hide,'\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+','','')
                              elseif s:Strlen(g:netrw_list_hide) >= 1
                               let g:netrw_list_hide= g:netrw_list_hide . ',\(^\|\s\s\)\zs\.\S\+'
                              else
                               let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
                              endif
                            
                              " refresh screen and return to saved position
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                              let @@= ykeep
                            "  call Dret("s:NetrwHidden")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwHome: this function determines a "home" for saving bookmarks and history {{{2
    1              0.000001 fun! s:NetrwHome()
                              if exists("g:netrw_home")
                               let home= g:netrw_home
                              else
                               " go to vim plugin home
                               for home in split(&rtp,',') + ['']
                                if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                 if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
                               if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
                               if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
                              endif
                              " insure that the home directory exists
                              if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
                               if exists("g:netrw_mkdir")
                                call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
                               else
                                call mkdir(home)
                               endif
                              endif
                              let g:netrw_home= home
                              return home
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
    1              0.000002 fun! s:NetrwLeftmouse(islocal)
                              if exists("s:netrwdrag")
                               return
                              endif
                            "  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " check if the status bar was clicked on instead of a file/directory name
                              while getchar(0) != 0
                               "clear the input stream
                              endwhile
                              call feedkeys("\<LeftMouse>")
                              let c          = getchar()
                              let mouse_lnum = v:mouse_lnum
                              let wlastline  = line('w$')
                              let lastline   = line('$')
                            "  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr(),'~'.expand("<slnum>"))
                            "  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0),'~'.expand("<slnum>"))
                              if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
                               " appears to be a status bar leftmouse click
                               let @@= ykeep
                            "   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
                               return
                              endif
                               " Dec 04, 2013: following test prevents leftmouse selection/deselection of directories and files in treelist mode
                               " Windows are separated by vertical separator bars - but the mouse seems to be doing what it should when dragging that bar
                               " without this test when its disabled.
                               " May 26, 2014: edit file, :Lex, resize window -- causes refresh.  Reinstated a modified test.  See if problems develop.
                            "   call Decho("v:mouse_col=".v:mouse_col." col#".col('.')." virtcol#".virtcol('.')." col($)#".col("$")." virtcol($)#".virtcol("$"),'~'.expand("<slnum>"))
                               if v:mouse_col > virtcol('.')
                                let @@= ykeep
                            "    call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
                                return
                               endif
                            
                              if a:islocal
                               if exists("b:netrw_curdir")
                                NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               endif
                              else
                               if exists("b:netrw_curdir")
                                NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwLeftmouse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwCLeftmouse: used to select a file/directory for a target {{{2
    1              0.000002 fun! s:NetrwCLeftmouse(islocal)
                            "  call Dfunc("s:NetrwCLeftmouse(islocal=".a:islocal.")")
                              call s:NetrwMarkFileTgt(a:islocal)
                            "  call Dret("s:NetrwCLeftmouse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwServerEdit: edit file in a server gvim, usually NETRWSERVER  (implements <c-r>){{{2
                            "   a:islocal=0 : <c-r> not used, remote
                            "   a:islocal=1 : <c-r> no  used, local
                            "   a:islocal=2 : <c-r>     used, remote
                            "   a:islocal=3 : <c-r>     used, local
    1              0.000002 fun! s:NetrwServerEdit(islocal,fname)
                            "  call Dfunc("s:NetrwServerEdit(islocal=".a:islocal.",fname<".a:fname.">)")
                              let islocal = a:islocal%2      " =0: remote           =1: local
                              let ctrlr   = a:islocal >= 2   " =0: <c-r> not used   =1: <c-r> used
                            "  call Decho("islocal=".islocal." ctrlr=".ctrlr,'~'.expand("<slnum>"))
                            
                              if (islocal && isdirectory(s:NetrwFile(a:fname))) || (!islocal && a:fname =~ '/$')
                               " handle directories in the local window -- not in the remote vim server
                               " user must have closed the NETRWSERVER window.  Treat as normal editing from netrw.
                            "   call Decho("handling directory in client window",'~'.expand("<slnum>"))
                               let g:netrw_browse_split= 0
                               if exists("s:netrw_browse_split") && exists("s:netrw_browse_split_".winnr())
                                let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
                                unlet s:netrw_browse_split_{winnr()}
                               endif
                               call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
                            "   call Dret("s:NetrwServerEdit")
                               return
                              endif
                            
                            "  call Decho("handling file in server window",'~'.expand("<slnum>"))
                              if has("clientserver") && executable("gvim")
                            "   call Decho("has clientserver and gvim",'~'.expand("<slnum>"))
                            
                                if exists("g:netrw_browse_split") && type(g:netrw_browse_split) == 3
                            "     call Decho("g:netrw_browse_split=".string(g:netrw_browse_split),'~'.expand("<slnum>"))
                                 let srvrname = g:netrw_browse_split[0]
                                 let tabnum   = g:netrw_browse_split[1]
                                 let winnum   = g:netrw_browse_split[2]
                            
                                 if serverlist() !~ '\<'.srvrname.'\>'
                            "      call Decho("server not available; ctrlr=".ctrlr,'~'.expand("<slnum>"))
                            
                                  if !ctrlr
                                   " user must have closed the server window and the user did not use <c-r>, but
                                   " used something like <cr>.
                            "       call Decho("user must have closed server AND did not use ctrl-r",'~'.expand("<slnum>"))
                                   if exists("g:netrw_browse_split")
                            	unlet g:netrw_browse_split
                                   endif
                                   let g:netrw_browse_split= 0
                                   if exists("s:netrw_browse_split_".winnr())
                                    let g:netrw_browse_split= s:netrw_browse_split_{winnr()}
                                   endif
                                   call s:NetrwBrowseChgDir(islocal,a:fname)
                            "       call Dret("s:NetrwServerEdit")
                                   return
                            
                                  elseif has("win32") && executable("start")
                                   " start up remote netrw server under windows
                            "       call Decho("starting up gvim server<".srvrname."> for windows",'~'.expand("<slnum>"))
                                   call system("start gvim --servername ".srvrname)
                            
                                  else
                                   " start up remote netrw server under linux
                            "       call Decho("starting up gvim server<".srvrname.">",'~'.expand("<slnum>"))
                                   call system("gvim --servername ".srvrname)
                                  endif
                                 endif
                            
                            "     call Decho("srvrname<".srvrname."> tabnum=".tabnum." winnum=".winnum." server-editing<".a:fname.">",'~'.expand("<slnum>"))
                                 call remote_send(srvrname,":tabn ".tabnum."\<cr>")
                                 call remote_send(srvrname,":".winnum."wincmd w\<cr>")
                                 call remote_send(srvrname,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")
                            
                                else
                            
                                 if serverlist() !~ '\<'.g:netrw_servername.'\>'
                            
                                  if !ctrlr
                            "       call Decho("server<".g:netrw_servername."> not available and ctrl-r not used",'~'.expand("<slnum>"))
                                   if exists("g:netrw_browse_split")
                            	unlet g:netrw_browse_split
                                   endif
                                   let g:netrw_browse_split= 0
                                   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,a:fname))
                            "       call Dret("s:NetrwServerEdit")
                                   return
                            
                                  else
                            "       call Decho("server<".g:netrw_servername."> not available but ctrl-r used",'~'.expand("<slnum>"))
                                   if has("win32") && executable("start")
                                    " start up remote netrw server under windows
                            "        call Decho("starting up gvim server<".g:netrw_servername."> for windows",'~'.expand("<slnum>"))
                                    call system("start gvim --servername ".g:netrw_servername)
                                   else
                                    " start up remote netrw server under linux
                            "        call Decho("starting up gvim server<".g:netrw_servername.">",'~'.expand("<slnum>"))
                                    call system("gvim --servername ".g:netrw_servername)
                                   endif
                                  endif
                                 endif
                            
                                 while 1
                                  try
                            "       call Decho("remote-send: e ".a:fname,'~'.expand("<slnum>"))
                                   call remote_send(g:netrw_servername,":e ".fnameescape(s:NetrwFile(a:fname))."\<cr>")
                                   break
                                  catch /^Vim\%((\a\+)\)\=:E241/
                                   sleep 200m
                                  endtry
                                 endwhile
                            
                                 if exists("g:netrw_browse_split")
                                  if type(g:netrw_browse_split) != 3
                                    let s:netrw_browse_split_{winnr()}= g:netrw_browse_split
                                   endif
                                  unlet g:netrw_browse_split
                                 endif
                                 let g:netrw_browse_split= [g:netrw_servername,1,1]
                                endif
                            
                               else
                                call netrw#ErrorMsg(s:ERROR,"you need a gui-capable vim and client-server to use <ctrl-r>",98)
                               endif
                            
                            "  call Dret("s:NetrwServerEdit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSLeftmouse: marks the file under the cursor.  May be dragged to select additional files {{{2
    1              0.000002 fun! s:NetrwSLeftmouse(islocal)
                            "  call Dfunc("s:NetrwSLeftmouse(islocal=".a:islocal.")")
                            
                              let s:ngw= s:NetrwGetWord()
                              call s:NetrwMarkFile(a:islocal,s:ngw)
                            
                            "  call Dret("s:NetrwSLeftmouse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSLeftdrag: invoked via a shift-leftmouse and dragging {{{2
                            "                   Used to mark multiple files.
    1              0.000002 fun! s:NetrwSLeftdrag(islocal)
                            "  call Dfunc("s:NetrwSLeftdrag(islocal=".a:islocal.")")
                              if !exists("s:netrwdrag")
                               let s:netrwdrag = winnr()
                               if a:islocal
                                nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(1)<cr>
                               else
                                nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(0)<cr>
                               endif
                              endif
                              let ngw = s:NetrwGetWord()
                              if !exists("s:ngw") || s:ngw != ngw
                               call s:NetrwMarkFile(a:islocal,ngw)
                              endif
                              let s:ngw= ngw
                            "  call Dret("s:NetrwSLeftdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSLeftrelease: terminates shift-leftmouse dragging {{{2
    1              0.000001 fun! s:NetrwSLeftrelease(islocal)
                            "  call Dfunc("s:NetrwSLeftrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
                              if exists("s:netrwdrag")
                               nunmap <s-leftrelease>
                               let ngw = s:NetrwGetWord()
                               if !exists("s:ngw") || s:ngw != ngw
                                call s:NetrwMarkFile(a:islocal,ngw)
                               endif
                               if exists("s:ngw")
                                unlet s:ngw
                               endif
                               unlet s:netrwdrag
                              endif
                            "  call Dret("s:NetrwSLeftrelease")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
                            " separated patterns given in g:netrw_list_hide
    1              0.000001 fun! s:NetrwListHide()
                            "  call Dfunc("s:NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
                              let ykeep= @@
                            
                              " find a character not in the "hide" string to use as a separator for :g and :v commands
                              " How-it-works: take the hiding command, convert it into a range.  Duplicate
                              " characters don't matter.  Remove all such characters from the '/~...90'
                              " string.  Use the first character left as a separator character.
                              let listhide= g:netrw_list_hide
                              let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
                            "  call Decho("sep=".sep,'~'.expand("<slnum>"))
                            
                              while listhide != ""
                               if listhide =~ ','
                                let hide     = substitute(listhide,',.*$','','e')
                                let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
                               else
                                let hide     = listhide
                                let listhide = ""
                               endif
                            
                               " Prune the list by hiding any files which match
                               if g:netrw_hide == 1
                            "    call Decho("hiding<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
                               elseif g:netrw_hide == 2
                            "    call Decho("showing<".hide."> listhide<".listhide.">",'~'.expand("<slnum>"))
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
                               endif
                              endwhile
                              if g:netrw_hide == 2
                               exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
                               exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
                              endif
                            
                              " remove any blank lines that have somehow remained.
                              " This seems to happen under Windows.
                              exe 'sil! NetrwKeepj 1,$g@^\s*$@d'
                            
                              let @@= ykeep
                            "  call Dret("s:NetrwListHide")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
                            "                 implements the "d" mapping.
    1              0.000002 fun! s:NetrwMakeDir(usrhost)
                            "  call Dfunc("s:NetrwMakeDir(usrhost<".a:usrhost.">)")
                            
                              let ykeep= @@
                              " get name of new directory from user.  A bare <CR> will skip.
                              " if its currently a directory, also request will be skipped, but with
                              " a message.
                              call inputsave()
                              let newdirname= input("Please give directory name: ")
                              call inputrestore()
                            "  call Decho("newdirname<".newdirname.">",'~'.expand("<slnum>"))
                            
                              if newdirname == ""
                               let @@= ykeep
                            "   call Dret("s:NetrwMakeDir : user aborted with bare <cr>")
                               return
                              endif
                            
                              if a:usrhost == ""
                            "   call Decho("local mkdir",'~'.expand("<slnum>"))
                            
                               " Local mkdir:
                               " sanity checks
                               let fullnewdir= b:netrw_curdir.'/'.newdirname
                            "   call Decho("fullnewdir<".fullnewdir.">",'~'.expand("<slnum>"))
                               if isdirectory(s:NetrwFile(fullnewdir))
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
                                endif
                                let @@= ykeep
                            "    call Dret("s:NetrwMakeDir : directory<".newdirname."> exists previously")
                                return
                               endif
                               if s:FileReadable(fullnewdir)
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
                                endif
                                let @@= ykeep
                            "    call Dret("s:NetrwMakeDir : file<".newdirname."> exists previously")
                                return
                               endif
                            
                               " requested new local directory is neither a pre-existing file or
                               " directory, so make it!
                               if exists("*mkdir")
                                if has("unix")
                                 call mkdir(fullnewdir,"p",xor(0777, system("umask")))
                                else
                                 call mkdir(fullnewdir,"p")
                                endif
                               else
                                let netrw_origdir= s:NetrwGetcwd(1)
                                call s:NetrwLcd(b:netrw_curdir)
                            "    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">",'~'.expand("<slnum>"))
                                call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
                                if v:shell_error != 0
                                 let @@= ykeep
                                 call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
                            "     call Dret("s:NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(newdirname,1))
                                 return
                                endif
                                if !g:netrw_keepdir
                            "     call Decho("restoring netrw_origdir since g:netrw_keepdir=".g:netrw_keepdir,'~'.expand("<slnum>"))
                                 call s:NetrwLcd(netrw_origdir)
                                endif
                               endif
                            
                               if v:shell_error == 0
                                " refresh listing
                            "    call Decho("refresh listing",'~'.expand("<slnum>"))
                                let svpos= winsaveview()
                            "    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                            "    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                call winrestview(svpos)
                               elseif !exists("g:netrw_quiet")
                                call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
                               endif
                            "   redraw!
                            
                              elseif !exists("b:netrw_method") || b:netrw_method == 4
                               " Remote mkdir:  using ssh
                            "   call Decho("remote mkdir",'~'.expand("<slnum>"))
                               let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
                               let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
                               call s:NetrwExe("sil! !".mkdircmd." ".s:ShellEscape(newdirname,1))
                               if v:shell_error == 0
                                " refresh listing
                                let svpos= winsaveview()
                            "    call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                            "    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                NetrwKeepj call winrestview(svpos)
                               elseif !exists("g:netrw_quiet")
                                NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
                               endif
                            "   redraw!
                            
                              elseif b:netrw_method == 2
                               " Remote mkdir:  using ftp+.netrc
                               let svpos= winsaveview()
                            "   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                               if exists("b:netrw_fname")
                            "    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
                                let remotepath= b:netrw_fname
                               else
                                let remotepath= ""
                               endif
                               call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
                               NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                            
                              elseif b:netrw_method == 3
                               " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
                               let svpos= winsaveview()
                            "   call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                               if exists("b:netrw_fname")
                            "    call Decho("b:netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
                                let remotepath= b:netrw_fname
                               else
                                let remotepath= ""
                               endif
                               call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
                               NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              endif
                            
                              let @@= ykeep
                            "  call Dret("s:NetrwMakeDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
    1              0.000002 fun! s:TreeSqueezeDir(islocal)
                            "  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " its a tree-listing style
                               let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
                               let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
                               let depth    = strchars(substitute(curdepth,' ','','g'))
                               let srch     = -1
                            "   call Decho("curdepth<".curdepth.'>','~'.expand("<slnum>"))
                            "   call Decho("depth   =".depth,'~'.expand("<slnum>"))
                            "   call Decho("stopline#".stopline,'~'.expand("<slnum>"))
                            "   call Decho("curline#".line(".")."<".getline('.').'>','~'.expand("<slnum>"))
                               if depth >= 2
                                NetrwKeepj norm! 0
                                let curdepthm1= substitute(curdepth,'^'.s:treedepthstring,'','')
                                let srch      = search('^'.curdepthm1.'\%('.s:treedepthstring.'\)\@!','bW',stopline)
                            "    call Decho("curdepthm1<".curdepthm1.'>','~'.expand("<slnum>"))
                            "    call Decho("case depth>=2: srch<".srch.'>','~'.expand("<slnum>"))
                               elseif depth == 1
                                NetrwKeepj norm! 0
                                let treedepthchr= substitute(s:treedepthstring,' ','','')
                                let srch        = search('^[^'.treedepthchr.']','bW',stopline)
                            "    call Decho("case depth==1: srch<".srch.'>','~'.expand("<slnum>"))
                               endif
                               if srch > 0
                            "    call Decho("squeezing at line#".line(".").": ".getline('.'),'~'.expand("<slnum>"))
                                call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
                                exe srch
                               endif
                              endif
                            "  call Dret("s:TreeSqueezeDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMaps: {{{2
    1              0.000002 fun! s:NetrwMaps(islocal)
                            "  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                            
                              if g:netrw_mousemaps && g:netrw_retmap
                            "   call Decho("set up Rexplore 2-leftmouse",'~'.expand("<slnum>"))
                               if !hasmapto("<Plug>NetrwReturn")
                                if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
                            "     call Decho("making map for 2-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
                                elseif maparg("<c-leftmouse>","n") == ""
                            "     call Decho("making map for c-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
                                endif
                               endif
                               nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
                            "   call Decho("made <Plug>NetrwReturn map",'~'.expand("<slnum>"))
                              endif
                            
                              if a:islocal
                            "   call Decho("make local maps",'~'.expand("<slnum>"))
                               " local normal-mode maps
                               nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(1)<cr>
                               nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(1)<cr>
                               nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(1)<cr>
                               nnoremap <buffer> <silent> <nowait> c	:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
                               nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(3,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> d	:<c-u>call <SID>NetrwMakeDir("")<cr>
                               nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
                               nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(1)<cr>
                               nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(1,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(1,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
                               nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
                               nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
                               nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                               nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
                               nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(1)<cr>
                               nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(3)<cr>
                               nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(1)<cr>
                               nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
                               nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
                               nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(1)<cr>
                               nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(1)<cr>
                               nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
                               nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(4)<cr>
                               nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
                               nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
                               nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
                               nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(5)<cr>
                               nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
                               nnoremap <buffer> <silent> <nowait> X	:<c-u>call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
                            "   " local insert-mode maps
                            "   inoremap <buffer> <silent> <nowait> a	<c-o>:call <SID>NetrwHide(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> c	<c-o>:exe "NetrwKeepj lcd ".fnameescape(b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> c	<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> C	<c-o>:call <SID>NetrwSetChgwin()<cr>
                            "   inoremap <buffer> <silent> <nowait> %	<c-o>:call <SID>NetrwOpenFile(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> -	<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
                            "   inoremap <buffer> <silent> <nowait> d	<c-o>:call <SID>NetrwMakeDir("")<cr>
                            "   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
                            "   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> I	<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> i	<c-o>:call <SID>NetrwListStyle(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> O	<c-o>:call <SID>NetrwObtain(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> o	<c-o>:call <SID>NetrwSplit(3)<cr>
                            "   inoremap <buffer> <silent> <nowait> p	<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                            "   inoremap <buffer> <silent> <nowait> P	<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
                            "   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
                            "   inoremap <buffer> <silent> <nowait> r	<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> s	<c-o>:call <SID>NetrwSortStyle(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> S	<c-o>:call <SID>NetSortSequence(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> t	<c-o>:call <SID>NetrwSplit(4)<cr>
                            "   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
                            "   inoremap <buffer> <silent> <nowait> u	<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
                            "   inoremap <buffer> <silent> <nowait> U	<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
                            "   inoremap <buffer> <silent> <nowait> v	<c-o>:call <SID>NetrwSplit(5)<cr>
                            "   inoremap <buffer> <silent> <nowait> x	<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
                            "    imap <buffer> <unique> <c-h> <c-o><Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit		:call <SID>NetrwHideEdit(1)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
                            "    imap <buffer> <unique> <c-l> <c-o><Plug>NetrwRefresh
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh		<c-l>:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,(w:netrw_liststyle == 3)? w:netrw_treetop : './'))<cr>
                               if s:didstarstar || !mapcheck("<s-down>","n")
                                nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                            "    inoremap <buffer> <silent> <s-down>	<c-o>:Nexplore<cr>
                               endif
                               if s:didstarstar || !mapcheck("<s-up>","n")
                                nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                            "    inoremap <buffer> <silent> <s-up>	<c-o>:Pexplore<cr>
                               endif
                               if !hasmapto('<Plug>NetrwTreeSqueeze')
                                nmap <buffer> <silent> <nowait> <s-cr>			<Plug>NetrwTreeSqueeze
                            "    imap <buffer> <silent> <nowait> <s-cr>			<c-o><Plug>NetrwTreeSqueeze
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze		:call <SID>TreeSqueezeDir(1)<cr>
                               let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
                               if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>   				<Plug>NetrwLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
                                nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(1)<cr>
                                nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>		<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
                                nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
                                nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
                                nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
                                nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>		<Plug>ILeftmouse
                            "    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
                                imap <buffer> <middlemouse>		<Plug>IMiddlemouse
                            "    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                            "    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
                            "    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
                               call netrw#UserMaps(1)
                            
                              else " remote
                            "   call Decho("make remote maps",'~'.expand("<slnum>"))
                               call s:RemotePathAnalysis(b:netrw_curdir)
                               " remote normal-mode maps
                               nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(0)<cr>
                               nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(0)<cr>
                               nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(0)<cr>
                               nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
                               nnoremap <buffer> <silent> <nowait> <c-l>	:<c-u>call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(2,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
                               nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(0)<cr>
                               nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(0)<cr>
                               nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
                               nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(0)<cr>
                               nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(0,'b',v:count1)<cr>
                               nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(1)<cr>
                               nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(0,'h',v:count)<cr>
                               nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(2)<cr>
                               nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                            "   " remote insert-mode maps
                            "   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                            "   inoremap <buffer> <silent> <nowait> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> a		<c-o>:call <SID>NetrwHide(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                            "   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
                            "   inoremap <buffer> <silent> <nowait> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> o		<c-o>:call <SID>NetrwSplit(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> O		<c-o>:call <SID>NetrwObtain(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                            "   inoremap <buffer> <silent> <nowait> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                            "   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
                            "   inoremap <buffer> <silent> <nowait> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> S		<c-o>:call <SID>NetSortSequence(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> t		<c-o>:call <SID>NetrwSplit(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                            "   inoremap <buffer> <silent> <nowait> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> v		<c-o>:call <SID>NetrwSplit(2)<cr>
                            "   inoremap <buffer> <silent> <nowait> x		<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                            "   inoremap <buffer> <silent> <nowait> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <c-h> <Plug>NetrwHideEdit
                            "    imap <buffer> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <c-l> <Plug>NetrwRefresh
                            "    imap <buffer> <c-l> <Plug>NetrwRefresh
                               endif
                               if !hasmapto('<Plug>NetrwTreeSqueeze')
                                nmap <buffer> <silent> <nowait> <s-cr>	<Plug>NetrwTreeSqueeze
                            "    imap <buffer> <silent> <nowait> <s-cr>	<c-o><Plug>NetrwTreeSqueeze
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze	:call <SID>TreeSqueezeDir(0)<cr>
                            
                               let mapsafepath     = escape(s:path, s:netrw_map_escape)
                               let mapsafeusermach = escape(((s:user == "")? "" : s:user."@").s:machine, s:netrw_map_escape)
                            
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>		<Plug>NetrwLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
                                nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(0)<cr>
                                nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
                                nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
                                nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
                                nmap <middlemouse>			<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>		<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
                                nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>		<Plug>ILeftmouse
                            "    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
                                imap <buffer> <middlemouse>		<Plug>IMiddlemouse
                            "    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                                imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
                            "    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            "   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
                               call netrw#UserMaps(0)
                              endif
                            
                            "  call Dret("s:NetrwMaps")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwCommands: set up commands 				{{{2
                            "  If -buffer, the command is only available from within netrw buffers
                            "  Otherwise, the command is available from any window, so long as netrw
                            "  has been used at least once in the session.
    1              0.000002 fun! s:NetrwCommands(islocal)
                            "  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")
                            
                              com! -nargs=* -complete=file -bang	NetrwMB	call s:NetrwBookmark(<bang>0,<f-args>)
                              com! -nargs=*			    	NetrwC	call s:NetrwSetChgwin(<q-args>)
                              com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"win#".winnr()." not a former netrw window",79)|endif
                              if a:islocal
                               com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(1,<f-args>)
                              else
                               com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(0,<f-args>)
                              endif
                              com! -buffer -nargs=? -complete=file	MT	call s:NetrwMarkTarget(<q-args>)
                            
                            "  call Dret("s:NetrwCommands")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
                            "                   glob()ing only works with local files
    1              0.000002 fun! s:NetrwMarkFiles(islocal,...)
                            "  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
                              let curdir = s:NetrwGetCurdir(a:islocal)
                              let i      = 1
                              while i <= a:0
                               if a:islocal
                                if v:version > 704 || (v:version == 704 && has("patch656"))
                                 let mffiles= glob(fnameescape(a:{i}),0,1,1)
                                else
                                 let mffiles= glob(fnameescape(a:{i}),0,1)
                                endif
                               else
                                let mffiles= [a:{i}]
                               endif
                            "   call Decho("mffiles".string(mffiles),'~'.expand("<slnum>"))
                               for mffile in mffiles
                            "    call Decho("mffile<".mffile.">",'~'.expand("<slnum>"))
                                call s:NetrwMarkFile(a:islocal,mffile)
                               endfor
                               let i= i + 1
                              endwhile
                            "  call Dret("s:NetrwMarkFiles")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkTarget: implements :MT (mark target) {{{2
    1              0.000002 fun! s:NetrwMarkTarget(...)
                            "  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
                              if a:0 == 0 || (a:0 == 1 && a:1 == "")
                               let curdir = s:NetrwGetCurdir(1)
                               let tgt    = b:netrw_curdir
                              else
                               let curdir = s:NetrwGetCurdir((a:1 =~ '^\a\{3,}://')? 0 : 1)
                               let tgt    = a:1
                              endif
                            "  call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
                              let s:netrwmftgt         = tgt
                              let s:netrwmftgt_islocal = tgt !~ '^\a\{3,}://'
                              let curislocal           = b:netrw_curdir !~ '^\a\{3,}://'
                              let svpos                = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call winrestview(svpos)
                            "  call Dret("s:NetrwMarkTarget")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
                            "                  mark and unmark files.  If a markfile list exists,
                            "                  then the rename and delete functions will use it instead
                            "                  of whatever may happen to be under the cursor at that
                            "                  moment.  When the mouse and gui are available,
                            "                  shift-leftmouse may also be used to mark files.
                            "
                            "  Creates two lists
                            "    s:netrwmarkfilelist    -- holds complete paths to all marked files
                            "    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
                            "
                            "  Creates a marked file match string
                            "    s:netrwmarfilemtch_#   -- used with 2match to display marked files
                            "
                            "  Creates a buffer version of islocal
                            "    b:netrw_islocal
    1              0.000002 fun! s:NetrwMarkFile(islocal,fname)
                            "  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")
                            "  call Decho("bufnr(%)=".bufnr("%").": ".bufname("%"),'~'.expand("<slnum>"))
                            
                              " sanity check
                              if empty(a:fname)
                            "   call Dret("s:NetrwMarkFile : emtpy fname")
                               return
                              endif
                              let curdir = s:NetrwGetCurdir(a:islocal)
                            
                              let ykeep   = @@
                              let curbufnr= bufnr("%")
                              if a:fname =~ '^\a'
                               let leader= '\<'
                              else
                               let leader= ''
                              endif
                              if a:fname =~ '\a$'
                               let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
                              else
                               let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
                              endif
                            
                              if exists("s:netrwmarkfilelist_".curbufnr)
                               " markfile list pre-exists
                            "   call Decho("case s:netrwmarkfilelist_".curbufnr." already exists",'~'.expand("<slnum>"))
                            "   call Decho("starting s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
                            "   call Decho("starting s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
                               let b:netrw_islocal= a:islocal
                            
                               if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
                                " append filename to buffer's markfilelist
                            "    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
                                call add(s:netrwmarkfilelist_{curbufnr},a:fname)
                                let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer
                            
                               else
                                " remove filename from buffer's markfilelist
                            "    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
                                call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
                                if s:netrwmarkfilelist_{curbufnr} == []
                                 " local markfilelist is empty; remove it entirely
                            "     call Decho("markfile list now empty",'~'.expand("<slnum>"))
                                 call s:NetrwUnmarkList(curbufnr,curdir)
                                else
                                 " rebuild match list to display markings correctly
                            "     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr,'~'.expand("<slnum>"))
                                 let s:netrwmarkfilemtch_{curbufnr}= ""
                                 let first                         = 1
                                 for fname in s:netrwmarkfilelist_{curbufnr}
                                  if first
                                   let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
                                  else
                                   let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
                                  endif
                                  let first= 0
                                 endfor
                            "     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
                                endif
                               endif
                            
                              else
                               " initialize new markfilelist
                            "   call Decho("case: initialize new markfilelist",'~'.expand("<slnum>"))
                            
                            "   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr,'~'.expand("<slnum>"))
                               let s:netrwmarkfilelist_{curbufnr}= []
                               call add(s:netrwmarkfilelist_{curbufnr},substitute(a:fname,'[|@]$','',''))
                            "   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">",'~'.expand("<slnum>"))
                            
                               " build initial markfile matching pattern
                               if a:fname =~ '/$'
                                let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
                               else
                                let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
                               endif
                            "   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">",'~'.expand("<slnum>"))
                              endif
                            
                              " handle global markfilelist
                              if exists("s:netrwmarkfilelist")
                               let dname= s:ComposePath(b:netrw_curdir,a:fname)
                               if index(s:netrwmarkfilelist,dname) == -1
                                " append new filename to global markfilelist
                                call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
                            "    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
                               else
                                " remove new filename from global markfilelist
                            "    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")",'~'.expand("<slnum>"))
                                call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
                            "    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
                                if s:netrwmarkfilelist == []
                                 unlet s:netrwmarkfilelist
                                endif
                               endif
                              else
                               " initialize new global-directory markfilelist
                               let s:netrwmarkfilelist= []
                               call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
                            "   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
                              endif
                            
                              " set up 2match'ing to netrwmarkfilemtch_# list
                              if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/",'~'.expand("<slnum>"))
                               if exists("g:did_drchip_netrwlist_syntax")
                                exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
                               endif
                              else
                            "   call Decho("2match none",'~'.expand("<slnum>"))
                               2match none
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileArgList: ma: move the marked file list to the argument list (tomflist=0) {{{2
                            "                         mA: move the argument list to marked file list     (tomflist=1)
                            "                            Uses the global marked file list
    1              0.000011 fun! s:NetrwMarkFileArgList(islocal,tomflist)
                            "  call Dfunc("s:NetrwMarkFileArgList(islocal=".a:islocal.",tomflist=".a:tomflist.")")
                            
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              if a:tomflist
                               " mA: move argument list to marked file list
                               while argc()
                                let fname= argv(0)
                            "    call Decho("exe argdel ".fname,'~'.expand("<slnum>"))
                                exe "argdel ".fnameescape(fname)
                                call s:NetrwMarkFile(a:islocal,fname)
                               endwhile
                            
                              else
                               " ma: move marked file list to argument list
                               if exists("s:netrwmarkfilelist")
                            
                                " for every filename in the marked list
                                for fname in s:netrwmarkfilelist
                            "     call Decho("exe argadd ".fname,'~'.expand("<slnum>"))
                                 exe "argadd ".fnameescape(fname)
                                endfor	" for every file in the marked list
                            
                                " unmark list and refresh
                                call s:NetrwUnmarkList(curbufnr,curdir)
                                NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                NetrwKeepj call winrestview(svpos)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwMarkFileArgList")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
                            "                          compress/decompress files using the programs
                            "                          in g:netrw_compress and g:netrw_uncompress,
                            "                          using g:netrw_compress_suffix to know which to
                            "                          do.  By default:
                            "                            g:netrw_compress        = "gzip"
                            "                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
    1              0.000003 fun! s:NetrwMarkFileCompress(islocal)
                            "  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileCompress")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")
                            
                               " for every filename in the marked list
                               for fname in s:netrwmarkfilelist_{curbufnr}
                                let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
                            "    call Decho("extracted sfx<".sfx.">",'~'.expand("<slnum>"))
                                if exists("g:netrw_decompress['".sfx."']")
                                 " fname has a suffix indicating that its compressed; apply associated decompression routine
                                 let exe= g:netrw_decompress[sfx]
                            "     call Decho("fname<".fname."> is compressed so decompress with <".exe.">",'~'.expand("<slnum>"))
                                 let exe= netrw#WinPath(exe)
                                 if a:islocal
                                  if g:netrw_keepdir
                                   let fname= s:ShellEscape(s:ComposePath(curdir,fname))
                                  endif
                                 else
                                  let fname= s:ShellEscape(b:netrw_curdir.fname,1)
                                 endif
                                 if executable(exe)
                                  if a:islocal
                                   call system(exe." ".fname)
                                  else
                                   NetrwKeepj call s:RemoteSystem(exe." ".fname)
                                  endif
                                 else
                                  NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
                                 endif
                                endif
                                unlet sfx
                            
                                if exists("exe")
                                 unlet exe
                                elseif a:islocal
                                 " fname not a compressed file, so compress it
                                 call system(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(s:ComposePath(b:netrw_curdir,fname)))
                                else
                                 " fname not a compressed file, so compress it
                                 NetrwKeepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".s:ShellEscape(fname))
                                endif
                               endfor	" for every file in the marked list
                            
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              endif
                            "  call Dret("s:NetrwMarkFileCompress")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
                            "                      If no marked files, then set up directory as the
                            "                      target.  Currently does not support copying entire
                            "                      directories.  Uses the local-buffer marked file list.
                            "                      Returns 1=success  (used by NetrwMarkFileMove())
                            "                              0=failure
    1              0.000003 fun! s:NetrwMarkFileCopy(islocal,...)
                            "  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)
                            
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                              if b:netrw_curdir !~ '/$'
                               if !exists("b:netrw_curdir")
                                let b:netrw_curdir= curdir
                               endif
                               let b:netrw_curdir= b:netrw_curdir."/"
                              endif
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileCopy")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if !exists("s:netrwmftgt")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
                            "   call Dret("s:NetrwMarkFileCopy 0")
                               return 0
                              endif
                            "  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                            
                              if a:islocal &&  s:netrwmftgt_islocal
                               " Copy marked files, local directory to local directory
                            "   call Decho("copy from local to local",'~'.expand("<slnum>"))
                               if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
                                call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
                            "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
                                return
                               endif
                            
                               " copy marked files while within the same directory (ie. allow renaming)
                               if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
                                if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
                                 " only one marked file
                            "     call Decho("case: only one marked file",'~'.expand("<slnum>"))
                                 let args    = s:ShellEscape(b:netrw_curdir.s:netrwmarkfilelist_{bufnr('%')}[0])
                                 let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
                                elseif a:0 == 1
                            "     call Decho("case: handling one input argument",'~'.expand("<slnum>"))
                                 " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
                                 let args    = s:ShellEscape(b:netrw_curdir.a:1)
                                 let oldname = a:1
                                else
                                 " copy multiple marked files inside the same directory
                            "     call Decho("case: handling a multiple marked files",'~'.expand("<slnum>"))
                                 let s:recursive= 1
                                 for oldname in s:netrwmarkfilelist_{bufnr("%")}
                                  let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
                                  if ret == 0
                                   break
                                  endif
                                 endfor
                                 unlet s:recursive
                                 call s:NetrwUnmarkList(curbufnr,curdir)
                            "     call Dret("s:NetrwMarkFileCopy ".ret)
                                 return ret
                                endif
                            
                                call inputsave()
                                let newname= input("Copy ".oldname." to : ",oldname,"file")
                                call inputrestore()
                                if newname == ""
                            "     call Dret("s:NetrwMarkFileCopy 0")
                                 return 0
                                endif
                                let args= s:ShellEscape(oldname)
                                let tgt = s:ShellEscape(s:netrwmftgt.'/'.newname)
                               else
                                let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"s:ShellEscape(b:netrw_curdir.\"/\".v:val)"))
                                let tgt = s:ShellEscape(s:netrwmftgt)
                               endif
                               if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                let args= substitute(args,'/','\\','g')
                                let tgt = substitute(tgt, '/','\\','g')
                               endif
                               if args =~ "'" |let args= substitute(args,"'\\(.*\\)'",'\1','')|endif
                               if tgt  =~ "'" |let tgt = substitute(tgt ,"'\\(.*\\)'",'\1','')|endif
                               if args =~ '//'|let args= substitute(args,'//','/','g')|endif
                               if tgt  =~ '//'|let tgt = substitute(tgt ,'//','/','g')|endif
                            "   call Decho("args   <".args.">",'~'.expand("<slnum>"))
                            "   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
                               if isdirectory(s:NetrwFile(args))
                            "    call Decho("args<".args."> is a directory",'~'.expand("<slnum>"))
                                let copycmd= g:netrw_localcopydircmd
                            "    call Decho("using copydircmd<".copycmd.">",'~'.expand("<slnum>"))
                                if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                 " window's xcopy doesn't copy a directory to a target properly.  Instead, it copies a directory's
                                 " contents to a target.  One must append the source directory name to the target to get xcopy to
                                 " do the right thing.
                                 let tgt= tgt.'\'.substitute(a:1,'^.*[\\/]','','')
                            "     call Decho("modified tgt for xcopy",'~'.expand("<slnum>"))
                                endif
                               else
                                let copycmd= g:netrw_localcopycmd
                               endif
                               if g:netrw_localcopycmd =~ '\s'
                                let copycmd     = substitute(copycmd,'\s.*$','','')
                                let copycmdargs = substitute(copycmd,'^.\{-}\(\s.*\)$','\1','')
                                let copycmd     = netrw#WinPath(copycmd).copycmdargs
                               else
                                let copycmd = netrw#WinPath(copycmd)
                               endif
                            "   call Decho("args   <".args.">",'~'.expand("<slnum>"))
                            "   call Decho("tgt    <".tgt.">",'~'.expand("<slnum>"))
                            "   call Decho("copycmd<".copycmd.">",'~'.expand("<slnum>"))
                            "   call Decho("system(".copycmd." '".args."' '".tgt."')",'~'.expand("<slnum>"))
                               call system(copycmd." '".args."' '".tgt."'")
                               if v:shell_error != 0
                                if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
                                 call netrw#ErrorMsg(s:ERROR,"copy failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",101)
                                else
                                 call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
                                endif
                            "    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".s:ShellEscape(s:netrwmftgt))
                                return 0
                               endif
                            
                              elseif  a:islocal && !s:netrwmftgt_islocal
                               " Copy marked files, local directory to remote directory
                            "   call Decho("copy from local to remote",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
                            
                              elseif !a:islocal &&  s:netrwmftgt_islocal
                               " Copy marked files, remote directory to local directory
                            "   call Decho("copy from remote to local",'~'.expand("<slnum>"))
                               NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
                            
                              elseif !a:islocal && !s:netrwmftgt_islocal
                               " Copy marked files, remote directory to remote directory
                            "   call Decho("copy from remote to remote",'~'.expand("<slnum>"))
                               let curdir = getcwd()
                               let tmpdir = s:GetTempfile("")
                               if tmpdir !~ '/'
                                let tmpdir= curdir."/".tmpdir
                               endif
                               if exists("*mkdir")
                                call mkdir(tmpdir)
                               else
                                call s:NetrwExe("sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1))
                                if v:shell_error != 0
                                 call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
                            "     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.s:ShellEscape(tmpdir,1) )
                                 return
                                endif
                               endif
                               if isdirectory(s:NetrwFile(tmpdir))
                                call s:NetrwLcd(tmpdir)
                                NetrwKeepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
                                let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
                                NetrwKeepj call s:NetrwUpload(localfiles,s:netrwmftgt)
                                if getcwd() == tmpdir
                                 for fname in s:netrwmarkfilelist_{bufnr('%')}
                                  NetrwKeepj call s:NetrwDelete(fname)
                                 endfor
                                 call s:NetrwLcd(curdir)
                                 if v:version < 704 || !has("patch1109")
                                  call s:NetrwExe("sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1))
                                  if v:shell_error != 0
                                   call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
                            " "      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".s:ShellEscape(tmpdir,1) )
                                   return
                                  endif
                                 else
                                  if delete(tmpdir,"d")
                                   call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".tmpdir.">!",103)
                                  endif
                                 endif
                                else
                                 call s:NetrwLcd(curdir)
                                endif
                               endif
                              endif
                            
                              " -------
                              " cleanup
                              " -------
                            "  call Decho("cleanup",'~'.expand("<slnum>"))
                              " remove markings from local buffer
                              call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer
                            "  call Decho(" g:netrw_fastbrowse  =".g:netrw_fastbrowse,'~'.expand("<slnum>"))
                            "  call Decho(" s:netrwmftgt        =".s:netrwmftgt,'~'.expand("<slnum>"))
                            "  call Decho(" s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
                            "  call Decho(" curdir              =".curdir,'~'.expand("<slnum>"))
                            "  call Decho(" a:islocal           =".a:islocal,'~'.expand("<slnum>"))
                            "  call Decho(" curbufnr            =".curbufnr,'~'.expand("<slnum>"))
                              if exists("s:recursive")
                            "   call Decho(" s:recursive         =".s:recursive,'~'.expand("<slnum>"))
                              else
                            "   call Decho(" s:recursive         =n/a",'~'.expand("<slnum>"))
                              endif
                              " see s:LocalFastBrowser() for g:netrw_fastbrowse interpretation (refreshing done for both slow and medium)
                              if g:netrw_fastbrowse <= 1
                               NetrwKeepj call s:LocalBrowseRefresh()
                              else
                               " refresh local and targets for fast browsing
                               if !exists("s:recursive")
                                " remove markings from local buffer
                            "    call Decho(" remove markings from local buffer",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwUnmarkList(curbufnr,curdir)
                               endif
                            
                               " refresh buffers
                               if s:netrwmftgt_islocal
                            "    call Decho(" refresh s:netrwmftgt=".s:netrwmftgt,'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
                               endif
                               if a:islocal && s:netrwmftgt != curdir
                            "    call Decho(" refresh curdir=".curdir,'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefreshDir(a:islocal,curdir)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwMarkFileCopy 1")
                              return 1
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
                            "                      invoke vim's diff mode on the marked files.
                            "                      Either two or three files can be so handled.
                            "                      Uses the global marked file list.
    1              0.000004 fun! s:NetrwMarkFileDiff(islocal)
                            "  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileDiff")
                               return
                              endif
                              let curdir= s:NetrwGetCurdir(a:islocal)
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{".curbufnr."}")
                               let cnt    = 0
                               for fname in s:netrwmarkfilelist
                                let cnt= cnt + 1
                                if cnt == 1
                            "     call Decho("diffthis: fname<".fname.">",'~'.expand("<slnum>"))
                                 exe "NetrwKeepj e ".fnameescape(fname)
                                 diffthis
                                elseif cnt == 2 || cnt == 3
                                 vsplit
                                 wincmd l
                            "     call Decho("diffthis: ".fname,'~'.expand("<slnum>"))
                                 exe "NetrwKeepj e ".fnameescape(fname)
                                 diffthis
                                else
                                 break
                                endif
                               endfor
                               call s:NetrwUnmarkList(curbufnr,curdir)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileDiff")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
                            "                       Uses global markfilelist
    1              0.000006 fun! s:NetrwMarkFileEdit(islocal)
                            "  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")
                            
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileEdit")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               call s:SetRexDir(a:islocal,curdir)
                               let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
                               " unmark markedfile list
                            "   call s:NetrwUnmarkList(curbufnr,curdir)
                               call s:NetrwUnmarkAll()
                            "   call Decho("exe sil args ".flist,'~'.expand("<slnum>"))
                               exe "sil args ".flist
                              endif
                              echo "(use :bn, :bp to navigate files; :Rex to return)"
                            
                            "  call Dret("s:NetrwMarkFileEdit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileQFEL: convert a quickfix-error or location list into a marked file list {{{2
    1              0.000002 fun! s:NetrwMarkFileQFEL(islocal,qfel)
                            "  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
                              call s:NetrwUnmarkAll()
                              let curbufnr= bufnr("%")
                            
                              if !empty(a:qfel)
                               for entry in a:qfel
                                let bufnmbr= entry["bufnr"]
                            "    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"],'~'.expand("<slnum>"))
                                if !exists("s:netrwmarkfilelist_{curbufnr}")
                            "     call Decho("case: no marked file list",'~'.expand("<slnum>"))
                                 call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
                                elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
                                 " s:NetrwMarkFile will remove duplicate entries from the marked file list.
                                 " So, this test lets two or more hits on the same pattern to be ignored.
                            "     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list",'~'.expand("<slnum>"))
                                 call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
                                else
                            "     call Decho("case: ".bufname(bufnmbr)." already in marked file list",'~'.expand("<slnum>"))
                                endif
                               endfor
                               echo "(use me to edit marked files)"
                              else
                               call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileQFEL")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileExe: (invoked by mx and mX) execute arbitrary system command on marked files {{{2
                            "                     mx enbloc=0: Uses the local marked-file list, applies command to each file individually
                            "                     mX enbloc=1: Uses the global marked-file list, applies command to entire list
    1              0.000002 fun! s:NetrwMarkFileExe(islocal,enbloc)
                            "  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.",enbloc=".a:enbloc.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              if a:enbloc == 0
                               " individually apply command to files, one at a time
                                " sanity check
                                if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                                 NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "     call Dret("s:NetrwMarkFileExe")
                                 return
                                endif
                            "    call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                                if exists("s:netrwmarkfilelist_{curbufnr}")
                                 " get the command
                                 call inputsave()
                                 let cmd= input("Enter command: ","","file")
                                 call inputrestore()
                            "     call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
                                 if cmd == ""
                            "      call Dret("s:NetrwMarkFileExe : early exit, empty command")
                                  return
                                 endif
                            
                                 " apply command to marked files, individually.  Substitute: filename -> %
                                 " If no %, then append a space and the filename to the command
                                 for fname in s:netrwmarkfilelist_{curbufnr}
                                  if a:islocal
                                   if g:netrw_keepdir
                            	let fname= s:ShellEscape(netrw#WinPath(s:ComposePath(curdir,fname)))
                                   endif
                                  else
                                   let fname= s:ShellEscape(netrw#WinPath(b:netrw_curdir.fname))
                                  endif
                                  if cmd =~ '%'
                                   let xcmd= substitute(cmd,'%',fname,'g')
                                  else
                                   let xcmd= cmd.' '.fname
                                  endif
                                  if a:islocal
                            "       call Decho("local: xcmd<".xcmd.">",'~'.expand("<slnum>"))
                                   let ret= system(xcmd)
                                  else
                            "       call Decho("remote: xcmd<".xcmd.">",'~'.expand("<slnum>"))
                                   let ret= s:RemoteSystem(xcmd)
                                  endif
                                  if v:shell_error < 0
                                   NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
                                   break
                                  else
                                   echo ret
                                  endif
                                 endfor
                            
                               " unmark marked file list
                               call s:NetrwUnmarkList(curbufnr,curdir)
                            
                               " refresh the listing
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                             else " apply command to global list of files, en bloc
                            
                              call inputsave()
                              let cmd= input("Enter command: ","","file")
                              call inputrestore()
                            "  call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
                              if cmd == ""
                            "   call Dret("s:NetrwMarkFileExe : early exit, empty command")
                               return
                              endif
                              if cmd =~ '%'
                               let cmd= substitute(cmd,'%',join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' '),'g')
                              else
                               let cmd= cmd.' '.join(map(s:netrwmarkfilelist,'s:ShellEscape(v:val)'),' ')
                              endif
                              if a:islocal
                               call system(cmd)
                               if v:shell_error < 0
                                NetrwKeepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
                               endif
                              else
                               let ret= s:RemoteSystem(cmd)
                              endif
                              call s:NetrwUnmarkAll()
                            
                              " refresh the listing
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                            
                             endif
                            
                            "  call Dret("s:NetrwMarkFileExe")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
                            "                  as the marked file(s) (toggles suffix presence)
                            "                  Uses the local marked file list.
    1              0.000002 fun! s:NetrwMarkHideSfx(islocal)
                            "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curbufnr = bufnr("%")
                            
                              " s:netrwmarkfilelist_{curbufnr}: the List of marked files
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                            
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
                                 " construct suffix pattern
                                 if fname =~ '\.'
                                  let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
                                 else
                                  let sfxpat= '^\%(\%(\.\)\@!.\)*$'
                                 endif
                                 " determine if its in the hiding list or not
                                 let inhidelist= 0
                                 if g:netrw_list_hide != ""
                                  let itemnum = 0
                                  let hidelist= split(g:netrw_list_hide,',')
                                  for hidepat in hidelist
                                   if sfxpat == hidepat
                                    let inhidelist= 1
                                    break
                                   endif
                                   let itemnum= itemnum + 1
                                  endfor
                                 endif
                            "     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
                                 if inhidelist
                                  " remove sfxpat from list
                                  call remove(hidelist,itemnum)
                                  let g:netrw_list_hide= join(hidelist,",")
                                 elseif g:netrw_list_hide != ""
                                  " append sfxpat to non-empty list
                                  let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
                                 else
                                  " set hiding list to sfxpat
                                  let g:netrw_list_hide= sfxpat
                                 endif
                                endfor
                            
                               " refresh the listing
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                            "  call Dret("s:NetrwMarkHideSfx")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileVimCmd: (invoked by mv) execute arbitrary vim command on marked files, one at a time {{{2
                            "                     Uses the local marked-file list.
    1              0.000002 fun! s:NetrwMarkFileVimCmd(islocal)
                            "  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileVimCmd")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               " get the command
                               call inputsave()
                               let cmd= input("Enter vim command: ","","file")
                               call inputrestore()
                            "   call Decho("cmd<".cmd.">",'~'.expand("<slnum>"))
                               if cmd == ""
                            "    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
                                return
                               endif
                            
                               " apply command to marked files.  Substitute: filename -> %
                               " If no %, then append a space and the filename to the command
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                                if a:islocal
                                 1split
                                 exe "sil! NetrwKeepj keepalt e ".fnameescape(fname)
                            "     call Decho("local<".fname.">: exe ".cmd,'~'.expand("<slnum>"))
                                 exe cmd
                                 exe "sil! keepalt wq!"
                                else
                            "     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET",'~'.expand("<slnum>"))
                                 echo "sorry, \"mv\" not supported yet for remote files"
                                endif
                               endfor
                            
                               " unmark marked file list
                               call s:NetrwUnmarkList(curbufnr,curdir)
                            
                               " refresh the listing
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileVimCmd")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
                            "                  as the marked file(s) (toggles suffix presence)
                            "                  Uses the local marked file list.
    1              0.000002 fun! s:NetrwMarkHideSfx(islocal)
                            "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curbufnr = bufnr("%")
                            
                              " s:netrwmarkfilelist_{curbufnr}: the List of marked files
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                            
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "     call Decho("s:NetrwMarkFileCopy: fname<".fname.">",'~'.expand("<slnum>"))
                                 " construct suffix pattern
                                 if fname =~ '\.'
                                  let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
                                 else
                                  let sfxpat= '^\%(\%(\.\)\@!.\)*$'
                                 endif
                                 " determine if its in the hiding list or not
                                 let inhidelist= 0
                                 if g:netrw_list_hide != ""
                                  let itemnum = 0
                                  let hidelist= split(g:netrw_list_hide,',')
                                  for hidepat in hidelist
                                   if sfxpat == hidepat
                                    let inhidelist= 1
                                    break
                                   endif
                                   let itemnum= itemnum + 1
                                  endfor
                                 endif
                            "     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">",'~'.expand("<slnum>"))
                                 if inhidelist
                                  " remove sfxpat from list
                                  call remove(hidelist,itemnum)
                                  let g:netrw_list_hide= join(hidelist,",")
                                 elseif g:netrw_list_hide != ""
                                  " append sfxpat to non-empty list
                                  let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
                                 else
                                  " set hiding list to sfxpat
                                  let g:netrw_list_hide= sfxpat
                                 endif
                                endfor
                            
                               " refresh the listing
                               NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                            "  call Dret("s:NetrwMarkHideSfx")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
                            "                     Uses the global markfilelist
    1              0.000001 fun! s:NetrwMarkFileGrep(islocal)
                            "  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curbufnr = bufnr("%")
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                            
                              if exists("s:netrwmarkfilelist")
                            "  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
                               let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
                               call s:NetrwUnmarkAll()
                              else
                            "   call Decho('no marked files, using "*"','~'.expand("<slnum>"))
                               let netrwmarkfilelist= "*"
                              endif
                            
                              " ask user for pattern
                              call inputsave()
                              let pat= input("Enter pattern: ","")
                              call inputrestore()
                              let patbang = ""
                              if pat =~ '^!'
                               let patbang = "!"
                               let pat     = strpart(pat,2)
                              endif
                              if pat =~ '^\i'
                               let pat    = escape(pat,'/')
                               let pat    = '/'.pat.'/'
                              else
                               let nonisi = pat[0]
                              endif
                            
                              " use vimgrep for both local and remote
                            "  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist,'~'.expand("<slnum>"))
                              try
                               exe "NetrwKeepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
                              catch /^Vim\%((\a\+)\)\=:E480/
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
                            "   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
                               return
                              endtry
                              echo "(use :cn, :cp to navigate, :Rex to return)"
                            
                              2match none
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                            
                              if exists("nonisi")
                               " original, user-supplied pattern did not begin with a character from isident
                            "   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg",'~'.expand("<slnum>"))
                               if pat =~# nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
                                call s:NetrwMarkFileQFEL(a:islocal,getqflist())
                               endif
                              endif
                            
                            "  call Dret("s:NetrwMarkFileGrep")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
                            "                      uses the global marked file list
                            "                      s:netrwmfloc= 0: target directory is remote
                            "                                  = 1: target directory is local
    1              0.000002 fun! s:NetrwMarkFileMove(islocal)
                            "  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileMove")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if !exists("s:netrwmftgt")
                               NetrwKeepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
                            "   call Dret("s:NetrwMarkFileCopy 0")
                               return 0
                              endif
                            "  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                            
                              if      a:islocal &&  s:netrwmftgt_islocal
                               " move: local -> local
                            "   call Decho("move from local to local",'~'.expand("<slnum>"))
                            "   call Decho("local to local move",'~'.expand("<slnum>"))
                               if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
                                call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
                            "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
                                return
                               endif
                               let tgt         = s:ShellEscape(s:netrwmftgt)
                            "   call Decho("tgt<".tgt.">",'~'.expand("<slnum>"))
                               if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                let tgt         = substitute(tgt, '/','\\','g')
                            "    call Decho("windows exception: tgt<".tgt.">",'~'.expand("<slnum>"))
                                if g:netrw_localmovecmd =~ '\s'
                                 let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
                                 let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
                                 let movecmd     = netrw#WinPath(movecmd).movecmdargs
                            "     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)",'~'.expand("<slnum>"))
                                else
                                 let movecmd = netrw#WinPath(movecmd)
                            "     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)",'~'.expand("<slnum>"))
                                endif
                               else
                                let movecmd = netrw#WinPath(g:netrw_localmovecmd)
                            "    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)",'~'.expand("<slnum>"))
                               endif
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                                if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                 let fname= substitute(fname,'/','\\','g')
                                endif
                            "    call Decho("system(".movecmd." ".s:ShellEscape(fname)." ".tgt.")",'~'.expand("<slnum>"))
                                let ret= system(movecmd." ".s:ShellEscape(fname)." ".tgt)
                                if v:shell_error != 0
                                 if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
                                  call netrw#ErrorMsg(s:ERROR,"move failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",100)
                                 else
                                  call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
                                 endif
                                 break
                                endif
                               endfor
                            
                              elseif  a:islocal && !s:netrwmftgt_islocal
                               " move: local -> remote
                            "   call Decho("move from local to remote",'~'.expand("<slnum>"))
                            "   call Decho("copy",'~'.expand("<slnum>"))
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove",'~'.expand("<slnum>"))
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                            
                              elseif !a:islocal &&  s:netrwmftgt_islocal
                               " move: remote -> local
                            "   call Decho("move from remote to local",'~'.expand("<slnum>"))
                            "   call Decho("copy",'~'.expand("<slnum>"))
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove",'~'.expand("<slnum>"))
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                            
                              elseif !a:islocal && !s:netrwmftgt_islocal
                               " move: remote -> remote
                            "   call Decho("move from remote to remote",'~'.expand("<slnum>"))
                            "   call Decho("copy",'~'.expand("<slnum>"))
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               NetrwKeepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove",'~'.expand("<slnum>"))
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                              endif
                            
                              " -------
                              " cleanup
                              " -------
                            "  call Decho("cleanup",'~'.expand("<slnum>"))
                            
                              " remove markings from local buffer
                              call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer
                            
                              " refresh buffers
                              if !s:netrwmftgt_islocal
                            "   call Decho("refresh netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
                              endif
                              if a:islocal
                            "   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
                              endif
                              if g:netrw_fastbrowse <= 1
                            "   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh",'~'.expand("<slnum>"))
                               NetrwKeepj call s:LocalBrowseRefresh()
                              endif
                            
                            "  call Dret("s:NetrwMarkFileMove")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
                            "                       using the hardcopy command.  Local marked-file list only.
    1              0.000002 fun! s:NetrwMarkFilePrint(islocal)
                            "  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFilePrint")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                              let curdir= s:NetrwGetCurdir(a:islocal)
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               for fname in netrwmarkfilelist
                                if a:islocal
                                 if g:netrw_keepdir
                                  let fname= s:ComposePath(curdir,fname)
                                 endif
                                else
                                 let fname= curdir.fname
                                endif
                                1split
                                " the autocmds will handle both local and remote files
                            "    call Decho("exe sil e ".escape(fname,' '),'~'.expand("<slnum>"))
                                exe "sil NetrwKeepj e ".fnameescape(fname)
                            "    call Decho("hardcopy",'~'.expand("<slnum>"))
                                hardcopy
                                q
                               endfor
                               2match none
                              endif
                            "  call Dret("s:NetrwMarkFilePrint")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
                            "                        files when given a regexp (for which a prompt is
                            "                        issued) (matches to name of files).
    1              0.000002 fun! s:NetrwMarkFileRegexp(islocal)
                            "  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")
                            
                              " get the regular expression
                              call inputsave()
                              let regexp= input("Enter regexp: ","","file")
                              call inputrestore()
                            
                              if a:islocal
                               let curdir= s:NetrwGetCurdir(a:islocal)
                               " get the matching list of files using local glob()
                            "   call Decho("handle local regexp",'~'.expand("<slnum>"))
                               let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
                               if v:version > 704 || (v:version == 704 && has("patch656"))
                                let files   = glob(s:ComposePath(dirname,regexp),0,0,1)
                               else
                                let files   = glob(s:ComposePath(dirname,regexp),0,0)
                               endif
                            "   call Decho("files<".files.">",'~'.expand("<slnum>"))
                               let filelist= split(files,"\n")
                            
                              " mark the list of files
                              for fname in filelist
                            "   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
                              endfor
                            
                              else
                            "   call Decho("handle remote regexp",'~'.expand("<slnum>"))
                            
                               " convert displayed listing into a filelist
                               let eikeep = &ei
                               let areg   = @a
                               sil NetrwKeepj %y a
                               setl ei=all ma
                            "   call Decho("setl ei=all ma",'~'.expand("<slnum>"))
                               1split
                               NetrwKeepj call s:NetrwEnew()
                               NetrwKeepj call s:NetrwSafeOptions()
                               sil NetrwKeepj norm! "ap
                               NetrwKeepj 2
                               let bannercnt= search('^" =====','W')
                               exe "sil NetrwKeepj 1,".bannercnt."d"
                               setl bt=nofile
                               if     g:netrw_liststyle == s:LONGLIST
                                sil NetrwKeepj %s/\s\{2,}\S.*$//e
                                call histdel("/",-1)
                               elseif g:netrw_liststyle == s:WIDELIST
                                sil NetrwKeepj %s/\s\{2,}/\r/ge
                                call histdel("/",-1)
                               elseif g:netrw_liststyle == s:TREELIST
                                exe 'sil NetrwKeepj %s/^'.s:treedepthstring.' //e'
                                sil! NetrwKeepj g/^ .*$/d
                                call histdel("/",-1)
                                call histdel("/",-1)
                               endif
                               " convert regexp into the more usual glob-style format
                               let regexp= substitute(regexp,'\*','.*','g')
                            "   call Decho("regexp<".regexp.">",'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj v/".escape(regexp,'/')."/d"
                               call histdel("/",-1)
                               let filelist= getline(1,line("$"))
                               q!
                               for filename in filelist
                                NetrwKeepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
                               endfor
                               unlet filelist
                               let @a  = areg
                               let &ei = eikeep
                              endif
                              echo "  (use me to edit marked files)"
                            
                            "  call Dret("s:NetrwMarkFileRegexp")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
                            "                        Uses the local marked file list.
    1              0.000003 fun! s:NetrwMarkFileSource(islocal)
                            "  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileSource")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                              let curdir= s:NetrwGetCurdir(a:islocal)
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               for fname in netrwmarkfilelist
                                if a:islocal
                                 if g:netrw_keepdir
                                  let fname= s:ComposePath(curdir,fname)
                                 endif
                                else
                                 let fname= curdir.fname
                                endif
                                " the autocmds will handle sourcing both local and remote files
                            "    call Decho("exe so ".fnameescape(fname),'~'.expand("<slnum>"))
                                exe "so ".fnameescape(fname)
                               endfor
                               2match none
                              endif
                            "  call Dret("s:NetrwMarkFileSource")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
                            "                     Uses the global markfilelist
    1              0.000002 fun! s:NetrwMarkFileTag(islocal)
                            "  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir   = s:NetrwGetCurdir(a:islocal)
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               NetrwKeepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileTag")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}),'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist")
                            "   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">",'~'.expand("<slnum>"))
                               let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "s:ShellEscape(v:val,".!a:islocal.")"))
                               call s:NetrwUnmarkAll()
                            
                               if a:islocal
                                if executable(g:netrw_ctags)
                            "     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")",'~'.expand("<slnum>"))
                                 call system(g:netrw_ctags." ".netrwmarkfilelist)
                                else
                                 call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
                                endif
                               else
                                let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
                                call netrw#Obtain(a:islocal,"tags")
                                let curdir= b:netrw_curdir
                                1split
                                NetrwKeepj e tags
                                let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
                            "    call Decho("curdir<".curdir."> path<".path.">",'~'.expand("<slnum>"))
                                exe 'NetrwKeepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
                                call histdel("/",-1)
                                wq!
                               endif
                               2match none
                               call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               call winrestview(svpos)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileTag")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
                            "   Sets up two variables,
                            "     s:netrwmftgt         : holds the target directory
                            "     s:netrwmftgt_islocal : 0=target directory is remote
                            "                            1=target directory is local
    1              0.000002 fun! s:NetrwMarkFileTgt(islocal)
                            " call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
                              let svpos  = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curdir = s:NetrwGetCurdir(a:islocal)
                              let hadtgt = exists("s:netrwmftgt")
                              if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= b:netrw_bannercnt
                              endif
                            
                              " set up target
                              if line(".") < w:netrw_bannercnt
                            "   call Decho("set up target: line(.) < w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                               " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
                               if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
                            "    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target",'~'.expand("<slnum>"))
                                unlet s:netrwmftgt s:netrwmftgt_islocal
                                if g:netrw_fastbrowse <= 1
                                 call s:LocalBrowseRefresh()
                                endif
                                call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "    call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                                call winrestview(svpos)
                            "    call Dret("s:NetrwMarkFileTgt : removed target")
                                return
                               else
                                let s:netrwmftgt= b:netrw_curdir
                            "    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                               endif
                            
                              else
                               " get word under cursor.
                               "  * If directory, use it for the target.
                               "  * If file, use b:netrw_curdir for the target
                            "   call Decho("get word under cursor",'~'.expand("<slnum>"))
                               let curword= s:NetrwGetWord()
                               let tgtdir = s:ComposePath(curdir,curword)
                               if a:islocal && isdirectory(s:NetrwFile(tgtdir))
                                let s:netrwmftgt = tgtdir
                            "    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                               elseif !a:islocal && tgtdir =~ '/$'
                                let s:netrwmftgt = tgtdir
                            "    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                               else
                                let s:netrwmftgt = curdir
                            "    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                               endif
                              endif
                              if a:islocal
                               " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
                               let s:netrwmftgt= simplify(s:netrwmftgt)
                            "   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                              endif
                              if g:netrw_cygwin
                               let s:netrwmftgt= substitute(system("cygpath ".s:ShellEscape(s:netrwmftgt)),'\n$','','')
                               let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
                              endif
                              let s:netrwmftgt_islocal= a:islocal
                            
                              " need to do refresh so that the banner will be updated
                              "  s:LocalBrowseRefresh handles all local-browsing buffers when not fast browsing
                              if g:netrw_fastbrowse <= 1
                            "   call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse.", so refreshing all local netrw buffers",'~'.expand("<slnum>"))
                               call s:LocalBrowseRefresh()
                              endif
                            "  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,w:netrw_treetop))
                              else
                               call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              endif
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call winrestview(svpos)
                              if !hadtgt
                               sil! NetrwKeepj norm! j
                              endif
                            
                            "  call Decho("getmatches=".string(getmatches()),'~'.expand("<slnum>"))
                            "  call Decho("s:netrwmarkfilelist=".(exists("s:netrwmarkfilelist")? string(s:netrwmarkfilelist) : 'n/a'),'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGetCurdir: gets current directory and sets up b:netrw_curdir if necessary {{{2
    1              0.000002 fun! s:NetrwGetCurdir(islocal)
                            "  call Dfunc("s:NetrwGetCurdir(islocal=".a:islocal.")")
                            
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let b:netrw_curdir = s:NetrwTreePath(w:netrw_treetop)
                            "   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used s:NetrwTreeDir)",'~'.expand("<slnum>"))
                              elseif !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                            "   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
                              endif
                            
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir."> ".((b:netrw_curdir !~ '\<\a\{3,}://')? "does not match" : "matches")." url pattern",'~'.expand("<slnum>"))
                              if b:netrw_curdir !~ '\<\a\{3,}://'
                               let curdir= b:netrw_curdir
                            "   call Decho("g:netrw_keepdir=".g:netrw_keepdir,'~'.expand("<slnum>"))
                               if g:netrw_keepdir == 0
                                call s:NetrwLcd(curdir)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwGetCurdir <".curdir.">")
                              return b:netrw_curdir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwOpenFile: query user for a filename and open it {{{2
    1              0.000002 fun! s:NetrwOpenFile(islocal)
                            "  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
                              let ykeep= @@
                              call inputsave()
                              let fname= input("Enter filename: ")
                              call inputrestore()
                              if fname !~ '[/\\]'
                               if exists("b:netrw_curdir")
                                if exists("g:netrw_quiet")
                                 let netrw_quiet_keep = g:netrw_quiet
                                endif
                                let g:netrw_quiet = 1
                                " save position for benefit of Rexplore
                                let s:rexposn_{bufnr("%")}= winsaveview()
                            "    call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                                if b:netrw_curdir =~ '/$'
                                 exe "NetrwKeepj e ".fnameescape(b:netrw_curdir.fname)
                                else
                                 exe "e ".fnameescape(b:netrw_curdir."/".fname)
                                endif
                                if exists("netrw_quiet_keep")
                                 let g:netrw_quiet= netrw_quiet_keep
                                else
                                 unlet g:netrw_quiet
                                endif
                               endif
                              else
                               exe "NetrwKeepj e ".fnameescape(fname)
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwOpenFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Shrink: shrinks/expands a netrw or Lexplorer window {{{2
                            "               For the mapping to this function be made via
                            "               netrwPlugin, you'll need to have had
                            "               g:netrw_usetab set to non-zero.
    1              0.000001 fun! netrw#Shrink()
                            "  call Dfunc("netrw#Shrink() ft<".&ft."> winwidth=".winwidth(0)." lexbuf#".((exists("t:netrw_lexbufnr"))? t:netrw_lexbufnr : 'n/a'))
                              let curwin  = winnr()
                              let wiwkeep = &wiw
                              set wiw=1
                            
                              if &ft == "netrw"
                               if winwidth(0) > g:netrw_wiw
                                let t:netrw_winwidth= winwidth(0)
                                exe "vert resize ".g:netrw_wiw
                                wincmd l
                                if winnr() == curwin
                                 wincmd h
                                endif
                            "    call Decho("vert resize 0",'~'.expand("<slnum>"))
                               else
                                exe "vert resize ".t:netrw_winwidth
                            "    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
                               endif
                            
                              elseif exists("t:netrw_lexbufnr")
                               exe bufwinnr(t:netrw_lexbufnr)."wincmd w"
                               if     winwidth(bufwinnr(t:netrw_lexbufnr)) >  g:netrw_wiw
                                let t:netrw_winwidth= winwidth(0)
                                exe "vert resize ".g:netrw_wiw
                                wincmd l
                                if winnr() == curwin
                                 wincmd h
                                endif
                            "    call Decho("vert resize 0",'~'.expand("<slnum>"))
                               elseif winwidth(bufwinnr(t:netrw_lexbufnr)) >= 0
                                exe "vert resize ".t:netrw_winwidth
                            "    call Decho("vert resize ".t:netrw_winwidth,'~'.expand("<slnum>"))
                               else 
                                call netrw#Lexplore(0,0)
                               endif
                            
                              else
                               call netrw#Lexplore(0,0)
                              endif
                              let wiw= wiwkeep
                            
                            "  call Dret("netrw#Shrink")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetSortSequence: allows user to edit the sorting sequence {{{2
    1              0.000002 fun! s:NetSortSequence(islocal)
                            "  call Dfunc("NetSortSequence(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              call inputsave()
                              let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
                              call inputrestore()
                            
                              " refresh the listing
                              let g:netrw_sort_sequence= newsortseq
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetSortSequence")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkList: delete local marked file list and remove their contents from the global marked-file list {{{2
                            "   User access provided by the <mF> mapping. (see :help netrw-mF)
                            "   Used by many MarkFile functions.
    1              0.000002 fun! s:NetrwUnmarkList(curbufnr,curdir)
                            "  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")
                            
                              "  remove all files in local marked-file list from global list
                              if exists("s:netrwmarkfilelist")
                               for mfile in s:netrwmarkfilelist_{a:curbufnr}
                                let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
                                let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
                                call remove(s:netrwmarkfilelist,idx)            " remove from global list
                               endfor
                               if s:netrwmarkfilelist == []
                                unlet s:netrwmarkfilelist
                               endif
                            
                               " getting rid of the local marked-file lists is easy
                               unlet s:netrwmarkfilelist_{a:curbufnr}
                              endif
                              if exists("s:netrwmarkfilemtch_{a:curbufnr}")
                               unlet s:netrwmarkfilemtch_{a:curbufnr}
                              endif
                              2match none
                            "  call Dret("s:NetrwUnmarkList")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
    1              0.000002 fun! s:NetrwUnmarkAll()
                            "  call Dfunc("s:NetrwUnmarkAll()")
                              if exists("s:netrwmarkfilelist")
                               unlet s:netrwmarkfilelist
                              endif
                              sil call s:NetrwUnmarkAll2()
                              2match none
                            "  call Dret("s:NetrwUnmarkAll")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
    1              0.000001 fun! s:NetrwUnmarkAll2()
                            "  call Dfunc("s:NetrwUnmarkAll2()")
                              redir => netrwmarkfilelist_let
                              let
                              redir END
                              let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
                              call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_
                              call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
                              for flist in netrwmarkfilelist_list
                               let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
                               unlet s:netrwmarkfilelist_{curbufnr}
                               unlet s:netrwmarkfilemtch_{curbufnr}
                              endfor
                            "  call Dret("s:NetrwUnmarkAll2")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnMarkFile: called via mu map; unmarks *all* marked files, both global and buffer-local {{{2
                            "
                            " Marked files are in two types of lists:
                            "    s:netrwmarkfilelist    -- holds complete paths to all marked files
                            "    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
                            "
                            " Marked files suitable for use with 2match are in:
                            "    s:netrwmarkfilemtch_#   -- used with 2match to display marked files
    1              0.000002 fun! s:NetrwUnMarkFile(islocal)
                            "  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let curbufnr = bufnr("%")
                            
                              " unmark marked file list
                              " (although I expect s:NetrwUpload() to do it, I'm just making sure)
                              if exists("s:netrwmarkfilelist")
                            "   "   call Decho("unlet'ing: s:netrwmarkfilelist",'~'.expand("<slnum>"))
                               unlet s:netrwmarkfilelist
                              endif
                            
                              let ibuf= 1
                              while ibuf < bufnr("$")
                               if exists("s:netrwmarkfilelist_".ibuf)
                                unlet s:netrwmarkfilelist_{ibuf}
                                unlet s:netrwmarkfilemtch_{ibuf}
                               endif
                               let ibuf = ibuf + 1
                              endwhile
                              2match none
                            
                            "  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            call winrestview(svpos)
                            "  call Dret("s:NetrwUnMarkFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMenu: generates the menu for gvim and netrw {{{2
    1              0.000001 fun! s:NetrwMenu(domenu)
                            
                              if !exists("g:NetrwMenuPriority")
                               let g:NetrwMenuPriority= 80
                              endif
                            
                              if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                            "   call Dfunc("NetrwMenu(domenu=".a:domenu.")")
                            
                               if !exists("s:netrw_menu_enabled") && a:domenu
                            "    call Decho("initialize menu",'~'.expand("<slnum>"))
                                let s:netrw_menu_enabled= 1
                                exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
                                if g:netrw_dirhistmax > 0
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
                                else
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
                                endif
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Exten<tab>s      :let g:netrw_sort_by="exten"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
                                let s:netrw_menucnt= 28
                                call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
                                call s:NetrwTgtMenu()      " let bookmarks and history be easy targets
                            
                               elseif !a:domenu
                                let s:netrwcnt = 0
                                let curwin     = winnr()
                                windo if getline(2) =~# "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
                                exe curwin."wincmd w"
                            
                                if s:netrwcnt <= 1
                            "     call Decho("clear menus",'~'.expand("<slnum>"))
                                 exe 'sil! unmenu '.g:NetrwTopLvlMenu
                            "     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*','~'.expand("<slnum>"))
                                 sil! unlet s:netrw_menu_enabled
                                endif
                               endif
                            "   call Dret("NetrwMenu")
                               return
                              endif
                            
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwObtain: obtain file under cursor or from markfile list {{{2
                            "                Used by the O maps (as <SID>NetrwObtain())
    1              0.000002 fun! s:NetrwObtain(islocal)
                            "  call Dfunc("NetrwObtain(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\{3,}://'
                               call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
                               call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
                              else
                               call netrw#Obtain(a:islocal,expand("<cWORD>"))
                              endif
                              let @@= ykeep
                            
                            "  call Dret("NetrwObtain")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
                            "   If there's only one window, then the window will first be split.
                            "   Returns:
                            "     choice = 0 : didn't have to choose
                            "     choice = 1 : saved modified file in window first
                            "     choice = 2 : didn't save modified file, opened window
                            "     choice = 3 : cancel open
    1              0.000001 fun! s:NetrwPrevWinOpen(islocal)
                            "  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " grab a copy of the b:netrw_curdir to pass it along to newly split windows
                              let curdir = b:netrw_curdir
                            
                              " get last window number and the word currently under the cursor
                              let origwin   = winnr()
                              let lastwinnr = winnr("$")
                              let curword   = s:NetrwGetWord()
                              let choice    = 0
                              let s:treedir = s:NetrwTreeDir(a:islocal)
                              let curdir    = s:treedir
                            "  call Decho("winnr($)#".lastwinnr." curword<".curword.">",'~'.expand("<slnum>"))
                            
                              let didsplit = 0
                              if lastwinnr == 1
                               " if only one window, open a new one first
                            "   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")",'~'.expand("<slnum>"))
                               if g:netrw_preview
                                " vertically split preview window
                                let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                            "    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s",'~'.expand("<slnum>"))
                                exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
                               else
                                " horizontally split preview window
                                let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                            "    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
                                exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               endif
                               let didsplit = 1
                            "   call Decho("did split",'~'.expand("<slnum>"))
                            
                              else
                               NetrwKeepj call s:SaveBufVars()
                               let eikeep= &ei
                               setl ei=all
                               wincmd p
                            "   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">",'~'.expand("<slnum>"))
                            
                               " prevwinnr: the window number of the "prev" window
                               " prevbufnr: the buffer number of the buffer in the "prev" window
                               " bnrcnt   : the qty of windows open on the "prev" buffer
                               let prevwinnr   = winnr()
                               let prevbufnr   = bufnr("%")
                               let prevbufname = bufname("%")
                               let prevmod     = &mod
                               let bnrcnt      = 0
                               NetrwKeepj call s:RestoreBufVars()
                            "   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr,'~'.expand("<slnum>"))
                            
                               " if the previous window's buffer has been changed (ie. its modified flag is set),
                               " and it doesn't appear in any other extant window, then ask the
                               " user if s/he wants to abandon modifications therein.
                               if prevmod
                            "    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr(),'~'.expand("<slnum>"))
                                windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
                            "    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr,'~'.expand("<slnum>"))
                                exe prevwinnr."wincmd w"
                            
                                if bnrcnt == 1 && &hidden == 0
                                 " only one copy of the modified buffer in a window, and
                                 " hidden not set, so overwriting will lose the modified file.  Ask first...
                                 let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
                            "     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr(),'~'.expand("<slnum>"))
                                 let &ei= eikeep
                            
                                 if choice == 1
                                  " Yes -- write file & then browse
                                  let v:errmsg= ""
                                  sil w
                                  if v:errmsg != ""
                                   call netrw#ErrorMsg(s:ERROR,"unable to write <".(exists("prevbufname")? prevbufname : 'n/a').">!",30)
                                   exe origwin."wincmd w"
                                   let &ei = eikeep
                                   let @@  = ykeep
                            "       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
                                   return choice
                                  endif
                            
                                 elseif choice == 2
                                  " No -- don't worry about changed file, just browse anyway
                            "      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")",'~'.expand("<slnum>"))
                                  echomsg "**note** changes to ".prevbufname." abandoned"
                            
                                 else
                                  " Cancel -- don't do this
                            "      call Decho("cancel, don't browse, switch to win#".origwin,'~'.expand("<slnum>"))
                                  exe origwin."wincmd w"
                                  let &ei= eikeep
                                  let @@ = ykeep
                            "      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
                                  return choice
                                 endif
                                endif
                               endif
                               let &ei= eikeep
                              endif
                            
                              " restore b:netrw_curdir (window split/enew may have lost it)
                              let b:netrw_curdir= curdir
                              if a:islocal < 2
                               if a:islocal
                                call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
                               else
                                call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwPrevWinOpen ".choice)
                              return choice
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
                            "                Always assumed to be local -> remote
                            "                call s:NetrwUpload(filename, target)
                            "                call s:NetrwUpload(filename, target, fromdirectory)
    1              0.000002 fun! s:NetrwUpload(fname,tgt,...)
                            "  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)
                            
                              if a:tgt =~ '^\a\{3,}://'
                               let tgtdir= substitute(a:tgt,'^\a\{3,}://[^/]\+/\(.\{-}\)$','\1','')
                              else
                               let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
                              endif
                            "  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))
                            
                              if a:0 > 0
                               let fromdir= a:1
                              else
                               let fromdir= getcwd()
                              endif
                            "  call Decho("fromdir<".fromdir.">",'~'.expand("<slnum>"))
                            
                              if type(a:fname) == 1
                               " handle uploading a single file using NetWrite
                            "   call Decho("handle uploading a single file via NetWrite",'~'.expand("<slnum>"))
                               1split
                            "   call Decho("exe e ".fnameescape(s:NetrwFile(a:fname)),'~'.expand("<slnum>"))
                               exe "NetrwKeepj e ".fnameescape(s:NetrwFile(a:fname))
                            "   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines",'~'.expand("<slnum>"))
                               if a:tgt =~ '/$'
                                let wfname= substitute(a:fname,'^.*/','','')
                            "    call Decho("exe w! ".fnameescape(wfname),'~'.expand("<slnum>"))
                                exe "w! ".fnameescape(a:tgt.wfname)
                               else
                            "    call Decho("writing local->remote: exe w ".fnameescape(a:tgt),'~'.expand("<slnum>"))
                                exe "w ".fnameescape(a:tgt)
                            "    call Decho("done writing local->remote",'~'.expand("<slnum>"))
                               endif
                               q!
                            
                              elseif type(a:fname) == 3
                               " handle uploading a list of files via scp
                            "   call Decho("handle uploading a list of files via scp",'~'.expand("<slnum>"))
                               let curdir= getcwd()
                               if a:tgt =~ '^scp:'
                                call s:NetrwLcd(fromdir)
                                let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
                                let args    = join(map(filelist,"s:ShellEscape(v:val, 1)"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                                let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
                                let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
                                call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".args." ".s:ShellEscape(machine.":".tgt,1))
                                call s:NetrwLcd(curdir)
                            
                               elseif a:tgt =~ '^ftp:'
                                call s:NetrwMethod(a:tgt)
                            
                                if b:netrw_method == 2
                                 " handle uploading a list of files via ftp+.netrc
                                 let netrw_fname = b:netrw_fname
                                 sil NetrwKeepj new
                            "     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
                            
                                 NetrwKeepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                            
                                 if exists("g:netrw_ftpextracmd")
                                  NetrwKeepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                            
                                 if tgtdir == ""
                                  let tgtdir= '/'
                                 endif
                                 NetrwKeepj call setline(line("$")+1,'cd "'.tgtdir.'"')
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                            
                                 for fname in a:fname
                                  NetrwKeepj call setline(line("$")+1,'put "'.s:NetrwFile(fname).'"')
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endfor
                            
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
                                 else
                            "      call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
                                  call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 sil NetrwKeepj g/Local directory now/d
                                 call histdel("/",-1)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  call netrw#ErrorMsg(s:ERROR,getline(1),14)
                                 else
                                  bw!|q
                                 endif
                            
                                elseif b:netrw_method == 3
                                 " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
                                 let netrw_fname= b:netrw_fname
                                 NetrwKeepj call s:SaveBufVars()|sil NetrwKeepj new|NetrwKeepj call s:RestoreBufVars()
                                 let tmpbufnr= bufnr("%")
                                 setl ff=unix
                            
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 else
                                  NetrwKeepj put ='open '.g:netrw_machine
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 if exists("g:netrw_uid") && g:netrw_uid != ""
                                  if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                   NetrwKeepj put =g:netrw_uid
                            "       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                   if exists("s:netrw_passwd")
                                    NetrwKeepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
                                   endif
                            "       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                  elseif exists("s:netrw_passwd")
                                   NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "       call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                  endif
                                 endif
                            
                                 NetrwKeepj call setline(line("$")+1,'lcd "'.fromdir.'"')
                            "     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                            
                                 if exists("b:netrw_fname") && b:netrw_fname != ""
                                  NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 if exists("g:netrw_ftpextracmd")
                                  NetrwKeepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endif
                            
                                 for fname in a:fname
                                  NetrwKeepj call setline(line("$")+1,'put "'.fname.'"')
                            "      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
                                 endfor
                            
                                 " perform ftp:
                                 " -i       : turns off interactive prompting from ftp
                                 " -n  unix : DON'T use <.netrc>, even though it exists
                                 " -n  win32: quit being obnoxious about password
                                 NetrwKeepj norm! 1Gdd
                                 call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 sil NetrwKeepj g/Local directory now/d
                                 call histdel("/",-1)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep= &debug
                                  setl debug=msg
                                  call netrw#ErrorMsg(s:ERROR,getline(1),15)
                                  let &debug = debugkeep
                                  let mod    = 1
                                 else
                                  bw!|q
                                 endif
                                elseif !exists("b:netrw_method") || b:netrw_method < 0
                            "     call Dfunc("netrw#NetrwUpload : unsupported method")
                                 return
                                endif
                               else
                                call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwUpload")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwPreview: {{{2
    1              0.000002 fun! s:NetrwPreview(path) range
                            "  call Dfunc("NetrwPreview(path<".a:path.">)")
                              let ykeep= @@
                              NetrwKeepj call s:NetrwOptionSave("s:")
                              NetrwKeepj call s:NetrwSafeOptions()
                              if has("quickfix")
                               if !isdirectory(s:NetrwFile(a:path))
                                if g:netrw_preview && !g:netrw_alto
                                 let pvhkeep = &pvh
                                 let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                                 let &pvh    = winwidth(0) - winsz
                                endif
                                exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
                                if exists("pvhkeep")
                                 let &pvh= pvhkeep
                                endif
                               elseif !exists("g:netrw_quiet")
                                NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
                               endif
                              elseif !exists("g:netrw_quiet")
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
                              endif
                              NetrwKeepj call s:NetrwOptionRestore("s:")
                              let @@= ykeep
                            "  call Dret("NetrwPreview")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRefresh: {{{2
    1              0.000001 fun! s:NetrwRefresh(islocal,dirname)
                            "  call Dfunc("s:NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
                              " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
                              setl ma noro
                            "  call Decho("setl ma noro",'~'.expand("<slnum>"))
                            "  call Decho("clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                              let ykeep      = @@
                            
                              " save the cursor position before refresh.
                              let screenposn = winsaveview()
                            "  call Decho("saving posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
                            
                            "  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">",'~'.expand("<slnum>"))
                            "  call Decho("clearing buffer prior to refresh",'~'.expand("<slnum>"))
                              sil! NetrwKeepj %d _
                              if a:islocal
                               NetrwKeepj call netrw#LocalBrowseCheck(a:dirname)
                              else
                               NetrwKeepj call s:NetrwBrowse(a:islocal,a:dirname)
                              endif
                            
                              " restore position
                            "  call Decho("restoring posn to screenposn<".string(screenposn).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(screenposn)
                            
                              " restore file marks
                              if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("2match none  (bufnr(%)=".bufnr("%")."<".bufname("%").">)",'~'.expand("<slnum>"))
                               2match none
                              endif
                            
                            "  restore
                              let @@= ykeep
                            "  call Dret("s:NetrwRefresh")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRefreshDir: refreshes a directory by name {{{2
                            "                    Called by NetrwMarkFileCopy()
                            "                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
    1              0.000001 fun! s:NetrwRefreshDir(islocal,dirname)
                            "  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
                              if g:netrw_fastbrowse == 0
                               " slowest mode (keep buffers refreshed, local or remote)
                            "   call Decho("slowest mode: keep buffers refreshed, local or remote",'~'.expand("<slnum>"))
                               let tgtwin= bufwinnr(a:dirname)
                            "   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin,'~'.expand("<slnum>"))
                            
                               if tgtwin > 0
                                " tgtwin is being displayed, so refresh it
                                let curwin= winnr()
                            "    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")",'~'.expand("<slnum>"))
                                exe tgtwin."wincmd w"
                                NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                                exe curwin."wincmd w"
                            
                               elseif bufnr(a:dirname) > 0
                                let bn= bufnr(a:dirname)
                            "    call Decho("bd bufnr(".a:dirname.")=".bn,'~'.expand("<slnum>"))
                                exe "sil keepj bd ".bn
                               endif
                            
                              elseif g:netrw_fastbrowse <= 1
                            "   call Decho("medium-speed mode: refresh local buffers only",'~'.expand("<slnum>"))
                               NetrwKeepj call s:LocalBrowseRefresh()
                              endif
                            "  call Dret("s:NetrwRefreshDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
                            " window number to do its editing in.
                            " Supports   [count]C  where the count, if present, is used to specify
                            " a window to use for editing via the <cr> mapping.
    1              0.000001 fun! s:NetrwSetChgwin(...)
                            "  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
                              if a:0 > 0
                            "   call Decho("a:1<".a:1.">",'~'.expand("<slnum>"))
                               if a:1 == ""    " :NetrwC win#
                                let g:netrw_chgwin= winnr()
                               else              " :NetrwC
                                let g:netrw_chgwin= a:1
                               endif
                              elseif v:count > 0 " [count]C
                               let g:netrw_chgwin= v:count
                              else               " C
                               let g:netrw_chgwin= winnr()
                              endif
                              echo "editing window now set to window#".g:netrw_chgwin
                            "  call Dret("s:NetrwSetChgwin : g:netrw_chgwin=".g:netrw_chgwin)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
                            "          What this function does is to compute a priority for the patterns
                            "          in the g:netrw_sort_sequence.  It applies a substitute to any
                            "          "files" that satisfy each pattern, putting the priority / in
                            "          front.  An "*" pattern handles the default priority.
    1              0.000001 fun! s:NetrwSetSort()
                            "  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
                              let ykeep= @@
                              if w:netrw_liststyle == s:LONGLIST
                               let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
                              else
                               let seqlist  = g:netrw_sort_sequence
                              endif
                              " sanity check -- insure that * appears somewhere
                              if seqlist == ""
                               let seqlist= '*'
                              elseif seqlist !~ '\*'
                               let seqlist= seqlist.',*'
                              endif
                              let priority = 1
                              while seqlist != ""
                               if seqlist =~ ','
                                let seq     = substitute(seqlist,',.*$','','e')
                                let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
                               else
                                let seq     = seqlist
                                let seqlist = ""
                               endif
                               if priority < 10
                                let spriority= "00".priority.g:netrw_sepchr
                               elseif priority < 100
                                let spriority= "0".priority.g:netrw_sepchr
                               else
                                let spriority= priority.g:netrw_sepchr
                               endif
                            "   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">",'~'.expand("<slnum>"))
                            
                               " sanity check
                               if w:netrw_bannercnt > line("$")
                                " apparently no files were left after a Hiding pattern was used
                            "    call Dret("SetSort : no files left after hiding")
                                return
                               endif
                               if seq == '*'
                                let starpriority= spriority
                               else
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
                                call histdel("/",-1)
                                " sometimes multiple sorting patterns will match the same file or directory.
                                " The following substitute is intended to remove the excess matches.
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
                                NetrwKeepj call histdel("/",-1)
                               endif
                               let priority = priority + 1
                              endwhile
                              if exists("starpriority")
                               exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
                               NetrwKeepj call histdel("/",-1)
                              endif
                            
                              " Following line associated with priority -- items that satisfy a priority
                              " pattern get prefixed by ###/ which permits easy sorting by priority.
                              " Sometimes files can satisfy multiple priority patterns -- only the latest
                              " priority pattern needs to be retained.  So, at this point, these excess
                              " priority prefixes need to be removed, but not directories that happen to
                              " be just digits themselves.
                              exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
                              NetrwKeepj call histdel("/",-1)
                              let @@= ykeep
                            
                            "  call Dret("SetSort")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSetTgt: sets the target to the specified choice index {{{2
                            "    Implements [count]Tb  (bookhist<b>)
                            "               [count]Th  (bookhist<h>)
                            "               See :help netrw-qb for how to make the choice.
    1              0.000002 fun! s:NetrwSetTgt(islocal,bookhist,choice)
                            "  call Dfunc("s:NetrwSetTgt(islocal=".a:islocal." bookhist<".a:bookhist."> choice#".a:choice.")")
                            
                              if     a:bookhist == 'b'
                               " supports choosing a bookmark as a target using a qb-generated list
                               let choice= a:choice - 1
                               if exists("g:netrw_bookmarklist[".choice."]")
                                call netrw#MakeTgt(g:netrw_bookmarklist[choice])
                               else
                                echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
                               endif
                            
                              elseif a:bookhist == 'h'
                               " supports choosing a history stack entry as a target using a qb-generated list
                               let choice= (a:choice % g:netrw_dirhistmax) + 1
                               if exists("g:netrw_dirhist_".choice)
                                let histentry = g:netrw_dirhist_{choice}
                                call netrw#MakeTgt(histentry)
                               else
                                echomsg "Sorry, history#".a:choice." not available!"
                               endif
                              endif
                            
                              " refresh the display
                              if !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                              endif
                              call s:NetrwRefresh(a:islocal,b:netrw_curdir)
                            
                            "  call Dret("s:NetrwSetTgt")
                            endfun
                            
                            " =====================================================================
                            " s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
    1              0.000001 fun! s:NetrwSortStyle(islocal)
                            "  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
                              NetrwKeepj call s:NetrwSaveWordPosn()
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              let g:netrw_sort_by= (g:netrw_sort_by =~# '^n')? 'time' : (g:netrw_sort_by =~# '^t')? 'size' : (g:netrw_sort_by =~# '^siz')? 'exten' : 'name'
                              NetrwKeepj norm! 0
                              NetrwKeepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                            
                            "  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSplit: mode {{{2
                            "           =0 : net   and o
                            "           =1 : net   and t
                            "           =2 : net   and v
                            "           =3 : local and o
                            "           =4 : local and t
                            "           =5 : local and v
    1              0.000001 fun! s:NetrwSplit(mode)
                            "  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)
                            
                              let ykeep= @@
                              call s:SaveWinVars()
                            
                              if a:mode == 0
                               " remote and o
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                               if winsz == 0|let winsz= ""|endif
                            "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
                               exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               let s:didsplit= 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 1
                               " remote and t
                               let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
                            "   call Decho("tabnew",'~'.expand("<slnum>"))
                               tabnew
                               let s:didsplit= 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call s:NetrwBrowse(0,newdir)
                               unlet s:didsplit
                            
                              elseif a:mode == 2
                               " remote and v
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                               if winsz == 0|let winsz= ""|endif
                            "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
                               exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
                               let s:didsplit= 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 3
                               " local and o
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                               if winsz == 0|let winsz= ""|endif
                            "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s",'~'.expand("<slnum>"))
                               exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               let s:didsplit= 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 4
                               " local and t
                               let cursorword  = s:NetrwGetWord()
                               let eikeep      = &ei
                               let netrw_winnr = winnr()
                               let netrw_line  = line(".")
                               let netrw_col   = virtcol(".")
                               NetrwKeepj norm! H0
                               let netrw_hline = line(".")
                               setl ei=all
                               exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
                               exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
                               let &ei          = eikeep
                               let netrw_curdir = s:NetrwTreeDir(0)
                            "   call Decho("tabnew",'~'.expand("<slnum>"))
                               tabnew
                               let b:netrw_curdir = netrw_curdir
                               let s:didsplit     = 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
                               if &ft == "netrw"
                                setl ei=all
                                exe "NetrwKeepj norm! ".netrw_hline."G0z\<CR>"
                                exe "NetrwKeepj norm! ".netrw_line."G0".netrw_col."\<bar>"
                                let &ei= eikeep
                               endif
                               unlet s:didsplit
                            
                              elseif a:mode == 5
                               " local and v
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                               if winsz == 0|let winsz= ""|endif
                            "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v",'~'.expand("<slnum>"))
                               exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
                               let s:didsplit= 1
                               NetrwKeepj call s:RestoreWinVars()
                               NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              else
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
                              endif
                            
                              let @@= ykeep
                            "  call Dret("s:NetrwSplit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTgtMenu: {{{2
    1              0.000001 fun! s:NetrwTgtMenu()
                              if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("s:NetrwTgtMenu()")
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " try to cull duplicate entries
                               let tgtdict={}
                            
                               " target bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                            "    call Decho("installing bookmarks as easy targets",'~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 if has_key(tgtdict,bmd)
                                  let cnt= cnt + 1
                                  continue
                                 endif
                                 let tgtdict[bmd]= cnt
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                                 " show bookmarks for goto menu
                            "     call Decho("menu: Targets: ".bmd,'~'.expand("<slnum>"))
                                 exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
                                 let cnt= cnt + 1
                                endfor
                               endif
                            
                               " target directory browsing history
                               if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
                            "    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")",'~'.expand("<slnum>"))
                                let histcnt = 1
                                while histcnt <= g:netrw_dirhistmax
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{histcnt}")
                                  let histentry  = g:netrw_dirhist_{histcnt}
                                  if has_key(tgtdict,histentry)
                                   let histcnt = histcnt + 1
                                   continue
                                  endif
                                  let tgtdict[histentry] = histcnt
                                  let ehistentry         = escape(histentry,g:netrw_menu_escape)
                            "      call Decho("menu: Targets: ".histentry,'~'.expand("<slnum>"))
                                  exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
                                 endif
                                 let histcnt = histcnt + 1
                                endwhile
                               endif
                              endif
                            "  call Dret("s:NetrwTgtMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeDir: determine tree directory given current cursor position {{{2
                            " (full path directory with trailing slash returned)
    1              0.000001 fun! s:NetrwTreeDir(islocal)
                            "  call Dfunc("s:NetrwTreeDir(islocal=".a:islocal.") getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
                            "  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_treetop  =".(exists("w:netrw_treetop")?   w:netrw_treetop   : 'n/a'),'~'.expand("<slnum>"))
                            
                              if exists("s:treedir")
                               " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
                               let treedir= s:treedir
                               unlet s:treedir
                            "   call Dret("s:NetrwTreeDir ".treedir)
                               return treedir
                              endif
                            
                              if !exists("b:netrw_curdir") || b:netrw_curdir == ""
                               let b:netrw_curdir= getcwd()
                              endif
                              let treedir = b:netrw_curdir
                            "  call Decho("set initial treedir<".treedir.">",'~'.expand("<slnum>"))
                            
                              let s:treecurpos= winsaveview()
                            "  call Decho("saving posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
                            
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Decho("w:netrw_liststyle is TREELIST:",'~'.expand("<slnum>"))
                            "   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
                            
                               " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
                               let curline= substitute(getline('.'),"\t -->.*$",'','')
                               if curline =~ '/$'
                            "    call Decho("extract tree subdirectory from current line",'~'.expand("<slnum>"))
                                let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
                            "    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                               elseif curline =~ '@$'
                            "    call Decho("handle symbolic link from current line",'~'.expand("<slnum>"))
                                let treedir= resolve(substitute(substitute(getline('.'),'@.*$','','e'),'^|*\s*','','e'))
                            "    call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                               else
                            "    call Decho("do not extract tree subdirectory from current line and set treedir to empty",'~'.expand("<slnum>"))
                                let treedir= ""
                               endif
                            
                               " detect user attempting to close treeroot
                            "   call Decho("check if user is attempting to close treeroot",'~'.expand("<slnum>"))
                            "   call Decho(".win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            "   call Decho(".getline(".line(".").")<".getline('.').'> '.((getline('.') =~# '^'.s:treedepthstring)? '=~#' : '!~').' ^'.s:treedepthstring,'~'.expand("<slnum>"))
                               if curline !~ '^'.s:treedepthstring && getline('.') != '..'
                            "    call Decho(".user may have attempted to close treeroot",'~'.expand("<slnum>"))
                                " now force a refresh
                            "    call Decho(".force refresh: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                                sil! NetrwKeepj %d _
                            "    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
                                return b:netrw_curdir
                            "   else " Decho
                            "    call Decho(".user not attempting to close treeroot",'~'.expand("<slnum>"))
                               endif
                            
                            "   call Decho("islocal=".a:islocal." curline<".curline.">",'~'.expand("<slnum>"))
                               let potentialdir= s:NetrwFile(substitute(curline,'^'.s:treedepthstring.'\+ \(.*\)@$','\1',''))
                            "   call Decho("potentialdir<".potentialdir."> isdir=".isdirectory(potentialdir),'~'.expand("<slnum>"))
                            
                               " COMBAK: a symbolic link may point anywhere -- so it will be used to start a new treetop
                            "   if a:islocal && curline =~ '@$' && isdirectory(s:NetrwFile(potentialdir))
                            "    let newdir          = w:netrw_treetop.'/'.potentialdir
                            " "   call Decho("apply NetrwTreePath to newdir<".newdir.">",'~'.expand("<slnum>"))
                            "    let treedir         = s:NetrwTreePath(newdir)
                            "    let w:netrw_treetop = newdir
                            " "   call Decho("newdir <".newdir.">",'~'.expand("<slnum>"))
                            "   else
                            "    call Decho("apply NetrwTreePath to treetop<".w:netrw_treetop.">",'~'.expand("<slnum>"))
                                let treedir = s:NetrwTreePath(w:netrw_treetop)
                            "   endif
                              endif
                            
                              " sanity maintenance: keep those //s away...
                              let treedir= substitute(treedir,'//$','/','')
                            "  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                            
                            "  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".(exists("s:treecurpos")? string(s:treecurpos) : 'n/a').">")
                              return treedir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeDisplay: recursive tree display {{{2
    1              0.000003 fun! s:NetrwTreeDisplay(dir,depth)
                            "  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")
                            
                              " insure that there are no folds
                              setl nofen
                            
                              " install ../ and shortdir
                              if a:depth == ""
                               call setline(line("$")+1,'../')
                            "   call Decho("setline#".line("$")." ../ (depth is zero)",'~'.expand("<slnum>"))
                              endif
                              if a:dir =~ '^\a\{3,}://'
                               if a:dir == w:netrw_treetop
                                let shortdir= a:dir
                               else
                                let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
                               endif
                               call setline(line("$")+1,a:depth.shortdir)
                              else
                               let shortdir= substitute(a:dir,'^.*/','','e')
                               call setline(line("$")+1,a:depth.shortdir.'/')
                              endif
                            "  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">",'~'.expand("<slnum>"))
                            
                              " append a / to dir if its missing one
                              let dir= a:dir
                            
                              " display subtrees (if any)
                              let depth= s:treedepthstring.a:depth
                            "  call Decho("display subtrees with depth<".depth."> and current leaves",'~'.expand("<slnum>"))
                            
                            "  call Decho("for every entry in w:netrw_treedict[".dir."]=".string(w:netrw_treedict[dir]),'~'.expand("<slnum>"))
                              for entry in w:netrw_treedict[dir]
                               if dir =~ '/$'
                                let direntry= substitute(dir.entry,'[@/]$','','e')
                               else
                                let direntry= substitute(dir.'/'.entry,'[@/]$','','e')
                               endif
                            "   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))
                               if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
                            "    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwTreeDisplay(direntry,depth)
                               elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
                            "    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
                               elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
                            "    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwTreeDisplay(direntry.'/',depth)
                               else
                            "    call Decho("<".entry."> is not a key in treedict (no subtree)",'~'.expand("<slnum>"))
                                sil! NetrwKeepj call setline(line("$")+1,depth.entry)
                               endif
                              endfor
                            
                            "  call Dret("NetrwTreeDisplay")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRefreshTreeDict: updates the contents information for a tree (w:netrw_treedict) {{{2
    1              0.000002 fun! s:NetrwRefreshTreeDict(dir)
                            "  call Dfunc("s:NetrwRefreshTreeDict(dir<".a:dir.">)")
                              for entry in w:netrw_treedict[a:dir]
                               let direntry= substitute(a:dir.'/'.entry,'[@/]$','','e')
                            "   call Decho("a:dir<".a:dir."> entry<".entry."> direntry<".direntry.">",'~'.expand("<slnum>"))
                            
                               if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
                            "    call Decho("<".direntry."> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefreshTreeDict(direntry)
                                let liststar                   = s:NetrwGlob(direntry,'*',1)
                                let listdotstar                = s:NetrwGlob(direntry,'.*',1)
                                let w:netrw_treedict[direntry] = liststar + listdotstar
                            "    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))
                            
                               elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
                            "    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
                                let liststar   = s:NetrwGlob(direntry.'/','*',1)
                                let listdotstar= s:NetrwGlob(direntry.'/','.*',1)
                                let w:netrw_treedict[direntry]= liststar + listdotstar
                            "    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))
                            
                               elseif entry =~ '@$' && has_key(w:netrw_treedict,direntry.'@')
                            "    call Decho("<".direntry."/> is a key in treedict - display subtree for it",'~'.expand("<slnum>"))
                                NetrwKeepj call s:NetrwRefreshTreeDict(direntry.'/')
                                let liststar   = s:NetrwGlob(direntry.'/','*',1)
                                let listdotstar= s:NetrwGlob(direntry.'/','.*',1)
                            "    call Decho("updating w:netrw_treedict[".direntry.']='.string(w:netrw_treedict[direntry]),'~'.expand("<slnum>"))
                            
                               else
                            "    call Decho('not updating w:netrw_treedict['.direntry.'] with entry<'.entry.'> (no subtree)',,'~'.expand("<slnum>"))
                               endif
                              endfor
                            "  call Dret("s:NetrwRefreshTreeDict")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
                            "                     Called by s:PerformListing()
    1              0.000002 fun! s:NetrwTreeListing(dirname)
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
                            "   call Decho("curdir<".a:dirname.">",'~'.expand("<slnum>"))
                            "   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"),'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " update the treetop
                            "   call Decho("update the treetop",'~'.expand("<slnum>"))
                               if !exists("w:netrw_treetop")
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)",'~'.expand("<slnum>"))
                               elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)",'~'.expand("<slnum>"))
                               endif
                            
                               if !exists("w:netrw_treedict")
                                " insure that we have a treedict, albeit empty
                            "    call Decho("initializing w:netrw_treedict to empty",'~'.expand("<slnum>"))
                                let w:netrw_treedict= {}
                               endif
                            
                               " update the dictionary for the current directory
                            "   call Decho("updating: w:netrw_treedict[".a:dirname.'] -> [directory listing]','~'.expand("<slnum>"))
                            "   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d _'
                               let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
                            "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"
                            
                               " if past banner, record word
                               if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
                                let fname= expand("<cword>")
                               else
                                let fname= ""
                               endif
                            "   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " display from treetop on down
                               NetrwKeepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
                            "   call Decho("s:NetrwTreeDisplay) setl noma nomod ro",'~'.expand("<slnum>"))
                            
                               " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
                               while getline(1) =~ '^\s*$' && byte2line(1) > 0
                            "    call Decho("deleting blank line",'~'.expand("<slnum>"))
                                1d
                               endwhile
                            
                               exe "setl ".g:netrw_bufsettings
                            
                            "   call Dret("NetrwTreeListing : bufname<".expand("%").">")
                               return
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreePath: returns path to current file in tree listing {{{2
                            "                  Normally, treetop is w:netrw_treetop, but a
                            "                  user of the function ( netrw#SetTreetop() )
                            "                  wipes that out prior to calling this function
    1              0.000002 fun! s:NetrwTreePath(treetop)
                            "  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
                              let svpos = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
                            "  call Decho("depth<".depth."> 1st subst",'~'.expand("<slnum>"))
                              let depth = substitute(depth,'^'.s:treedepthstring,'','')
                            "  call Decho("depth<".depth."> 2nd subst (first depth removed)",'~'.expand("<slnum>"))
                              let curline= getline('.')
                            "  call Decho("curline<".curline.'>','~'.expand("<slnum>"))
                              if curline =~ '/$'
                            "   call Decho("extract tree directory from current line",'~'.expand("<slnum>"))
                               let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
                            "   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                              elseif curline =~ '@\s\+-->'
                            "   call Decho("extract tree directory using symbolic link",'~'.expand("<slnum>"))
                               let treedir= substitute(curline,'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
                               let treedir= substitute(treedir,'@\s\+-->.*$','','e')
                            "   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
                              else
                            "   call Decho("do not extract tree directory from current line and set treedir to empty",'~'.expand("<slnum>"))
                               let treedir= ""
                              endif
                              " construct treedir by searching backwards at correct depth
                            "  call Decho("construct treedir by searching backwards for correct depth",'~'.expand("<slnum>"))
                            "  call Decho("initial      treedir<".treedir."> depth<".depth.">",'~'.expand("<slnum>"))
                              while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
                               let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
                               let treedir= dirname.treedir
                               let depth  = substitute(depth,'^'.s:treedepthstring,'','')
                            "   call Decho("constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">",'~'.expand("<slnum>"))
                              endwhile
                              if a:treetop =~ '/$'
                               let treedir= a:treetop.treedir
                              else
                               let treedir= a:treetop.'/'.treedir
                              endif
                              let treedir= substitute(treedir,'//$','/','')
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
                              call winrestview(svpos)
                            "  call Dret("s:NetrwTreePath <".treedir.">")
                              return treedir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwWideListing: {{{2
    1              0.000001 fun! s:NetrwWideListing()
                            
                              if w:netrw_liststyle == s:WIDELIST
                            "   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
                               " look for longest filename (cpf=characters per filename)
                               " cpf: characters per filename
                               " fpl: filenames per line
                               " fpc: filenames per column
                               setl ma noro
                            "   call Decho("setl ma noro",'~'.expand("<slnum>"))
                               let b:netrw_cpf= 0
                               if line("$") >= w:netrw_bannercnt
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                NetrwKeepj call histdel("/",-1)
                               else
                            "    call Dret("NetrwWideListing")
                                return
                               endif
                               let b:netrw_cpf= b:netrw_cpf + 2
                            "   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf,'~'.expand("<slnum>"))
                            
                               " determine qty files per line (fpl)
                               let w:netrw_fpl= winwidth(0)/b:netrw_cpf
                               if w:netrw_fpl <= 0
                                let w:netrw_fpl= 1
                               endif
                            "   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl,'~'.expand("<slnum>"))
                            
                               " make wide display
                               "   fpc: files per column of wide listing
                               exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'S",submatch(0)),"\\")/'
                               NetrwKeepj call histdel("/",-1)
                               let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
                               let newcolstart = w:netrw_bannercnt + fpc
                               let newcolend   = newcolstart + fpc - 1
                            "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]",'~'.expand("<slnum>"))
                               if has("clipboard")
                                sil! let keepregstar = @*
                                sil! let keepregplus = @+
                               endif
                               while line("$") >= newcolstart
                                if newcolend > line("$") | let newcolend= line("$") | endif
                                let newcolqty= newcolend - newcolstart
                                exe newcolstart
                                if newcolqty == 0
                                 exe "sil! NetrwKeepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
                                else
                                 exe "sil! NetrwKeepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
                                endif
                                exe "sil! NetrwKeepj ".newcolstart.','.newcolend.'d _'
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt
                               endwhile
                               if has("clipboard")
                                sil! let @*= keepregstar
                                sil! let @+= keepregplus
                               endif
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/\s\+$//e'
                               NetrwKeepj call histdel("/",-1)
                               exe 'nno <buffer> <silent> w	:call search(''^.\\|\s\s\zs\S'',''W'')'."\<cr>"
                               exe 'nno <buffer> <silent> b	:call search(''^.\\|\s\s\zs\S'',''bW'')'."\<cr>"
                            "   call Decho("NetrwWideListing) setl noma nomod ro",'~'.expand("<slnum>"))
                               exe "setl ".g:netrw_bufsettings
                            "   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("NetrwWideListing")
                               return
                              else
                               if hasmapto("w","n")
                                sil! nunmap <buffer> w
                               endif
                               if hasmapto("b","n")
                                sil! nunmap <buffer> b
                               endif
                              endif
                            
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:PerformListing: {{{2
    1              0.000002 fun! s:PerformListing(islocal)
                            "  call Dfunc("s:PerformListing(islocal=".a:islocal.")")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Decho("settings: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)",'~'.expand("<slnum>"))
                            
                              " set up syntax highlighting {{{3
                            "  call Decho("--set up syntax highlighting (ie. setl ft=netrw)",'~'.expand("<slnum>"))
                              sil! setl ft=netrw
                            
                              NetrwKeepj call s:NetrwSafeOptions()
                              setl noro ma
                            "  call Decho("setl noro ma bh=".&bh,'~'.expand("<slnum>"))
                            
                            "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
                            "   call Decho("(netrw) Processing your browsing request...",'~'.expand("<slnum>"))
                            "  endif								" Decho
                            
                            "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " force a refresh for tree listings
                            "   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                               sil! NetrwKeepj %d _
                              endif
                            
                              " save current directory on directory history list
                              NetrwKeepj call s:NetrwBookHistHandler(3,b:netrw_curdir)
                            
                              " Set up the banner {{{3
                              if g:netrw_banner
                            "   call Decho("--set up banner",'~'.expand("<slnum>"))
                               NetrwKeepj call setline(1,'" ============================================================================')
                               if exists("g:netrw_pchk")
                                " this undocumented option allows pchk to run with different versions of netrw without causing spurious
                                " failure detections.
                                NetrwKeepj call setline(2,'" Netrw Directory Listing')
                               else
                                NetrwKeepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
                               endif
                               if exists("g:netrw_pchk")
                                let curdir= substitute(b:netrw_curdir,expand("$HOME"),'~','')
                               else
                                let curdir= b:netrw_curdir
                               endif
                               if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
                                NetrwKeepj call setline(3,'"   '.substitute(curdir,'/','\\','g'))
                               else
                                NetrwKeepj call setline(3,'"   '.curdir)
                               endif
                               let w:netrw_bannercnt= 3
                               NetrwKeepj exe "sil! NetrwKeepj ".w:netrw_bannercnt
                              else
                            "   call Decho("--no banner",'~'.expand("<slnum>"))
                               NetrwKeepj 1
                               let w:netrw_bannercnt= 1
                              endif
                            "  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr(),'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            
                              let sortby= g:netrw_sort_by
                              if g:netrw_sort_direction =~# "^r"
                               let sortby= sortby." reversed"
                              endif
                            
                              " Sorted by... {{{3
                              if g:netrw_banner
                            "   call Decho("--handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
                               if g:netrw_sort_by =~# "^n"
                            "   call Decho("directories will be sorted by name",'~'.expand("<slnum>"))
                                " sorted by name
                                NetrwKeepj put ='\"   Sorted by      '.sortby
                                NetrwKeepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
                                let w:netrw_bannercnt= w:netrw_bannercnt + 2
                               else
                            "   call Decho("directories will be sorted by size or time",'~'.expand("<slnum>"))
                                " sorted by size or date
                                NetrwKeepj put ='\"   Sorted by '.sortby
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                              endif
                            
                              " show copy/move target, if any
                              if g:netrw_banner
                               if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
                            "    call Decho("--show copy/move target<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                                NetrwKeepj put =''
                                if s:netrwmftgt_islocal
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
                                else
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               else
                            "    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt",'~'.expand("<slnum>"))
                               endif
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt
                              endif
                            
                              " Hiding...  -or-  Showing... {{{3
                              if g:netrw_banner
                            "   call Decho("--handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)",'~'.expand("<slnum>"))
                               if g:netrw_list_hide != "" && g:netrw_hide
                                if g:netrw_hide == 1
                                 NetrwKeepj put ='\"   Hiding:        '.g:netrw_list_hide
                                else
                                 NetrwKeepj put ='\"   Showing:       '.g:netrw_list_hide
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
                               exe "NetrwKeepj ".w:netrw_bannercnt
                            
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
                            "   call Decho("quickhelp   =".quickhelp,'~'.expand("<slnum>"))
                               NetrwKeepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               NetrwKeepj put ='\" =============================================================================='
                               let w:netrw_bannercnt= w:netrw_bannercnt + 2
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                              endif
                            
                              " bannercnt should index the line just after the banner
                              if g:netrw_banner
                               let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "   call Decho("--w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"),'~'.expand("<slnum>"))
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                              endif
                            
                              " get list of files
                            "  call Decho("--Get list of files - islocal=".a:islocal,'~'.expand("<slnum>"))
                              if a:islocal
                               NetrwKeepj call s:LocalListing()
                              else " remote
                               NetrwKeepj let badresult= s:NetrwRemoteListing()
                               if badresult
                            "    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            "    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
                                return
                               endif
                              endif
                            
                              " manipulate the directory listing (hide, sort) {{{3
                              if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= 0
                              endif
                            "  call Decho("--manipulate directory listing (hide, sort)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "   call Decho("manipulate directory listing (hide)",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
                               if g:netrw_hide && g:netrw_list_hide != ""
                                NetrwKeepj call s:NetrwListHide()
                               endif
                               if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
                            
                                if g:netrw_sort_by =~# "^n"
                                 " sort by name
                                 NetrwKeepj call s:NetrwSetSort()
                            
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                                   " normal direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 endif
                                 " remove priority pattern prefix
                            "     call Decho("remove priority pattern prefix",'~'.expand("<slnum>"))
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
                                 NetrwKeepj call histdel("/",-1)
                            
                                elseif g:netrw_sort_by =~# "^ext"
                                 " sort by extension
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g+/+s/^/001'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+[./]+s/^/002'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+['.g:netrw_sepchr.'/]+s/^\(.*\.\)\(.\{-\}\)$/\2'.g:netrw_sepchr.'&/e'
                                 NetrwKeepj call histdel("/",-1)
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                                   " normal direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 endif
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^.\{-}'.g:netrw_sepchr.'//e'
                                 NetrwKeepj call histdel("/",-1)
                            
                                elseif a:islocal
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction,'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort!','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
                                 NetrwKeepj call histdel("/",-1)
                                 endif
                                endif
                            
                               elseif g:netrw_sort_direction =~# 'r'
                            "    call Decho('(s:PerformListing) reverse the sorted listing','~'.expand("<slnum>"))
                                if !g:netrw_banner || w:netrw_bannercnt < line('$')
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
                                 call histdel("/",-1)
                                endif
                               endif
                              endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " convert to wide/tree listing {{{3
                            "  call Decho("--modify display if wide/tree listing style",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwWideListing()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwTreeListing(b:netrw_curdir)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)",'~'.expand("<slnum>"))
                            
                              " resolve symbolic links if local and (thin or tree)
                              if a:islocal && (w:netrw_liststyle == s:THINLIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST))
                            "   call Decho("--resolve symbolic links if local and thin|tree",'~'.expand("<slnum>"))
                               g/@$/call s:ShowLink()
                              endif
                            
                              if exists("w:netrw_bannercnt") && (line("$") >= w:netrw_bannercnt || !g:netrw_banner)
                               " place cursor on the top-left corner of the file listing
                            "   call Decho("--place cursor on top-left corner of file listing",'~'.expand("<slnum>"))
                               exe 'sil! '.w:netrw_bannercnt
                               sil! NetrwKeepj norm! 0
                            "   call Decho("  tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                              else
                            "   call Decho("--did NOT place cursor on top-left corner",'~'.expand("<slnum>"))
                            "   call Decho("  w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'),'~'.expand("<slnum>"))
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
                            "   call Decho("  g:netrw_banner=".(exists("g:netrw_banner")? g:netrw_banner : 'n/a'),'~'.expand("<slnum>"))
                              endif
                            
                              " record previous current directory
                              let w:netrw_prvdir= b:netrw_curdir
                            "  call Decho("--record netrw_prvdir<".w:netrw_prvdir.">",'~'.expand("<slnum>"))
                            
                              " save certain window-oriented variables into buffer-oriented variables {{{3
                            "  call Decho("--save some window-oriented variables into buffer oriented variables",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)",'~'.expand("<slnum>"))
                              NetrwKeepj call s:SetBufWinVars()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwOptionRestore("w:")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)",'~'.expand("<slnum>"))
                            
                              " set display to netrw display settings
                            "  call Decho("--set display to netrw display settings (".g:netrw_bufsettings.")",'~'.expand("<slnum>"))
                              exe "setl ".g:netrw_bufsettings
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)",'~'.expand("<slnum>"))
                              if g:netrw_liststyle == s:LONGLIST
                            "   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
                               exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              endif
                            
                              if exists("s:treecurpos")
                            "   call Decho("s:treecurpos exists; restore posn",'~'.expand("<slnum>"))
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)",'~'.expand("<slnum>"))
                            "   call Decho("restoring posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(s:treecurpos)
                               unlet s:treecurpos
                              endif
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)",'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetupNetrwStatusLine: {{{2
    1              0.000003 fun! s:SetupNetrwStatusLine(statline)
                            "  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")
                            
                              if !exists("s:netrw_setup_statline")
                               let s:netrw_setup_statline= 1
                            "   call Decho("do first-time status line setup",'~'.expand("<slnum>"))
                            
                               if !exists("s:netrw_users_stl")
                                let s:netrw_users_stl= &stl
                               endif
                               if !exists("s:netrw_users_ls")
                                let s:netrw_users_ls= &laststatus
                               endif
                            
                               " set up User9 highlighting as needed
                               let keepa= @a
                               redir @a
                               try
                                hi User9
                               catch /^Vim\%((\a\{3,})\)\=:E411/
                                if &bg == "dark"
                                 hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
                                else
                                 hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
                                endif
                               endtry
                               redir END
                               let @a= keepa
                              endif
                            
                              " set up status line (may use User9 highlighting)
                              " insure that windows have a statusline
                              " make sure statusline is displayed
                              let &stl=a:statline
                              setl laststatus=2
                            "  call Decho("stl=".&stl,'~'.expand("<slnum>"))
                              redraw
                            
                            "  call Dret("SetupNetrwStatusLine : stl=".&stl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Remote Directory Browsing Support:    {{{1
                            " ===========================================
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
                            "  This function assumes that a long listing will be received.  Size, time,
                            "  and reverse sorts will be requested of the server but not otherwise
                            "  enforced here.
    1              0.000002 fun! s:NetrwRemoteFtpCmd(path,listcmd)
                            "  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
                            "  call Decho("line($)=".line("$")." win#".winnr()." w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                              " sanity check: {{{3
                              if !exists("w:netrw_method")
                               if exists("b:netrw_method")
                                let w:netrw_method= b:netrw_method
                               else
                                call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
                            "    call Dret("NetrwRemoteFtpCmd")
                                return
                               endif
                              endif
                            
                              " WinXX ftp uses unix style input, so set ff to unix	" {{{3
                              let ffkeep= &ff
                              setl ma ff=unix noro
                            "  call Decho("setl ma ff=unix noro",'~'.expand("<slnum>"))
                            
                              " clear off any older non-banner lines	" {{{3
                              " note that w:netrw_bannercnt indexes the line after the banner
                            "  call Decho('exe sil! NetrwKeepj '.w:netrw_bannercnt.",$d _  (clear off old non-banner lines)",'~'.expand("<slnum>"))
                              exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"
                            
                              ".........................................
                              if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
                               " ftp + <.netrc>:  Method #2
                               if a:path != ""
                                NetrwKeepj put ='cd \"'.a:path.'\"'
                               endif
                               if exists("g:netrw_ftpextracmd")
                                NetrwKeepj put =g:netrw_ftpextracmd
                            "    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call setline(line("$")+1,a:listcmd)
                            "   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
                               if exists("g:netrw_port") && g:netrw_port != ""
                            "    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1),'~'.expand("<slnum>"))
                                exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1)
                               else
                            "    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1),'~'.expand("<slnum>"))
                                exe s:netrw_silentxfer." NetrwKeepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)
                               endif
                            
                              ".........................................
                              elseif w:netrw_method == 3	" {{{3
                               " ftp + machine,id,passwd,filename:  Method #3
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                else
                                 NetrwKeepj put ='open '.g:netrw_machine
                                endif
                            
                                " handle userid and password
                                let host= substitute(g:netrw_machine,'\..*$','','')
                            "    call Decho("host<".host.">",'~'.expand("<slnum>"))
                                if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
                                 call NetUserPass("ftp:".host)
                                endif
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  NetrwKeepj put =g:netrw_uid
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                                 elseif exists("s:netrw_passwd")
                                  NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                                 endif
                                endif
                            
                               if a:path != ""
                                NetrwKeepj put ='cd \"'.a:path.'\"'
                               endif
                               if exists("g:netrw_ftpextracmd")
                                NetrwKeepj put =g:netrw_ftpextracmd
                            "    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call setline(line("$")+1,a:listcmd)
                            
                               " perform ftp:
                               " -i       : turns off interactive prompting from ftp
                               " -n  unix : DON'T use <.netrc>, even though it exists
                               " -n  win32: quit being obnoxious about password
                               if exists("w:netrw_bannercnt")
                            "    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."),''~''.expand("<slnum>"))'
                                call s:NetrwExe(s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                            "   else " Decho
                            "    call Decho("WARNING: w:netrw_bannercnt doesn't exist!",'~'.expand("<slnum>"))
                            "    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline("."),'~'.expand("<slnum>"))
                               endif
                            
                              ".........................................
                              elseif w:netrw_method == 9	" {{{3
                               " sftp username@machine: Method #9
                               " s:netrw_sftp_cmd
                               setl ff=unix
                            
                               " restore settings
                               let &ff= ffkeep
                            "   call Dret("NetrwRemoteFtpCmd")
                               return
                            
                              ".........................................
                              else	" {{{3
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
                              endif
                            
                              " cleanup for Windows " {{{3
                              if has("win32") || has("win95") || has("win64") || has("win16")
                               sil! NetrwKeepj %s/\r$//e
                               NetrwKeepj call histdel("/",-1)
                              endif
                              if a:listcmd == "dir"
                               " infer directory/link based on the file permission string
                               sil! NetrwKeepj g/d\%([-r][-w][-x]\)\{3}/NetrwKeepj s@$@/@e
                               sil! NetrwKeepj g/l\%([-r][-w][-x]\)\{3}/NetrwKeepj s/$/@/e
                               NetrwKeepj call histdel("/",-1)
                               NetrwKeepj call histdel("/",-1)
                               if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
                                exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
                                NetrwKeepj call histdel("/",-1)
                               endif
                              endif
                            
                              " ftp's listing doesn't seem to include ./ or ../ " {{{3
                              if !search('^\.\/$\|\s\.\/$','wn')
                               exe 'NetrwKeepj '.w:netrw_bannercnt
                               NetrwKeepj put ='./'
                              endif
                              if !search('^\.\.\/$\|\s\.\.\/$','wn')
                               exe 'NetrwKeepj '.w:netrw_bannercnt
                               NetrwKeepj put ='../'
                              endif
                            
                              " restore settings " {{{3
                              let &ff= ffkeep
                            "  call Dret("NetrwRemoteFtpCmd")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteListing: {{{2
    1              0.000002 fun! s:NetrwRemoteListing()
                            "  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">) win#".winnr())
                            
                              if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
                               let w:netrw_bannercnt= s:bannercnt
                              endif
                              if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
                               let w:netrw_bannercnt= s:bannercnt
                              endif
                            
                              call s:RemotePathAnalysis(b:netrw_curdir)
                            
                              " sanity check:
                              if exists("b:netrw_method") && b:netrw_method =~ '[235]'
                            "   call Decho("b:netrw_method=".b:netrw_method,'~'.expand("<slnum>"))
                               if !executable("ftp")
                            "    call Decho("ftp is not executable",'~'.expand("<slnum>"))
                                if !exists("g:netrw_quiet")
                                 call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
                                endif
                                call s:NetrwOptionRestore("w:")
                            "    call Dret("s:NetrwRemoteListing -1")
                                return -1
                               endif
                            
                              elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
                            "   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">",'~'.expand("<slnum>"))
                               if !exists("g:netrw_quiet")
                                if g:netrw_list_cmd == ""
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
                                else
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
                                endif
                               endif
                            
                               NetrwKeepj call s:NetrwOptionRestore("w:")
                            "   call Dret("s:NetrwRemoteListing -1")
                               return -1
                              endif  " (remote handling sanity check)
                            "  call Decho("passed remote listing sanity checks",'~'.expand("<slnum>"))
                            
                              if exists("b:netrw_method")
                            "   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">",'~'.expand("<slnum>"))
                               let w:netrw_method= b:netrw_method
                              endif
                            
                              if s:method == "ftp"
                               " use ftp to get remote file listing {{{3
                            "   call Decho("use ftp to get remote file listing",'~'.expand("<slnum>"))
                               let s:method  = "ftp"
                               let listcmd = g:netrw_ftp_list_cmd
                               if g:netrw_sort_by =~# '^t'
                                let listcmd= g:netrw_ftp_timelist_cmd
                               elseif g:netrw_sort_by =~# '^s'
                                let listcmd= g:netrw_ftp_sizelist_cmd
                               endif
                            "   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)",'~'.expand("<slnum>"))
                               call s:NetrwRemoteFtpCmd(s:path,listcmd)
                            "   exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."),''~''.expand("<slnum>"))'
                            
                               " report on missing file or directory messages
                               if search('[Nn]o such file or directory\|Failed to change directory')
                                let mesg= getline(".")
                                if exists("w:netrw_bannercnt")
                                 setl ma
                                 exe w:netrw_bannercnt.",$d _"
                                 setl noma
                                endif
                                NetrwKeepj call s:NetrwOptionRestore("w:")
                                call netrw#ErrorMsg(s:WARNING,mesg,96)
                            "    call Dret("s:NetrwRemoteListing : -1")
                                return -1
                               endif
                            
                               if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST)
                                " shorten the listing
                            "    call Decho("generate short listing",'~'.expand("<slnum>"))
                                exe "sil! keepalt NetrwKeepj ".w:netrw_bannercnt
                            
                                " cleanup
                                if g:netrw_ftp_browse_reject != ""
                                 exe "sil! keepalt NetrwKeepj g/".g:netrw_ftp_browse_reject."/NetrwKeepj d"
                                 NetrwKeepj call histdel("/",-1)
                                endif
                                sil! NetrwKeepj %s/\r$//e
                                NetrwKeepj call histdel("/",-1)
                            
                                " if there's no ../ listed, then put ../ in
                                let line1= line(".")
                                exe "sil! NetrwKeepj ".w:netrw_bannercnt
                                let line2= search('\.\.\/\%(\s\|$\)','cnW')
                            "    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                                if line2 == 0
                            "     call Decho("netrw is putting ../ into listing",'~'.expand("<slnum>"))
                                 sil! NetrwKeepj put='../'
                                endif
                                exe "sil! NetrwKeepj ".line1
                                sil! NetrwKeepj norm! 0
                            
                            "    call Decho("line1=".line1." line2=".line2." line(.)=".line("."),'~'.expand("<slnum>"))
                                if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
                            "     call Decho("M$ ftp cleanup",'~'.expand("<slnum>"))
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
                                 NetrwKeepj call histdel("/",-1)
                                else " normal ftp cleanup
                            "     call Decho("normal ftp cleanup",'~'.expand("<slnum>"))
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
                                 exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
                                 exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
                                 NetrwKeepj call histdel("/",-1)
                                 NetrwKeepj call histdel("/",-1)
                                 NetrwKeepj call histdel("/",-1)
                                endif
                               endif
                            
                               else
                               " use ssh to get remote file listing {{{3
                            "   call Decho("use ssh to get remote file listing: s:path<".s:path.">",'~'.expand("<slnum>"))
                               let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
                            "   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)",'~'.expand("<slnum>"))
                               if g:netrw_scp_cmd =~ '^pscp'
                            "    call Decho("1: exe r! ".s:ShellEscape(listcmd.s:path, 1),'~'.expand("<slnum>"))
                                exe "NetrwKeepj r! ".listcmd.s:ShellEscape(s:path, 1)
                                " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
                                sil! NetrwKeepj g/^Listing directory/NetrwKeepj d
                                sil! NetrwKeepj g/^d[-rwx][-rwx][-rwx]/NetrwKeepj s+$+/+e
                                sil! NetrwKeepj g/^l[-rwx][-rwx][-rwx]/NetrwKeepj s+$+@+e
                                NetrwKeepj call histdel("/",-1)
                                NetrwKeepj call histdel("/",-1)
                                NetrwKeepj call histdel("/",-1)
                                if g:netrw_liststyle != s:LONGLIST
                                 sil! NetrwKeepj g/^[dlsp-][-rwx][-rwx][-rwx]/NetrwKeepj s/^.*\s\(\S\+\)$/\1/e
                                 NetrwKeepj call histdel("/",-1)
                                endif
                               else
                                if s:path == ""
                            "     call Decho("2: exe r! ".listcmd,'~'.expand("<slnum>"))
                                 exe "NetrwKeepj keepalt r! ".listcmd
                                else
                            "     call Decho("3: exe r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1),'~'.expand("<slnum>"))
                                 exe "NetrwKeepj keepalt r! ".listcmd.' '.s:ShellEscape(fnameescape(s:path),1)
                            "     call Decho("listcmd<".listcmd."> path<".s:path.">",'~'.expand("<slnum>"))
                                endif
                               endif
                            
                               " cleanup
                               if g:netrw_ssh_browse_reject != ""
                            "    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d",'~'.expand("<slnum>"))
                                exe "sil! g/".g:netrw_ssh_browse_reject."/NetrwKeepj d"
                                NetrwKeepj call histdel("/",-1)
                               endif
                              endif
                            
                              if w:netrw_liststyle == s:LONGLIST
                               " do a long listing; these substitutions need to be done prior to sorting {{{3
                            "   call Decho("fix long listing:",'~'.expand("<slnum>"))
                            
                               if s:method == "ftp"
                                " cleanup
                                exe "sil! NetrwKeepj ".w:netrw_bannercnt
                                while getline('.') =~# g:netrw_ftp_browse_reject
                                 sil! NetrwKeepj d
                                endwhile
                                " if there's no ../ listed, then put ../ in
                                let line1= line(".")
                                sil! NetrwKeepj 1
                                sil! NetrwKeepj call search('^\.\.\/\%(\s\|$\)','W')
                                let line2= line(".")
                                if line2 == 0
                                 if b:netrw_curdir != '/'
                                  exe 'sil! NetrwKeepj '.w:netrw_bannercnt."put='../'"
                                 endif
                                endif
                                exe "sil! NetrwKeepj ".line1
                                sil! NetrwKeepj norm! 0
                               endif
                            
                               if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
                            "    call Decho("M$ ftp site listing cleanup",'~'.expand("<slnum>"))
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
                               elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
                            "    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2 \t\1/e'
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt
                                NetrwKeepj call histdel("/",-1)
                                NetrwKeepj call histdel("/",-1)
                                NetrwKeepj call histdel("/",-1)
                               endif
                              endif
                            
                            "  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
                            "   exe "NetrwKeepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."),''~''.expand("<slnum>"))'
                            "  endif " Decho
                            
                            "  call Dret("s:NetrwRemoteListing 0")
                              return 0
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
    1              0.000006 fun! s:NetrwRemoteRm(usrhost,path) range
                            "  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
                            "  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))
                              let svpos= winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              let all= 0
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               " remove all marked files
                            "   call Decho("remove all marked files with bufnr#".bufnr("%"),'~'.expand("<slnum>"))
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                                let ok= s:NetrwRemoteRmFile(a:path,fname,all)
                                if ok =~# 'q\%[uit]'
                                 break
                                elseif ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endfor
                               call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                            
                              else
                               " remove files specified by range
                            "   call Decho("remove files specified by range",'~'.expand("<slnum>"))
                            
                               " preparation for removing multiple files/directories
                               let keepsol = &l:sol
                               setl nosol
                               let ctr    = a:firstline
                            
                               " remove multiple files and directories
                               while ctr <= a:lastline
                                exe "NetrwKeepj ".ctr
                                let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
                                if ok =~# 'q\%[uit]'
                                 break
                                elseif ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                                let ctr= ctr + 1
                               endwhile
                               let &l:sol = keepsol
                              endif
                            
                              " refresh the (remote) directory listing
                            "  call Decho("refresh remote directory listing",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                            
                            "  call Dret("s:NetrwRemoteRm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRmFile: {{{2
    1              0.000003 fun! s:NetrwRemoteRmFile(path,rmfile,all)
                            "  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)
                            
                              let all= a:all
                              let ok = ""
                            
                              if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
                               " attempt to remove file
                            "    call Decho("attempt to remove file (all=".all.")",'~'.expand("<slnum>"))
                               if !all
                                echohl Statement
                            "    call Decho("case all=0:",'~'.expand("<slnum>"))
                                call inputsave()
                                let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                echohl NONE
                                if ok == ""
                                 let ok="no"
                                endif
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~# 'y\%[es]' || ok == ""
                            "    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""),'~'.expand("<slnum>"))
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                            "     call Decho("case ftp:",'~'.expand("<slnum>"))
                                 let path= a:path
                                 if path =~ '^\a\{3,}://'
                                  let path= substitute(path,'^\a\{3,}://[^/]\+/','','')
                                 endif
                                 sil! NetrwKeepj .,$d _
                                 call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
                                else
                            "     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">",'~'.expand("<slnum>"))
                                 let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
                            "     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
                                 if !exists("b:netrw_curdir")
                                  NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
                                  let ok="q"
                                 else
                                  let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
                            "      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">",'~'.expand("<slnum>"))
                            "      call Decho("remotedir<".remotedir.">",'~'.expand("<slnum>"))
                            "      call Decho("rmfile<".a:rmfile.">",'~'.expand("<slnum>"))
                                  if remotedir != ""
                                   let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(remotedir.a:rmfile))
                                  else
                                   let netrw_rm_cmd= netrw_rm_cmd." ".s:ShellEscape(fnameescape(a:rmfile))
                                  endif
                            "      call Decho("call system(".netrw_rm_cmd.")",'~'.expand("<slnum>"))
                                  let ret= system(netrw_rm_cmd)
                                  if v:shell_error != 0
                                   if exists("b:netrw_curdir") && b:netrw_curdir != getcwd() && !g:netrw_keepdir
                                    call netrw#ErrorMsg(s:ERROR,"remove failed; perhaps due to vim's current directory<".getcwd()."> not matching netrw's (".b:netrw_curdir.") (see :help netrw-c)",102)
                                   else
                                    call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
                                   endif
                                  elseif ret != 0
                                   call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
                                  endif
                            "      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))
                                 endif
                                endif
                               elseif ok =~# 'q\%[uit]'
                            "    call Decho("ok==".ok,'~'.expand("<slnum>"))
                               endif
                            
                              else
                               " attempt to remove directory
                            "    call Decho("attempt to remove directory",'~'.expand("<slnum>"))
                               if !all
                                call inputsave()
                                let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                if ok == ""
                                 let ok="no"
                                endif
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~# 'y\%[es]' || ok == ""
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
                                else
                                 let rmfile          = substitute(a:path.a:rmfile,'/$','','')
                                 let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.s:ShellEscape(netrw#WinPath(rmfile))
                            "      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")",'~'.expand("<slnum>"))
                                 let ret= system(netrw_rmdir_cmd)
                            "      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))
                            
                                 if v:shell_error != 0
                            "      call Decho("v:shell_error not 0",'~'.expand("<slnum>"))
                                  let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.s:ShellEscape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
                            "      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")",'~'.expand("<slnum>"))
                                  let ret= system(netrw_rmf_cmd)
                            "      call Decho("returned=".ret." errcode=".v:shell_error,'~'.expand("<slnum>"))
                            
                                  if v:shell_error != 0 && !exists("g:netrw_quiet")
                                  	NetrwKeepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
                                  endif
                                 endif
                                endif
                            
                               elseif ok =~# 'q\%[uit]'
                            "    call Decho("ok==".ok,'~'.expand("<slnum>"))
                               endif
                              endif
                            
                            "  call Dret("s:NetrwRemoteRmFile ".ok)
                              return ok
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRename: rename a remote file or directory {{{2
    1              0.000002 fun! s:NetrwRemoteRename(usrhost,path) range
                            "  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")
                            
                              " preparation for removing multiple files/directories
                              let svpos      = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              let ctr        = a:firstline
                              let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)
                            
                              " rename files given by the markfilelist
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               for oldname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
                                if exists("subfrom")
                                 let newname= substitute(oldname,subfrom,subto,'')
                            "     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
                                else
                                 call inputsave()
                                 let newname= input("Moving ".oldname." to : ",oldname)
                                 call inputrestore()
                                 if newname =~ '^s/'
                                  let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
                                  let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
                                  let newname = substitute(oldname,subfrom,subto,'')
                            "      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
                                 endif
                                endif
                            
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 NetrwKeepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
                                else
                                 let oldname= s:ShellEscape(a:path.oldname)
                                 let newname= s:ShellEscape(a:path.newname)
                            "     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
                                 let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
                                endif
                            
                               endfor
                               call s:NetrwUnMarkFile(1)
                            
                              else
                            
                              " attempt to rename files/directories
                               let keepsol= &l:sol
                               setl nosol
                               while ctr <= a:lastline
                                exe "NetrwKeepj ".ctr
                            
                                let oldname= s:NetrwGetWord()
                            "   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
                            
                                call inputsave()
                                let newname= input("Moving ".oldname." to : ",oldname)
                                call inputrestore()
                            
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
                                else
                                 let oldname= s:ShellEscape(a:path.oldname)
                                 let newname= s:ShellEscape(a:path.newname)
                            "     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")",'~'.expand("<slnum>"))
                                 let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
                                endif
                            
                                let ctr= ctr + 1
                               endwhile
                               let &l:sol= keepsol
                              endif
                            
                              " refresh the directory
                              NetrwKeepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                            
                            "  call Dret("NetrwRemoteRename")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Local Directory Browsing Support:    {{{1
                            " ==========================================
                            
                            " ---------------------------------------------------------------------
                            " netrw#FileUrlRead: handles reading file://* files {{{2
                            "   Should accept:   file://localhost/etc/fstab
                            "                    file:///etc/fstab
                            "                    file:///c:/WINDOWS/clock.avi
                            "                    file:///c|/WINDOWS/clock.avi
                            "                    file://localhost/c:/WINDOWS/clock.avi
                            "                    file://localhost/c|/WINDOWS/clock.avi
                            "                    file://c:/foo.txt
                            "                    file:///c:/foo.txt
                            " and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
    1              0.000002 fun! netrw#FileUrlRead(fname)
                            "  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
                              let fname = a:fname
                              if fname =~ '^file://localhost/'
                            "   call Decho('converting file://localhost/   -to-  file:///','~'.expand("<slnum>"))
                               let fname= substitute(fname,'^file://localhost/','file:///','')
                            "   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                              endif
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                               if fname  =~ '^file:///\=\a[|:]/'
                            "    call Decho('converting file:///\a|/   -to-  file://\a:/','~'.expand("<slnum>"))
                                let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
                            "    call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                               endif
                              endif
                              let fname2396 = netrw#RFC2396(fname)
                              let fname2396e= fnameescape(fname2396)
                              let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows exception for plainfname",'~'.expand("<slnum>"))
                               if plainfname =~ '^/\+\a:'
                            "    call Decho('removing leading "/"s','~'.expand("<slnum>"))
                                let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
                               endif
                              endif
                            "  call Decho("fname2396<".fname2396.">",'~'.expand("<slnum>"))
                            "  call Decho("plainfname<".plainfname.">",'~'.expand("<slnum>"))
                              exe "sil doau BufReadPre ".fname2396e
                              exe 'NetrwKeepj r '.plainfname
                              exe 'sil! bdelete '.plainfname
                              exe 'keepalt file! '.plainfname
                              NetrwKeepj 1d
                            "  call Decho("setl nomod",'~'.expand("<slnum>"))
                              setl nomod
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("netrw#FileUrlRead")
                              exe "sil doau BufReadPost ".fname2396e
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#LocalBrowseCheck: {{{2
    1              0.000001 fun! netrw#LocalBrowseCheck(dirname)
                              " This function is called by netrwPlugin.vim's s:LocalBrowse(), s:NetrwRexplore(), and by <cr> when atop listed file/directory
                              " unfortunate interaction -- split window debugging can't be
                              " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
                              " event triggers another call to LocalBrowseCheck() when attempts
                              " to write to the DBG buffer are made.
                              " The &ft == "netrw" test was installed because the BufEnter event
                              " would hit when re-entering netrw windows, creating unexpected
                              " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
                            "  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
                            "  call Decho("isdir<".a:dirname."> =".isdirectory(s:NetrwFile(a:dirname)).((exists("s:treeforceredraw")? " treeforceredraw" : "")).'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dredir("ls!","ls!")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("current buffer#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            
                              let ykeep= @@
                              if isdirectory(s:NetrwFile(a:dirname))
                            "   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse,'~'.expand("<slnum>"))
                            
                               if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
                            "    call Decho("case 1 : ft=".&ft,'~'.expand("<slnum>"))
                            "    call Decho("s:rexposn_".bufnr("%")."<".bufname("%")."> ".(exists("s:rexposn_".bufnr("%"))? "exists" : "does not exist"),'~'.expand("<slnum>"))
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
                               elseif &ft == "netrw" && line("$") == 1
                            "    call Decho("case 2 (ft≡netrw && line($)≡1)",'~'.expand("<slnum>"))
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
                               elseif exists("s:treeforceredraw")
                            "    call Decho("case 3 (treeforceredraw)",'~'.expand("<slnum>"))
                                unlet s:treeforceredraw
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                               endif
                            "   call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "   call Dret("netrw#LocalBrowseCheck")
                               return
                              endif
                            
                              " following code wipes out currently unused netrw buffers
                              "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
                              "   AND IF the listing style is not a tree listing
                              if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
                            "   call Decho("wiping out currently unused netrw buffers",'~'.expand("<slnum>"))
                               let ibuf    = 1
                               let buflast = bufnr("$")
                               while ibuf <= buflast
                                if bufwinnr(ibuf) == -1 && isdirectory(s:NetrwFile(bufname(ibuf)))
                                 exe "sil! keepj keepalt ".ibuf."bw!"
                                endif
                                let ibuf= ibuf + 1
                               endwhile
                              endif
                              let @@= ykeep
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                              " not a directory, ignore it
                            "  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:LocalBrowseRefresh: this function is called after a user has {{{2
                            " performed any shell command.  The idea is to cause all local-browsing
                            " buffers to be refreshed after a user has executed some shell command,
                            " on the chance that s/he removed/created a file/directory with it.
    1              0.000002 fun! s:LocalBrowseRefresh()
                            "  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
                            "  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'),'~'.expand("<slnum>"))
                            
                              " determine which buffers currently reside in a tab
                              if !exists("s:netrw_browselist")
                            "   call Dret("s:LocalBrowseRefresh : browselist is empty")
                               return
                              endif
                              if !exists("w:netrw_bannercnt")
                            "   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
                               return
                              endif
                              if exists("s:netrw_events") && s:netrw_events == 1
                               " s:LocalFastBrowser gets called (indirectly) from a
                               let s:netrw_events= 2
                            "   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
                               return
                              endif
                              let itab       = 1
                              let buftablist = []
                              let ykeep      = @@
                              while itab <= tabpagenr("$")
                               let buftablist = buftablist + tabpagebuflist()
                               let itab       = itab + 1
                               tabn
                              endwhile
                            "  call Decho("buftablist".string(buftablist),'~'.expand("<slnum>"))
                            "  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">",'~'.expand("<slnum>"))
                              "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
                              "   | refresh any netrw window
                              "   | wipe out any non-displaying netrw buffer
                              let curwin = winnr()
                              let ibl    = 0
                              for ibuf in s:netrw_browselist
                            "   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf),'~'.expand("<slnum>"))
                               if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
                                " wipe out any non-displaying netrw buffer
                            "    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">",'~'.expand("<slnum>"))
                                exe "sil! keepj bd ".fnameescape(ibuf)
                                call remove(s:netrw_browselist,ibl)
                            "    call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
                                continue
                               elseif index(tabpagebuflist(),ibuf) != -1
                                " refresh any netrw buffer
                            "    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf),'~'.expand("<slnum>"))
                                exe bufwinnr(ibuf)."wincmd w"
                                if getline(".") =~# 'Quick Help'
                                 " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
                                 " (counteracts s:NetrwBrowseChgDir()'s incrementing)
                                 let g:netrw_quickhelp= g:netrw_quickhelp - 1
                                endif
                            "    call Decho("#3: quickhelp=".g:netrw_quickhelp,'~'.expand("<slnum>"))
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 NetrwKeepj call s:NetrwRefreshTreeDict(w:netrw_treetop)
                                endif
                                NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                               endif
                               let ibl= ibl + 1
                            "   call Decho("bottom of s:netrw_browselist for loop: ibl=".ibl,'~'.expand("<slnum>"))
                              endfor
                            "  call Decho("restore window: exe ".curwin."wincmd w",'~'.expand("<slnum>"))
                              exe curwin."wincmd w"
                              let @@= ykeep
                            
                            "  call Dret("s:LocalBrowseRefresh")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
                            "
                            "     g:netrw_    Directory Is
                            "     fastbrowse  Local  Remote
                            "  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
                            "  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
                            "  fast   2         H      H
                            "
                            "  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
                            "  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
                            "                       (re-using a buffer may not be as accurate)
                            "
                            "  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
                            "                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
                            "                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
                            "                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
                            "                   =2: autocmds installed (doesn't ignore any FocusGained events)
    1              0.000002 fun! s:LocalFastBrowser()
                            "  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
                            "  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"),'~'.expand("<slnum>"))
                            
                              " initialize browselist, a list of buffer numbers that the local browser has used
                              if !exists("s:netrw_browselist")
                            "   call Decho("initialize s:netrw_browselist",'~'.expand("<slnum>"))
                               let s:netrw_browselist= []
                              endif
                            
                              " append current buffer to fastbrowse list
                              if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
                            "   call Decho("appendng current buffer to browselist",'~'.expand("<slnum>"))
                               call add(s:netrw_browselist,bufnr("%"))
                            "   call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
                              endif
                            
                              " enable autocmd events to handle refreshing/removing local browser buffers
                              "    If local browse buffer is currently showing: refresh it
                              "    If local browse buffer is currently hidden : wipe it
                              "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
                              "                      =1 : medium speed, re-use directory listing for remote only
                              "                      =2 : fast   speed, always re-use directory listing when possible
                              if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
                               let s:netrw_events= 1
                               augroup AuNetrwEvent
                                au!
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "     call Decho("installing autocmd: ShellCmdPost",'~'.expand("<slnum>"))
                                 au ShellCmdPost			*	call s:LocalBrowseRefresh()
                                else
                            "     call Decho("installing autocmds: ShellCmdPost FocusGained",'~'.expand("<slnum>"))
                                 au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
                                endif
                               augroup END
                            
                              " user must have changed fastbrowse to its fast setting, so remove
                              " the associated autocmd events
                              elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
                            "   call Decho("remove AuNetrwEvent autcmd group",'~'.expand("<slnum>"))
                               unlet s:netrw_events
                               augroup AuNetrwEvent
                                au!
                               augroup END
                               augroup! AuNetrwEvent
                              endif
                            
                            "  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:LocalListing: does the job of "ls" for local directories {{{2
    1              0.000002 fun! s:LocalListing()
                            "  call Dfunc("s:LocalListing()")
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                            "  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist",'~'.expand("<slnum>")) |endif
                            "  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist",'~'.expand("<slnum>"))|endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " get the list of files contained in the current directory
                              let dirname    = b:netrw_curdir
                              let dirnamelen = strlen(b:netrw_curdir)
                              let filelist   = s:NetrwGlob(dirname,"*",0)
                              let filelist   = filelist + s:NetrwGlob(dirname,".*",0)
                            "  call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                            
                              if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                              elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
                                " include ../ in the glob() entry if its missing
                            "   call Decho("forcibly including on \"..\"",'~'.expand("<slnum>"))
                               let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                              endif
                            
                            "  call Decho("before while: dirname   <".dirname.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: dirnamelen<".dirnamelen.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: filelist  =".string(filelist),'~'.expand("<slnum>"))
                            
                              if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
                               let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
                               let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
                            "   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy),'~'.expand("<slnum>"))
                            "   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen,'~'.expand("<slnum>"))
                              endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              for filename in filelist
                            "   call Decho(" ",'~'.expand("<slnum>"))
                            "   call Decho("for filename in filelist: filename<".filename.">",'~'.expand("<slnum>"))
                            
                               if getftype(filename) == "link"
                                " indicate a symbolic link
                            "    call Decho("indicate <".filename."> is a symbolic link with trailing @",'~'.expand("<slnum>"))
                                let pfile= filename."@"
                            
                               elseif getftype(filename) == "socket"
                                " indicate a socket
                            "    call Decho("indicate <".filename."> is a socket with trailing =",'~'.expand("<slnum>"))
                                let pfile= filename."="
                            
                               elseif getftype(filename) == "fifo"
                                " indicate a fifo
                            "    call Decho("indicate <".filename."> is a fifo with trailing |",'~'.expand("<slnum>"))
                                let pfile= filename."|"
                            
                               elseif isdirectory(s:NetrwFile(filename))
                                " indicate a directory
                            "    call Decho("indicate <".filename."> is a directory with trailing /",'~'.expand("<slnum>"))
                                let pfile= filename."/"
                            
                               elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(s:NetrwFile(filename))
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
                                  " indicate an executable
                            "      call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                  let pfile= filename."*"
                                 else
                                  " normal file
                                  let pfile= filename
                                 endif
                                elseif executable(filename)
                                 " indicate an executable
                            "     call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                 let pfile= filename."*"
                                else
                                 " normal file
                                 let pfile= filename
                                endif
                            
                               else
                                " normal file
                                let pfile= filename
                               endif
                            "   call Decho("pfile<".pfile."> (after *@/ appending)",'~'.expand("<slnum>"))
                            
                               if pfile =~ '//$'
                                let pfile= substitute(pfile,'//$','/','e')
                            "    call Decho("change // to /: pfile<".pfile.">",'~'.expand("<slnum>"))
                               endif
                               let pfile= strpart(pfile,dirnamelen)
                               let pfile= substitute(pfile,'^[/\\]','','e')
                            "   call Decho("filename<".filename.">",'~'.expand("<slnum>"))
                            "   call Decho("pfile   <".pfile.">",'~'.expand("<slnum>"))
                            
                               if w:netrw_liststyle == s:LONGLIST
                                let sz   = getfsize(filename)
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                let fsz  = strpart("               ",1,15-strlen(sz)).sz
                                let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
                            "    call Decho("longlist support: sz=".sz." fsz=".fsz,'~'.expand("<slnum>"))
                               endif
                            
                               if     g:netrw_sort_by =~# "^t"
                                " sort by time (handles time up to 1 quintillion seconds, US)
                            "    call Decho("getftime(".filename.")=".getftime(filename),'~'.expand("<slnum>"))
                                let t  = getftime(filename)
                                let ft = strpart("000000000000000000",1,18-strlen(t)).t
                            "    call Decho("exe NetrwKeepj put ='".ft.'/'.filename."'",'~'.expand("<slnum>"))
                                let ftpfile= ft.'/'.pfile
                                sil! NetrwKeepj put=ftpfile
                            
                               elseif g:netrw_sort_by =~ "^s"
                                " sort by size (handles file sizes up to 1 quintillion bytes, US)
                            "    call Decho("getfsize(".filename.")=".getfsize(filename),'~'.expand("<slnum>"))
                                let sz   = getfsize(filename)
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
                            "    call Decho("exe NetrwKeepj put ='".fsz.'/'.filename."'",'~'.expand("<slnum>"))
                                let fszpfile= fsz.'/'.pfile
                                sil! NetrwKeepj put =fszpfile
                            
                               else
                                " sort by name
                            "    call Decho("exe NetrwKeepj put ='".pfile."'",'~'.expand("<slnum>"))
                                sil! NetrwKeepj put=pfile
                               endif
                              endfor
                            
                              " cleanup any windows mess at end-of-line
                              sil! NetrwKeepj g/^$/d
                              sil! NetrwKeepj %s/\r$//e
                              call histdel("/",-1)
                            "  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
                              exe "setl ts=".(g:netrw_maxfilenamelen+1)
                            
                            "  call Dret("s:LocalListing")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
    1              0.000002 fun! s:NetrwLocalExecute(cmd)
                            "  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
                              let ykeep= @@
                              " sanity check
                              if !executable(a:cmd)
                               call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
                               let @@= ykeep
                            "   call Dret("s:NetrwLocalExecute")
                               return
                              endif
                            
                              let optargs= input(":!".a:cmd,"","file")
                            "  call Decho("optargs<".optargs.">",'~'.expand("<slnum>"))
                              let result= system(a:cmd.optargs)
                            "  call Decho("result,'~'.expand("<slnum>"))
                            
                              " strip any ansi escape sequences off
                              let result = substitute(result,"\e\\[[0-9;]*m","","g")
                            
                              " show user the result(s)
                              echomsg result
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwLocalExecute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRename: rename a local file or directory {{{2
    1              0.000002 fun! s:NetrwLocalRename(path) range
                            "  call Dfunc("NetrwLocalRename(path<".a:path.">)")
                            
                              " preparation for removing multiple files/directories
                              let ykeep    = @@
                              let ctr      = a:firstline
                              let svpos    = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              " rename files given by the markfilelist
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               for oldname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
                                if exists("subfrom")
                                 let newname= substitute(oldname,subfrom,subto,'')
                            "     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
                                else
                                 call inputsave()
                                 let newname= input("Moving ".oldname." to : ",oldname,"file")
                                 call inputrestore()
                                 if newname =~ ''
                                  " two ctrl-x's : ignore all of string preceding the ctrl-x's
                                  let newname = substitute(newname,'^.*','','')
                                 elseif newname =~ ''
                                  " one ctrl-x : ignore portion of string preceding ctrl-x but after last /
                                  let newname = substitute(newname,'[^/]*','','')
                                 endif
                                 if newname =~ '^s/'
                                  let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
                                  let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
                            "      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">",'~'.expand("<slnum>"))
                                  let newname = substitute(oldname,subfrom,subto,'')
                                 endif
                                endif
                                call rename(oldname,newname)
                               endfor
                               call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                            
                              else
                            
                               " attempt to rename files/directories
                               while ctr <= a:lastline
                                exe "NetrwKeepj ".ctr
                            
                                " sanity checks
                                if line(".") < w:netrw_bannercnt
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let curword= s:NetrwGetWord()
                                if curword == "./" || curword == "../"
                                 let ctr= ctr + 1
                                 continue
                                endif
                            
                                NetrwKeepj norm! 0
                                let oldname= s:ComposePath(a:path,curword)
                            "   call Decho("oldname<".oldname.">",'~'.expand("<slnum>"))
                            
                                call inputsave()
                                let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
                                call inputrestore()
                            
                                call rename(oldname,newname)
                            "   call Decho("renaming <".oldname."> to <".newname.">",'~'.expand("<slnum>"))
                            
                                let ctr= ctr + 1
                               endwhile
                              endif
                            
                              " refresh the directory
                            "  call Decho("refresh the directory listing",'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                            "  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                              NetrwKeepj call winrestview(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetrwLocalRename")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRm: {{{2
    1              0.000001 fun! s:NetrwLocalRm(path) range
                            "  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
                            "  call Decho("firstline=".a:firstline." lastline=".a:lastline,'~'.expand("<slnum>"))
                            
                              " preparation for removing multiple files/directories
                              let ykeep = @@
                              let ret   = 0
                              let all   = 0
                              let svpos = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                            
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               " remove all marked files
                            "   call Decho("remove all marked files",'~'.expand("<slnum>"))
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                                let ok= s:NetrwLocalRmFile(a:path,fname,all)
                                if ok =~# 'q\%[uit]' || ok == "no"
                                 break
                                elseif ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endfor
                               call s:NetrwUnMarkFile(1)
                            
                              else
                              " remove (multiple) files and directories
                            "   call Decho("remove files in range [".a:firstline.",".a:lastline."]",'~'.expand("<slnum>"))
                            
                               let keepsol= &l:sol
                               setl nosol
                               let ctr = a:firstline
                               while ctr <= a:lastline
                                exe "NetrwKeepj ".ctr
                            
                                " sanity checks
                                if line(".") < w:netrw_bannercnt
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let curword= s:NetrwGetWord()
                                if curword == "./" || curword == "../"
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let ok= s:NetrwLocalRmFile(a:path,curword,all)
                                if ok =~# 'q\%[uit]' || ok == "no"
                                 break
                                elseif ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                                let ctr= ctr + 1
                               endwhile
                               let &l:sol= keepsol
                              endif
                            
                              " refresh the directory
                            "  call Decho("bufname<".bufname("%").">",'~'.expand("<slnum>"))
                              if bufname("%") != "NetrwMessage"
                               NetrwKeepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(svpos)
                              endif
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwLocalRm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRmFile: remove file fname given the path {{{2
                            "                     Give confirmation prompt unless all==1
    1              0.000002 fun! s:NetrwLocalRmFile(path,fname,all)
                            "  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)
                            
                              let all= a:all
                              let ok = ""
                              NetrwKeepj norm! 0
                              let rmfile= s:NetrwFile(s:ComposePath(a:path,a:fname))
                            "  call Decho("rmfile<".rmfile.">",'~'.expand("<slnum>"))
                            
                              if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
                               " attempt to remove file
                            "   call Decho("attempt to remove file<".rmfile.">",'~'.expand("<slnum>"))
                               if !all
                                echohl Statement
                                call inputsave()
                                let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                echohl NONE
                                if ok == ""
                                 let ok="no"
                                endif
                            "    call Decho("response: ok<".ok.">",'~'.expand("<slnum>"))
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                            "    call Decho("response: ok<".ok."> (after sub)",'~'.expand("<slnum>"))
                                if ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~# 'y\%[es]' || ok == ""
                                let ret= s:NetrwDelete(rmfile)
                            "    call Decho("errcode=".v:shell_error." ret=".ret,'~'.expand("<slnum>"))
                               endif
                            
                              else
                               " attempt to remove directory
                               if !all
                                echohl Statement
                                call inputsave()
                                let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok == ""
                                 let ok="no"
                                endif
                                if ok =~# 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                               let rmfile= substitute(rmfile,'[\/]$','','e')
                            
                               if all || ok =~# 'y\%[es]' || ok == ""
                                if v:version < 704 || !has("patch1109")
                            " "    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.s:ShellEscape(rmfile).')','~'.expand("<slnum>"))
                                 call system(netrw#WinPath(g:netrw_localrmdir).' '.s:ShellEscape(rmfile))
                            " "    call Decho("v:shell_error=".v:shell_error,'~'.expand("<slnum>"))
                            
                                 if v:shell_error != 0
                            " "     call Decho("2nd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
                                  let errcode= s:NetrwDelete(rmfile)
                            " "     call Decho("errcode=".errcode,'~'.expand("<slnum>"))
                            
                                  if errcode != 0
                                   if has("unix")
                            " "       call Decho("3rd attempt to remove directory<".rmfile.">",'~'.expand("<slnum>"))
                            	call system("rm ".s:ShellEscape(rmfile))
                            	if v:shell_error != 0 && !exists("g:netrw_quiet")
                            	 call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
                            	 let ok="no"
                            	endif
                                   elseif !exists("g:netrw_quiet")
                            	call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
                            	let ok="no"
                                   endif
                                  endif
                                 endif
                                else
                                 if delete(rmfile,"d")
                                  call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".rmfile.">!",103)
                                 endif
                                endif
                               endif
                              endif
                            
                            "  call Dret("s:NetrwLocalRmFile ".ok)
                              return ok
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " Support Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " s:WinNames: COMBAK {{{2
    1              0.000002 fun! s:WinNames(id)
                              let curwin= winnr()
                              1wincmd w
                            "  call Decho("--- Windows By Name --- #".a:id)
                            "  windo call Decho("win#".winnr()."<".expand("%").">")
                            "  call Decho("--- --- --- --- --- ---")
                              exe curwin."wincmd w"
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
                            "   0: marked file list of current buffer
                            "   1: marked file target
    1              0.000001 fun! netrw#Access(ilist)
                              if     a:ilist == 0
                               if exists("s:netrwmarkfilelist_".bufnr('%'))
                                return s:netrwmarkfilelist_{bufnr('%')}
                               else
                                return "no-list-buf#".bufnr('%')
                               endif
                              elseif a:ilist == 1
                               return s:netrwmftgt
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Call: allows user-specified mappings to call internal netrw functions {{{2
    1              0.000001 fun! netrw#Call(funcname,...)
                            "  call Dfunc("netrw#Call(funcname<".a:funcname.">,".string(a:000).")")
                              if a:0 > 0
                               exe "call s:".a:funcname."(".string(a:000).")"
                              else
                               exe "call s:".a:funcname."()"
                              endif
                            "  call Dret("netrw#Call")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Expose: allows UserMaps and pchk to look at otherwise script-local variables {{{2
                            "               I expect this function to be used in
                            "                 :PChkAssert netrw#Expose("netrwmarkfilelist")
                            "               for example.
    1              0.000005 fun! netrw#Expose(varname)
                            "   call Dfunc("netrw#Expose(varname<".a:varname.">)")
                              if exists("s:".a:varname)
                               exe "let retval= s:".a:varname
                               if exists("g:netrw_pchk")
                                if type(retval) == 3
                                 let retval = copy(retval)
                                 let i      = 0
                                 while i < len(retval)
                                  let retval[i]= substitute(retval[i],expand("$HOME"),'~','')
                                  let i        = i + 1
                                 endwhile
                                endif
                            "     call Dret("netrw#Expose ".string(retval))
                                return string(retval)
                               endif
                              else
                               let retval= "n/a"
                              endif
                            
                            "  call Dret("netrw#Expose ".string(retval))
                              return retval
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Modify: allows UserMaps to set (modify) script-local variables {{{2
    1              0.000002 fun! netrw#Modify(varname,newvalue)
                            "  call Dfunc("netrw#Modify(varname<".a:varname.">,newvalue<".string(a:newvalue).">)")
                              exe "let s:".a:varname."= ".string(a:newvalue)
                            "  call Dret("netrw#Modify")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  netrw#RFC2396: converts %xx into characters {{{2
    1              0.000002 fun! netrw#RFC2396(fname)
                            "  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
                              let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
                            "  call Dret("netrw#RFC2396 ".fname)
                              return fname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#UserMaps: supports user-specified maps {{{2
                            "                 see :help function()
                            "
                            "                 g:Netrw_UserMaps is a List with members such as:
                            "                       [[keymap sequence, function reference],...]
                            "
                            "                 The referenced function may return a string,
                            "                 	refresh : refresh the display
                            "                 	-other- : this string will be executed
                            "                 or it may return a List of strings.
                            "
                            "                 Each keymap-sequence will be set up with a nnoremap
                            "                 to invoke netrw#UserMaps(islocal).
                            "                 Related functions:
                            "                   netrw#Expose(varname)          -- see s:varname variables
                            "                   netrw#Modify(varname,newvalue) -- modify value of s:varname variable
                            "                   netrw#Call(funcname,...)       -- call internal netrw function with optional arguments
    1              0.000001 fun! netrw#UserMaps(islocal)
                            "  call Dfunc("netrw#UserMaps(islocal=".a:islocal.")")
                            "  call Decho("g:Netrw_UserMaps ".(exists("g:Netrw_UserMaps")? "exists" : "does NOT exist"),'~'.expand("<slnum>"))
                            
                               " set up usermaplist
                               if exists("g:Netrw_UserMaps") && type(g:Netrw_UserMaps) == 3
                            "    call Decho("g:Netrw_UserMaps has type 3<List>",'~'.expand("<slnum>"))
                                for umap in g:Netrw_UserMaps
                            "     call Decho("type(umap[0]<".string(umap[0]).">)=".type(umap[0])." (should be 1=string)",'~'.expand("<slnum>"))
                            "     call Decho("type(umap[1])=".type(umap[1])." (should be 1=string)",'~'.expand("<slnum>"))
                                 " if umap[0] is a string and umap[1] is a string holding a function name
                                 if type(umap[0]) == 1 && type(umap[1]) == 1
                            "      call Decho("nno <buffer> <silent> ".umap[0]." :call s:UserMaps(".a:islocal.",".string(umap[1]).")<cr>",'~'.expand("<slnum>"))
                                  exe "nno <buffer> <silent> ".umap[0]." :call <SID>UserMaps(".a:islocal.",'".umap[1]."')<cr>"
                                  else
                                   call netrw#ErrorMsg(s:WARNING,"ignoring usermap <".string(umap[0])."> -- not a [string,funcref] entry",99)
                                 endif
                                endfor
                               endif
                            "  call Dret("netrw#UserMaps")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
    1              0.000001 fun! netrw#WinPath(path)
                            "  call Dfunc("netrw#WinPath(path<".a:path.">)")
                              if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
                               " remove cygdrive prefix, if present
                               let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
                               " remove trailing slash (Win95)
                               let path = substitute(path, '\(\\\|/\)$', '', 'g')
                               " remove escaped spaces
                               let path = substitute(path, '\ ', ' ', 'g')
                               " convert slashes to backslashes
                               let path = substitute(path, '/', '\', 'g')
                              else
                               let path= a:path
                              endif
                            "  call Dret("netrw#WinPath <".path.">")
                              return path
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
    1              0.000002 fun! s:ComposePath(base,subdir)
                            "  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")
                            
                              if has("amiga")
                            "   call Decho("amiga",'~'.expand("<slnum>"))
                               let ec = a:base[s:Strlen(a:base)-1]
                               if ec != '/' && ec != ':'
                                let ret = a:base."/" . a:subdir
                               else
                                let ret = a:base.a:subdir
                               endif
                            
                              elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               let ret= a:subdir
                            
                              elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               if a:base =~ '[/\\]$'
                                let ret= a:base.a:subdir
                               else
                                let ret= a:base.'/'.a:subdir
                               endif
                            
                              elseif a:base =~ '^\a\{3,}://'
                            "   call Decho("remote linux/macos",'~'.expand("<slnum>"))
                               let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
                               let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
                               if a:subdir == '../'
                                if curpath =~ '[^/]/[^/]\+/$'
                                 let curpath= substitute(curpath,'[^/]\+/$','','')
                                else
                                 let curpath=""
                                endif
                                let ret= urlbase.curpath
                               else
                                let ret= urlbase.curpath.a:subdir
                               endif
                            "   call Decho("urlbase<".urlbase.">",'~'.expand("<slnum>"))
                            "   call Decho("curpath<".curpath.">",'~'.expand("<slnum>"))
                            "   call Decho("ret<".ret.">",'~'.expand("<slnum>"))
                            
                              else
                            "   call Decho("local linux/macos",'~'.expand("<slnum>"))
                               let ret = substitute(a:base."/".a:subdir,"//","/","g")
                               if a:base =~ '^//'
                                " keeping initial '//' for the benefit of network share listing support
                                let ret= '/'.ret
                               endif
                               let ret= simplify(ret)
                              endif
                            
                            "  call Dret("s:ComposePath ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:DeleteBookmark: deletes a file/directory from Netrw's bookmark system {{{2
                            "   Related Functions: s:MakeBookmark() s:NetrwBookHistHandler() s:NetrwBookmark()
    1              0.000001 fun! s:DeleteBookmark(fname)
                            "  call Dfunc("s:DeleteBookmark(fname<".a:fname.">)")
                              call s:MergeBookmarks()
                            
                              if exists("g:netrw_bookmarklist")
                               let indx= index(g:netrw_bookmarklist,a:fname)
                               if indx == -1
                                let indx= 0
                                while indx < len(g:netrw_bookmarklist)
                                 if g:netrw_bookmarklist[indx] =~ a:fname
                                  call remove(g:netrw_bookmarklist,indx)
                                  let indx= indx - 1
                                 endif
                                 let indx= indx + 1
                                endwhile
                               else
                                " remove exact match
                                call remove(g:netrw_bookmarklist,indx)
                               endif
                              endif
                            
                            "  call Dret("s:DeleteBookmark")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:FileReadable: o/s independent filereadable {{{2
    1              0.000002 fun! s:FileReadable(fname)
                            "  call Dfunc("s:FileReadable(fname<".a:fname.">)")
                            
                              if g:netrw_cygwin
                               let ret= filereadable(s:NetrwFile(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/','')))
                              else
                               let ret= filereadable(s:NetrwFile(a:fname))
                              endif
                            
                            "  call Dret("s:FileReadable ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
                            "                 Places correct suffix on end of temporary filename,
                            "                 using the suffix provided with fname
    1              0.000001 fun! s:GetTempfile(fname)
                            "  call Dfunc("s:GetTempfile(fname<".a:fname.">)")
                            
                              if !exists("b:netrw_tmpfile")
                               " get a brand new temporary filename
                               let tmpfile= tempname()
                            "   call Decho("tmpfile<".tmpfile."> : from tempname()",'~'.expand("<slnum>"))
                            
                               let tmpfile= substitute(tmpfile,'\','/','ge')
                            "   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /",'~'.expand("<slnum>"))
                            
                               " sanity check -- does the temporary file's directory exist?
                               if !isdirectory(s:NetrwFile(substitute(tmpfile,'[^/]\+$','','e')))
                            "    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                NetrwKeepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
                            "    call Dret("s:GetTempfile getcwd<".getcwd().">")
                                return ""
                               endif
                            
                               " let netrw#NetSource() know about the tmpfile
                               let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#BrowseX()
                            "   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))
                            
                               " o/s dependencies
                               if g:netrw_cygwin != 0
                                let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
                               elseif has("win32") || has("win95") || has("win64") || has("win16")
                                if !exists("+shellslash") || !&ssl
                                 let tmpfile = substitute(tmpfile,'/','\','g')
                                endif
                               else
                                let tmpfile = tmpfile
                               endif
                               let b:netrw_tmpfile= tmpfile
                            "   call Decho("o/s dependent fixed tempname<".tmpfile.">",'~'.expand("<slnum>"))
                              else
                               " re-use temporary filename
                               let tmpfile= b:netrw_tmpfile
                            "   call Decho("tmpfile<".tmpfile."> re-using",'~'.expand("<slnum>"))
                              endif
                            
                              " use fname's suffix for the temporary file
                              if a:fname != ""
                               if a:fname =~ '\.[^./]\+$'
                            "    call Decho("using fname<".a:fname.">'s suffix",'~'.expand("<slnum>"))
                                if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
                                 let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                elseif a:fname =~ '.txz$'
                                 let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                else
                                 let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                endif
                            "    call Decho("suffix<".suffix.">",'~'.expand("<slnum>"))
                                let tmpfile= substitute(tmpfile,'\.tmp$','','e')
                            "    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)",'~'.expand("<slnum>"))
                                let tmpfile .= suffix
                            "    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">",'~'.expand("<slnum>"))
                                let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
                               endif
                              endif
                            
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("s:GetTempfile <".tmpfile.">")
                              return tmpfile
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
                            "               a correct command for use with a system() call
    1              0.000001 fun! s:MakeSshCmd(sshcmd)
                            "  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
                              if s:user == ""
                               let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
                              else
                               let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
                              endif
                              if exists("g:netrw_port") && g:netrw_port != ""
                               let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
                              elseif exists("s:port") && s:port != ""
                               let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
                              else
                               let sshcmd= substitute(sshcmd,"USEPORT ",'','')
                              endif
                            "  call Dret("s:MakeSshCmd <".sshcmd.">")
                              return sshcmd
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:MakeBookmark: enters a bookmark into Netrw's bookmark system   {{{2
    1              0.000002 fun! s:MakeBookmark(fname)
                            "  call Dfunc("s:MakeBookmark(fname<".a:fname.">)")
                            
                              if !exists("g:netrw_bookmarklist")
                               let g:netrw_bookmarklist= []
                              endif
                            
                              if index(g:netrw_bookmarklist,a:fname) == -1
                               " curdir not currently in g:netrw_bookmarklist, so include it
                               if isdirectory(s:NetrwFile(a:fname)) && a:fname !~ '/$'
                                call add(g:netrw_bookmarklist,a:fname.'/')
                               elseif a:fname !~ '/'
                                call add(g:netrw_bookmarklist,getcwd()."/".a:fname)
                               else
                                call add(g:netrw_bookmarklist,a:fname)
                               endif
                               call sort(g:netrw_bookmarklist)
                              endif
                            
                            "  call Dret("s:MakeBookmark")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:MergeBookmarks: merge current bookmarks with saved bookmarks {{{2
    1              0.000001 fun! s:MergeBookmarks()
                            "  call Dfunc("s:MergeBookmarks() : merge current bookmarks into .netrwbook")
                              " get bookmarks from .netrwbook file
                              let savefile= s:NetrwHome()."/.netrwbook"
                              if filereadable(s:NetrwFile(savefile))
                            "   call Decho("merge bookmarks (active and file)",'~'.expand("<slnum>"))
                               NetrwKeepj call s:NetrwBookHistSave()
                            "   call Decho("bookmark delete savefile<".savefile.">",'~'.expand("<slnum>"))
                               NetrwKeepj call delete(savefile)
                              endif
                            "  call Dret("s:MergeBookmarks")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBMShow: {{{2
    1              0.000002 fun! s:NetrwBMShow()
                            "  call Dfunc("s:NetrwBMShow()")
                              redir => bmshowraw
                               menu
                              redir END
                              let bmshowlist = split(bmshowraw,'\n')
                              if bmshowlist != []
                               let bmshowfuncs= filter(bmshowlist,'v:val =~# "<SNR>\\d\\+_BMShow()"')
                               if bmshowfuncs != []
                                let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
                                if bmshowfunc =~# '^call.*BMShow()'
                                 exe "sil! NetrwKeepj ".bmshowfunc
                                endif
                               endif
                              endif
                            "  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
    1              0.000001 fun! s:NetrwCursor()
                              if !exists("w:netrw_liststyle")
                               let w:netrw_liststyle= g:netrw_liststyle
                              endif
                            "  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)
                            
                              if &ft != "netrw"
                               " if the current window isn't a netrw directory listing window, then use user cursorline/column
                               " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
                            "   call Decho("case ft!=netrw: use user cul,cuc",'~'.expand("<slnum>"))
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                            
                              elseif g:netrw_cursor == 4
                               " all styles: cursorline, cursorcolumn
                            "   call Decho("case g:netrw_cursor==4: setl cul cuc",'~'.expand("<slnum>"))
                               setl cursorline
                               setl cursorcolumn
                            
                              elseif g:netrw_cursor == 3
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc",'~'.expand("<slnum>"))
                                setl cursorline
                                setl cursorcolumn
                               else
                            "    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                                let &l:cursorcolumn   = s:netrw_usercuc
                               endif
                            
                              elseif g:netrw_cursor == 2
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, user's cursorcolumn
                            "   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)",'~'.expand("<slnum>"))
                               let &l:cursorcolumn = s:netrw_usercuc
                               setl cursorline
                            
                              elseif g:netrw_cursor == 1
                               " thin-long-tree: user's cursorline, user's cursorcolumn
                               " wide          : cursorline,        user's cursorcolumn
                               let &l:cursorcolumn = s:netrw_usercuc
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                               else
                            "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)",'~'.expand("<slnum>"))
                                let &l:cursorline   = s:netrw_usercul
                               endif
                            
                              else
                               " all styles: user's cursorline, user's cursorcolumn
                            "   call Decho("default: (use user's cul,cuc)",'~'.expand("<slnum>"))
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            
                            "  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
    1              0.000006 fun! s:RestoreCursorline()
                            "  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
                              if exists("s:netrw_usercul")
                               let &l:cursorline   = s:netrw_usercul
                              endif
                              if exists("s:netrw_usercuc")
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            "  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwDelete: Deletes a file. {{{2
                            "           Uses Steve Hall's idea to insure that Windows paths stay
                            "           acceptable.  No effect on Unix paths.
                            "  Examples of use:  let result= s:NetrwDelete(path)
    1              0.000002 fun! s:NetrwDelete(path)
                            "  call Dfunc("s:NetrwDelete(path<".a:path.">)")
                            
                              let path = netrw#WinPath(a:path)
                              if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                               if exists("+shellslash")
                                let sskeep= &shellslash
                                setl noshellslash
                                let result      = delete(path)
                                let &shellslash = sskeep
                               else
                            "    call Decho("exe let result= ".a:cmd."('".path."')",'~'.expand("<slnum>"))
                                let result= delete(path)
                               endif
                              else
                            "   call Decho("let result= delete(".path.")",'~'.expand("<slnum>"))
                               let result= delete(path)
                              endif
                              if result < 0
                               NetrwKeepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
                              endif
                            
                            "  call Dret("s:NetrwDelete ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
    1              0.000001 fun! s:NetrwEnew(...)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
                              if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
                              if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
                              if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
                              if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
                              if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
                              if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
                              if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
                              if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
                              if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
                              if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
                              if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
                              if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
                              if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
                              if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
                              if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
                              if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
                              NetrwKeepj call s:NetrwOptionRestore("w:")
                            "  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
                              " when tree listing uses file TreeListing... a new buffer is made.
                              " Want the old buffer to be unlisted.
                              " COMBAK: this causes a problem, see P43
                            "  setl nobl
                              let netrw_keepdiff= &l:diff
                              noswapfile NetrwKeepj keepalt enew!
                              let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
                              NetrwKeepj call s:NetrwOptionSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
                              if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
                              if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
                              if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
                              if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
                              if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
                              if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
                              if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
                              if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
                              if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
                              if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
                              if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
                              if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
                              if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
                              if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
                              if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
                              if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
                              if a:0 > 0
                               let b:netrw_curdir= a:1
                               if b:netrw_curdir =~ '/$'
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 setl nobl
                                 file NetrwTreeListing
                                 setl nobl bt=nowrite bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
                                 exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
                                endif
                               endif
                              endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwExe: executes a string using "!" {{{2
    1              0.000001 fun! s:NetrwExe(cmd)
                            "  call Dfunc("s:NetrwExe(a:cmd)")
                              if has("win32") && &shell !~? 'cmd' && !g:netrw_cygwin
                                let savedShell=[&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash]
                                set shell& shellcmdflag& shellxquote& shellxescape&
                                set shellquote& shellpipe& shellredir& shellslash&
                                exe a:cmd
                                let [&shell,&shellcmdflag,&shellxquote,&shellxescape,&shellquote,&shellpipe,&shellredir,&shellslash] = savedShell
                              else
                               exe a:cmd
                              endif
                            "  call Dret("s:NetrwExe")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
    1              0.000001 fun! s:NetrwInsureWinVars()
                              if !exists("w:netrw_liststyle")
                            "   call Dfunc("s:NetrwInsureWinVars() win#".winnr())
                               let curbuf = bufnr("%")
                               let curwin = winnr()
                               let iwin   = 1
                               while iwin <= winnr("$")
                                exe iwin."wincmd w"
                                if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
                                 " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
                                 let winvars= w:
                                 break
                                endif
                                let iwin= iwin + 1
                               endwhile
                               exe "keepalt ".curwin."wincmd w"
                               if exists("winvars")
                            "    call Decho("copying w#".iwin." window variables to w#".curwin,'~'.expand("<slnum>"))
                                for k in keys(winvars)
                                 let w:{k}= winvars[k]
                                endfor
                               endif
                            "   call Dret("s:NetrwInsureWinVars win#".winnr())
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLcd: handles changing the (local) directory {{{2
    1              0.000001 fun! s:NetrwLcd(newdir)
                            "  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")
                            
                              try
                               exe 'NetrwKeepj sil lcd '.fnameescape(a:newdir)
                              catch /^Vim\%((\a\+)\)\=:E344/
                                 " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
                                 " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
                                 " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or
                                 " forward slashes ('//Foo'), depending on whether backslashes have been converted to
                                 " forward slashes by earlier code; so check for both.
                                 if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
                                   if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
                                     let dirname = '\'
                            	 exe 'NetrwKeepj sil lcd '.fnameescape(dirname)
                                   endif
                                 endif
                              catch /^Vim\%((\a\+)\)\=:E472/
                               call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
                               if exists("w:netrw_prvdir")
                                let a:newdir= w:netrw_prvdir
                               else
                                call s:NetrwOptionRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                exe "setl ".g:netrw_bufsettings
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                let a:newdir= dirname
                            "    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
                                return
                               endif
                              endtry
                            
                            "  call Dret("s:NetrwLcd")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
                            " changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
    1              0.000001 fun! s:NetrwSaveWordPosn()
                            "  call Dfunc("NetrwSaveWordPosn()")
                              let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
                            "  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHumanReadable: takes a number and makes it "human readable" {{{2
                            "                       1000 -> 1K, 1000000 -> 1M, 1000000000 -> 1G
    1              0.000001 fun! s:NetrwHumanReadable(sz)
                            "  call Dfunc("s:NetrwHumanReadable(sz=".a:sz.") type=".type(a:sz)." style=".g:netrw_sizestyle )
                            
                              if g:netrw_sizestyle == 'h'
                               if a:sz >= 1000000000 
                                let sz = printf("%.1f",a:sz/1000000000.0)."g"
                               elseif a:sz >= 10000000
                                let sz = printf("%d",a:sz/1000000)."m"
                               elseif a:sz >= 1000000
                                let sz = printf("%.1f",a:sz/1000000.0)."m"
                               elseif a:sz >= 10000
                                let sz = printf("%d",a:sz/1000)."k"
                               elseif a:sz >= 1000
                                let sz = printf("%.1f",a:sz/1000.0)."k"
                               else
                                let sz= a:sz
                               endif
                            
                              elseif g:netrw_sizestyle == 'H'
                               if a:sz >= 1073741824
                                let sz = printf("%.1f",a:sz/1073741824.0)."G"
                               elseif a:sz >= 10485760
                                let sz = printf("%d",a:sz/1048576)."M"
                               elseif a:sz >= 1048576
                                let sz = printf("%.1f",a:sz/1048576.0)."M"
                               elseif a:sz >= 10240
                                let sz = printf("%d",a:sz/1024)."K"
                               elseif a:sz >= 1024
                                let sz = printf("%.1f",a:sz/1024.0)."K"
                               else
                                let sz= a:sz
                               endif
                            
                              else
                               let sz= a:sz
                              endif
                            
                            "  call Dret("s:NetrwHumanReadable ".sz)
                              return sz
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
                            "  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
    1              0.000001 fun! s:NetrwRestoreWordPosn()
                            "  call Dfunc("NetrwRestoreWordPosn()")
                              sil! call search(s:netrw_saveword,'w')
                            "  call Dret("NetrwRestoreWordPosn")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreBufVars: {{{2
    1              0.000001 fun! s:RestoreBufVars()
                            "  call Dfunc("s:RestoreBufVars()")
                            
                              if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
                              if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
                              if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
                              if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
                              if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
                              if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif
                            
                            "  call Dret("s:RestoreBufVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RemotePathAnalysis: {{{2
    1              0.000001 fun! s:RemotePathAnalysis(dirname)
                            "  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")
                            
                              "                method   ://    user  @      machine      :port            /path
                              let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
                              let s:method  = substitute(a:dirname,dirpat,'\1','')
                              let s:user    = substitute(a:dirname,dirpat,'\3','')
                              let s:machine = substitute(a:dirname,dirpat,'\4','')
                              let s:port    = substitute(a:dirname,dirpat,'\5','')
                              let s:path    = substitute(a:dirname,dirpat,'\6','')
                              let s:fname   = substitute(s:path,'^.*/\ze.','','')
                              if s:machine =~ '@'
                               let dirpat    = '^\(.*\)@\(.\{-}\)$'
                               let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
                               let s:machine = substitute(s:machine,dirpat,'\2','')
                              endif
                            
                            "  call Decho("set up s:method <".s:method .">",'~'.expand("<slnum>"))
                            "  call Decho("set up s:user   <".s:user   .">",'~'.expand("<slnum>"))
                            "  call Decho("set up s:machine<".s:machine.">",'~'.expand("<slnum>"))
                            "  call Decho("set up s:port   <".s:port.">",'~'.expand("<slnum>"))
                            "  call Decho("set up s:path   <".s:path   .">",'~'.expand("<slnum>"))
                            "  call Decho("set up s:fname  <".s:fname  .">",'~'.expand("<slnum>"))
                            
                            "  call Dret("s:RemotePathAnalysis")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RemoteSystem: runs a command on a remote host using ssh {{{2
                            "                 Returns status
                            " Runs system() on
                            "    [cd REMOTEDIRPATH;] a:cmd
                            " Note that it doesn't do s:ShellEscape(a:cmd)!
    1              0.000002 fun! s:RemoteSystem(cmd)
                            "  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
                              if !executable(g:netrw_ssh_cmd)
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
                              elseif !exists("b:netrw_curdir")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
                              else
                               let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
                               let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
                               if remotedir != ""
                                let cmd= cmd.' cd '.s:ShellEscape(remotedir).";"
                               else
                                let cmd= cmd.' '
                               endif
                               let cmd= cmd.a:cmd
                            "   call Decho("call system(".cmd.")",'~'.expand("<slnum>"))
                               let ret= system(cmd)
                              endif
                            "  call Dret("s:RemoteSystem ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
    1              0.000001 fun! s:RestoreWinVars()
                            "  call Dfunc("s:RestoreWinVars()")
                              if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
                              if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
                              if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
                              if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
                              if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
                              if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
                              if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
                              if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
                              if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
                              if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
                              if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
                              if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
                              if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
                              if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
                              if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
                              if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
                              if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
                              if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
                            "  call Dret("s:RestoreWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:Rexplore: implements returning from a buffer to a netrw directory {{{2
                            "
                            "             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
                            "             is true) and a command, :Rexplore, which call this function.
                            "
                            "             s:netrw_nbcd is set up by s:NetrwBrowseChgDir()
                            "
                            "             s:rexposn_BUFNR used to save/restore cursor position
    1              0.000002 fun! s:NetrwRexplore(islocal,dirname)
                              if exists("s:netrwdrag")
                               return
                              endif
                            "  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir."> win#".winnr())
                            "  call Decho("currently in bufname<".bufname("%").">",'~'.expand("<slnum>"))
                            "  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))
                            
                              if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
                               " a :Rex while in a netrw buffer means: edit the file in w:netrw_rexfile
                            "   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">",'~'.expand("<slnum>"))
                               exe "NetrwKeepj e ".w:netrw_rexfile
                               unlet w:netrw_rexfile
                            "   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
                               return
                            "  else " Decho
                            "   call Decho("treating as not-netrw-buffer: ft=".&ft.((&ft == "netrw")? " == netrw" : "!= netrw"),'~'.expand("<slnum>"))
                            "   call Decho("treating as not-netrw-buffer: w:netrw_rexfile<".((exists("w:netrw_rexfile"))? w:netrw_rexfile : 'n/a').">",'~'.expand("<slnum>"))
                              endif
                            
                              " ---------------------------
                              " :Rex issued while in a file
                              " ---------------------------
                            
                              " record current file so :Rex can return to it from netrw
                              let w:netrw_rexfile= expand("%")
                            "  call Decho("set w:netrw_rexfile<".w:netrw_rexfile.">  (win#".winnr().")",'~'.expand("<slnum>"))
                            
                              if !exists("w:netrw_rexlocal")
                            "   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft." win#".winnr().")")
                               return
                              endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                              if w:netrw_rexlocal
                               NetrwKeepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
                              else
                               NetrwKeepj call s:NetrwBrowse(0,w:netrw_rexdir)
                              endif
                              if exists("s:initbeval")
                               setl beval
                              endif
                              if exists("s:rexposn_".bufnr("%"))
                            "   call Decho("restore posn, then unlet s:rexposn_".bufnr('%')."<".bufname("%").">",'~'.expand("<slnum>"))
                               " restore position in directory listing
                            "   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
                               if exists("s:rexposn_".bufnr('%'))
                                unlet s:rexposn_{bufnr('%')}
                               endif
                              else
                            "   call Decho("s:rexposn_".bufnr('%')."<".bufname("%")."> doesn't exist",'~'.expand("<slnum>"))
                              endif
                            
                              if exists("s:explore_match")
                               exe "2match netrwMarkFile /".s:explore_match."/"
                              endif
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwRexplore : ft=".&ft)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveBufVars: save selected b: variables to s: variables {{{2
                            "                use s:RestoreBufVars() to restore b: variables from s: variables
    1              0.000001 fun! s:SaveBufVars()
                            "  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))
                            
                              if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
                              if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
                              if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
                              if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
                              if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
                              if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif
                            
                            "  call Dret("s:SaveBufVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SavePosn: saves position associated with current buffer into a dictionary {{{2
    1              0.000001 fun! s:SavePosn(posndict)
                            "  call Dfunc("s:SavePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
                            
                              let a:posndict[bufnr("%")]= winsaveview()
                            "  call Decho("saving posn: posndict[".bufnr("%")."]=".string(winsaveview()),'~'.expand("<slnum>"))
                            
                            "  call Dret("s:SavePosn posndict")
                              return a:posndict
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestorePosn: restores position associated with current buffer using dictionary {{{2
    1              0.000001 fun! s:RestorePosn(posndict)
                            "  call Dfunc("s:RestorePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
                              if has_key(a:posndict,bufnr("%"))
                               call winrestview(a:posndict[bufnr("%")])
                            "   call Decho("restoring posn: posndict[".bufnr("%")."]=".string(a:posndict[bufnr("%")]),'~'.expand("<slnum>"))
                              endif
                            "  call Dret("s:RestorePosn")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
    1              0.000002 fun! s:SaveWinVars()
                            "  call Dfunc("s:SaveWinVars() win#".winnr())
                              if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
                              if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
                              if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
                              if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
                              if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
                              if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
                              if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
                              if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
                              if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
                              if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
                              if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
                              if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
                              if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
                              if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
                              if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
                              if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
                            "  call Dret("s:SaveWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
                            "   To allow separate windows to have their own activities, such as
                            "   Explore **/pattern, several variables have been made window-oriented.
                            "   However, when the user splits a browser window (ex: ctrl-w s), these
                            "   variables are not inherited by the new window.  SetBufWinVars() and
                            "   UseBufWinVars() get around that.
    1              0.000001 fun! s:SetBufWinVars()
                            "  call Dfunc("s:SetBufWinVars() win#".winnr())
                              if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
                              if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
                              if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
                              if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
                              if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
                              if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
                              if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
                              if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
                            "  call Dret("s:SetBufWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetRexDir: set directory for :Rexplore {{{2
    1              0.000002 fun! s:SetRexDir(islocal,dirname)
                            "  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">) win#".winnr())
                              let w:netrw_rexdir         = a:dirname
                              let w:netrw_rexlocal       = a:islocal
                              let s:rexposn_{bufnr("%")} = winsaveview()
                            "  call Decho("setting w:netrw_rexdir  =".w:netrw_rexdir,'~'.expand("<slnum>"))
                            "  call Decho("setting w:netrw_rexlocal=".w:netrw_rexlocal,'~'.expand("<slnum>"))
                            "  call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "  call Decho("setting s:rexposn_".bufnr("%")."<".bufname("%")."> to ".string(winsaveview()),'~'.expand("<slnum>"))
                            "  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:ShowLink: used to modify thin and tree listings to show links {{{2
    1              0.000001 fun! s:ShowLink()
                            " "  call Dfunc("s:ShowLink()")
                            " "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))
                            " "  call Decho(printf("line#%4d: %s",line("."),getline(".")),'~'.expand("<slnum>"))
                              if exists("b:netrw_curdir")
                               norm! $?\a
                               let fname   = b:netrw_curdir.'/'.s:NetrwGetWord()
                               let resname = resolve(fname)
                            " "   call Decho("fname         <".fname.">",'~'.expand("<slnum>"))
                            " "   call Decho("resname       <".resname.">",'~'.expand("<slnum>"))
                            " "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                               if resname =~ '^\M'.b:netrw_curdir.'/'
                                let dirlen  = strlen(b:netrw_curdir)
                                let resname = strpart(resname,dirlen+1)
                            " "    call Decho("resname<".resname.">  (b:netrw_curdir elided)",'~'.expand("<slnum>"))
                               endif
                               let modline = getline(".")."\t --> ".resname
                            " "   call Decho("fname  <".fname.">",'~'.expand("<slnum>"))
                            " "   call Decho("modline<".modline.">",'~'.expand("<slnum>"))
                               setl noro ma
                               call setline(".",modline)
                               setl ro noma nomod
                              endif
                            " "  call Dret("s:ShowLink".((exists("fname")? ' : '.fname : 'n/a')))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:ShowStyle: {{{2
    1              0.000002 fun! s:ShowStyle()
                              if !exists("w:netrw_liststyle")
                               let liststyle= g:netrw_liststyle
                              else
                               let liststyle= w:netrw_liststyle
                              endif
                              if     liststyle == s:THINLIST
                               return s:THINLIST.":thin"
                              elseif liststyle == s:LONGLIST
                               return s:LONGLIST.":long"
                              elseif liststyle == s:WIDELIST
                               return s:WIDELIST.":wide"
                              elseif liststyle == s:TREELIST
                               return s:TREELIST.":tree"
                              else
                               return 'n/a'
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
                            "           Solution from Nicolai Weibull, vim docs (:help strlen()),
                            "           Tony Mechelynck, and my own invention.
    1              0.000006 fun! s:Strlen(x)
                            "  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")
                            
                              if v:version >= 703 && exists("*strdisplaywidth")
                               let ret= strdisplaywidth(a:x)
                            
                              elseif type(g:Align_xstrlen) == 1
                               " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
                               exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"
                            
                              elseif g:Align_xstrlen == 1
                               " number of codepoints (Latin a + combining circumflex is two codepoints)
                               " (comment from TM, solution from NW)
                               let ret= strlen(substitute(a:x,'.','c','g'))
                            
                              elseif g:Align_xstrlen == 2
                               " number of spacing codepoints (Latin a + combining circumflex is one spacing
                               " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
                               " (comment from TM, solution from TM)
                               let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))
                            
                              elseif g:Align_xstrlen == 3
                               " virtual length (counting, for instance, tabs as anything between 1 and
                               " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
                               " preceded by lam, one otherwise, etc.)
                               " (comment from TM, solution from me)
                               let modkeep= &l:mod
                               exe "norm! o\<esc>"
                               call setline(line("."),a:x)
                               let ret= virtcol("$") - 1
                               d
                               NetrwKeepj norm! k
                               let &l:mod= modkeep
                            
                              else
                               " at least give a decent default
                                let ret= strlen(a:x)
                              endif
                            "  "" call Dret("s:Strlen ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:ShellEscape: shellescape(), or special windows handling {{{2
    1              0.000001 fun! s:ShellEscape(s, ...)
                              if (has('win32') || has('win64')) && $SHELL == '' && &shellslash
                                return printf('"%s"', substitute(a:s, '"', '""', 'g'))
                              endif 
                              let f = a:0 > 0 ? a:1 : 0
                              return shellescape(a:s, f)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:TreeListMove: supports [[, ]], [], and ][ in tree mode {{{2
    1              0.000001 fun! s:TreeListMove(dir)
                            "  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
                              let curline      = getline('.')
                              let prvline      = (line(".") > 1)?         getline(line(".")-1) : ''
                              let nxtline      = (line(".") < line("$"))? getline(line(".")+1) : ''
                              let curindent    = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
                              let indentm1     = substitute(curindent,'^'.s:treedepthstring,'','')
                              let treedepthchr = substitute(s:treedepthstring,' ','','g')
                              let stopline     = exists("w:netrw_bannercnt")? w:netrw_bannercnt : 1
                            "  call Decho("prvline  <".prvline."> #".(line(".")-1), '~'.expand("<slnum>"))
                            "  call Decho("curline  <".curline."> #".line(".")    , '~'.expand("<slnum>"))
                            "  call Decho("nxtline  <".nxtline."> #".(line(".")+1), '~'.expand("<slnum>"))
                            "  call Decho("curindent<".curindent.">"              , '~'.expand("<slnum>"))
                            "  call Decho("indentm1 <".indentm1.">"               , '~'.expand("<slnum>"))
                              "  COMBAK : need to handle when on a directory
                              "  COMBAK : need to handle ]] and ][.  In general, needs work!!!
                              if curline !~ '/$'
                               if     a:dir == '[[' && prvline != ''
                                NetrwKeepj norm! 0
                                let nl = search('^'.indentm1.'\%('.s:treedepthstring.'\)\@!','bWe',stopline) " search backwards
                            "    call Decho("regfile srch back: ".nl,'~'.expand("<slnum>"))
                               elseif a:dir == '[]' && nxtline != ''
                                NetrwKeepj norm! 0
                            "    call Decho('srchpat<'.'^\%('.curindent.'\)\@!'.'>','~'.expand("<slnum>"))
                                let nl = search('^\%('.curindent.'\)\@!','We') " search forwards
                                if nl != 0
                                 NetrwKeepj norm! k
                                else
                                 NetrwKeepj norm! G
                                endif
                            "    call Decho("regfile srch fwd: ".nl,'~'.expand("<slnum>"))
                               endif
                              endif
                            
                            "  call Dret("s:TreeListMove")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
                            "                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
                            "                      can't be called except via emenu.  But due to locale, that menu line may not be called
                            "                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
    1              0.000002 fun! s:UpdateBuffersMenu()
                            "  call Dfunc("s:UpdateBuffersMenu()")
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               try
                                sil emenu Buffers.Refresh\ menu
                               catch /^Vim\%((\a\+)\)\=:E/
                                let v:errmsg= ""
                                sil NetrwKeepj call s:NetrwBMShow()
                               endtry
                              endif
                            "  call Dret("s:UpdateBuffersMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
                            "              Matching function to s:SetBufWinVars()
    1              0.000001 fun! s:UseBufWinVars()
                            "  call Dfunc("s:UseBufWinVars()")
                              if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
                              if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
                              if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
                              if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
                              if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
                              if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
                              if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
                              if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
                              if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
                              if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
                            "  call Dret("s:UseBufWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:UserMaps: supports user-defined UserMaps {{{2
                            "               * calls a user-supplied funcref(islocal,curdir)
                            "               * interprets result
                            "             See netrw#UserMaps()
    1              0.000002 fun! s:UserMaps(islocal,funcname)
                            "  call Dfunc("s:UserMaps(islocal=".a:islocal.",funcname<".a:funcname.">)")
                            
                              if !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                              endif
                              let Funcref = function(a:funcname)
                              let result  = Funcref(a:islocal)
                            
                              if     type(result) == 1
                               " if result from user's funcref is a string...
                            "   call Decho("result string from user funcref<".result.">",'~'.expand("<slnum>"))
                               if result == "refresh"
                            "    call Decho("refreshing display",'~'.expand("<slnum>"))
                                call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               elseif result != ""
                            "    call Decho("executing result<".result.">",'~'.expand("<slnum>"))
                                exe result
                               endif
                            
                              elseif type(result) == 3
                               " if result from user's funcref is a List...
                            "   call Decho("result List from user funcref<".string(result).">",'~'.expand("<slnum>"))
                               for action in result
                                if action == "refresh"
                            "     call Decho("refreshing display",'~'.expand("<slnum>"))
                                 call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                                elseif action != ""
                            "     call Decho("executing action<".action.">",'~'.expand("<slnum>"))
                                 exe action
                                endif
                               endfor
                              endif
                            
                            "  call Dret("s:UserMaps")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " Settings Restoration: {{{1
    1              0.000015 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " ------------------------------------------------------------------------
                            " Modelines: {{{1
                            " vim:ts=8 fdm=marker

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/.netrwhist
Sourced 1 time
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
    1              0.000005 let g:netrw_dirhistmax  =10
    1              0.000002 let g:netrw_dirhist_cnt =4
    1              0.000002 let g:netrw_dirhist_1='/Users/cicloid/dotfiles/vim/.vim'
    1              0.000003 let g:netrw_dirhist_2='/Users/cicloid/dotfiles/vim/.vim/old_settings'
    1              0.000001 let g:netrw_dirhist_3='/Users/cicloid/dotfiles/vim/.vim'
    1              0.000002 let g:netrw_dirhist_4='/Users/cicloid/dotfiles/vim/.vim/settings'

SCRIPT  /usr/local/Cellar/vim/8.0.1650_1/share/vim/vim80/syntax/netrw.vim
Sourced 53 times
Total time:   0.025831
 Self time:   0.025831

count  total (s)   self (s)
                            " Language   : Netrw Listing Syntax
                            " Maintainer : Charles E. Campbell
                            " Last change: Oct 31, 2016
                            " Version    : 20	NOT RELEASED
                            " ---------------------------------------------------------------------
   53              0.000358 if exists("b:current_syntax")
                             finish
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Directory List Syntax Highlighting: {{{1
   53              0.000850 syn cluster NetrwGroup		contains=netrwHide,netrwSortBy,netrwSortSeq,netrwQuickHelp,netrwVersion,netrwCopyTgt
   53              0.000302 syn cluster NetrwTreeGroup	contains=netrwDir,netrwSymLink,netrwExe
                            
   53              0.000525 syn match  netrwPlain		"\(\S\+ \)*\S\+"					contains=netrwLink,@NoSpell
   53              0.000787 syn match  netrwSpecial		"\%(\S\+ \)*\S\+[*|=]\ze\%(\s\{2,}\|$\)"		contains=netrwClassify,@NoSpell
   53              0.000362 syn match  netrwDir		"\.\{1,2}/"						contains=netrwClassify,@NoSpell
   53              0.000581 syn match  netrwDir		"\%(\S\+ \)*\S\+/\ze\%(\s\{2,}\|$\)"			contains=netrwClassify,@NoSpell
   53              0.000481 syn match  netrwSizeDate	"\<\d\+\s\d\{1,2}/\d\{1,2}/\d\{4}\s"	skipwhite	contains=netrwDateSep,@NoSpell	nextgroup=netrwTime
   53              0.000422 syn match  netrwSymLink		"\%(\S\+ \)*\S\+@\ze\%(\s\{2,}\|$\)"  			contains=netrwClassify,@NoSpell
   53              0.000472 syn match  netrwExe		"\%(\S\+ \)*\S*[^~]\*\ze\%(\s\{2,}\|$\)" 		contains=netrwClassify,@NoSpell
   53              0.000296 if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
                            syn match  netrwTreeBar		"^\%([-+|│] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
                            else
   53              0.000351 syn match  netrwTreeBar		"^\%([-+|] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
   53              0.000046 endif
   53              0.000157 syn match  netrwTreeBarSpace	" "					contained
                            
   53              0.000282 syn match  netrwClassify	"[*=|@/]\ze\%(\s\{2,}\|$\)"		contained
   53              0.000193 syn match  netrwDateSep		"/"					contained
   53              0.000320 syn match  netrwTime		"\d\{1,2}:\d\{2}:\d\{2}"		contained	contains=netrwTimeSep
   53              0.000138 syn match  netrwTimeSep		":"
                            
   53              0.000302 syn match  netrwComment		'".*\%(\t\|$\)'						contains=@NetrwGroup,@NoSpell
   53              0.000406 syn match  netrwHide		'^"\s*\(Hid\|Show\)ing:'	skipwhite		contains=@NoSpell		nextgroup=netrwHidePat
   53              0.000146 syn match  netrwSlash		"/"				contained
   53              0.000304 syn match  netrwHidePat		"[^,]\+"			contained skipwhite	contains=@NoSpell		nextgroup=netrwHideSep
   53              0.000193 syn match  netrwHideSep		","				contained skipwhite					nextgroup=netrwHidePat
   53              0.000262 syn match  netrwSortBy		"Sorted by"			contained transparent skipwhite				nextgroup=netrwList
   53              0.000267 syn match  netrwSortSeq		"Sort sequence:"		contained transparent skipwhite			 	nextgroup=netrwList
   53              0.000317 syn match  netrwCopyTgt		"Copy/Move Tgt:"		contained transparent skipwhite				nextgroup=netrwList
   53              0.000332 syn match  netrwList		".*$"				contained		contains=netrwComma,@NoSpell
   53              0.000125 syn match  netrwComma		","				contained
   53              0.001720 syn region netrwQuickHelp	matchgroup=Comment start="Quick Help:\s\+" end="$"	contains=netrwHelpCmd,netrwQHTopic,@NoSpell	keepend contained
   53              0.000299 syn match  netrwHelpCmd		"\S\+\ze:"			contained skipwhite	contains=@NoSpell		nextgroup=netrwCmdSep
   53              0.000287 syn match  netrwQHTopic		"([a-zA-Z &]\+)"		contained skipwhite
   53              0.000188 syn match  netrwCmdSep		":"				contained nextgroup=netrwCmdNote
   53              0.000221 syn match  netrwCmdNote		".\{-}\ze  "			contained		contains=@NoSpell
   53              0.000225 syn match  netrwVersion		"(netrw.*)"			contained		contains=@NoSpell
   53              0.000291 syn match  netrwLink		"-->"				contained skipwhite
                            
                            " -----------------------------
                            " Special filetype highlighting {{{1
                            " -----------------------------
   53              0.000236 if exists("g:netrw_special_syntax") && g:netrw_special_syntax
                             if exists("+suffixes") && &suffixes != ""
                              let suflist= join(split(&suffixes,','))
                              let suflist= escape(substitute(suflist," ",'\\|','g'),'.~')
                              exe "syn match netrwSpecFile '\\(\\S\\+ \\)*\\S*\\(".suflist."\\)\\>'  contains=netrwTreeBar,@NoSpell"
                             endif
                             syn match netrwBak		"\(\S\+ \)*\S\+\.bak\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwCompress	"\(\S\+ \)*\S\+\.\%(gz\|bz2\|Z\|zip\)\>"		contains=netrwTreeBar,@NoSpell
                             if has("unix")
                              syn match netrwCoreDump	"\<core\%(\.\d\+\)\=\>"					contains=netrwTreeBar,@NoSpell
                             endif
                             syn match netrwLex		"\(\S\+ \)*\S\+\.\%(l\|lex\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwYacc		"\(\S\+ \)*\S\+\.y\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwData		"\(\S\+ \)*\S\+\.dat\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwDoc		"\(\S\+ \)*\S\+\.\%(doc\|txt\|pdf\|ps\|docx\)\>"	contains=netrwTreeBar,@NoSpell
                             syn match netrwHdr		"\(\S\+ \)*\S\+\.\%(h\|hpp\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwLib		"\(\S\+ \)*\S*\.\%(a\|so\|lib\|dll\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwMakeFile	"\<[mM]akefile\>\|\(\S\+ \)*\S\+\.mak\>"		contains=netrwTreeBar,@NoSpell
                             syn match netrwObj		"\(\S\+ \)*\S*\.\%(o\|obj\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwPix		"\c\(\S\+ \)*\S*\.\%(bmp\|fits\=\|gif\|je\=pg\|pcx\|ppc\|pgm\|png\|ppm\|psd\|rgb\|tif\|xbm\|xcf\)\>"	contains=netrwTreeBar,@NoSpell
                             syn match netrwTags		"\<\(ANmenu\|ANtags\)\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwTags    	"\<tags\>"						contains=netrwTreeBar,@NoSpell
                             syn match netrwTilde		"\(\S\+ \)*\S\+\~\*\=\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwTmp		"\<tmp\(\S\+ \)*\S\+\>\|\(\S\+ \)*\S*tmp\>"		contains=netrwTreeBar,@NoSpell
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Highlighting Links: {{{1
   53              0.000196 if !exists("did_drchip_netrwlist_syntax")
    1              0.000002  let did_drchip_netrwlist_syntax= 1
    1              0.000007  hi default link netrwClassify	Function
    1              0.000004  hi default link netrwCmdSep	Delimiter
    1              0.000004  hi default link netrwComment	Comment
    1              0.000004  hi default link netrwDir	Directory
    1              0.000004  hi default link netrwHelpCmd	Function
    1              0.000003  hi default link netrwQHTopic	Number
    1              0.000004  hi default link netrwHidePat	Statement
    1              0.000001  hi default link netrwHideSep	netrwComment
    1              0.000004  hi default link netrwList	Statement
    1              0.000004  hi default link netrwVersion	Identifier
    1              0.000004  hi default link netrwSymLink	Question
    1              0.000004  hi default link netrwExe	PreProc
    1              0.000003  hi default link netrwDateSep	Delimiter
                            
    1              0.000003  hi default link netrwTreeBar	Special
    1              0.000001  hi default link netrwTimeSep	netrwDateSep
    1              0.000007  hi default link netrwComma	netrwComment
    1              0.000002  hi default link netrwHide	netrwComment
    1              0.000008  hi default link netrwMarkFile	TabLineSel
    1              0.000003  hi default link netrwLink	Special
                            
                             " special syntax highlighting (see :he g:netrw_special_syntax)
    1              0.000007  hi default link netrwCoreDump	WarningMsg
    1              0.000007  hi default link netrwData	DiffChange
    1              0.000004  hi default link netrwHdr	netrwPlain
    1              0.000004  hi default link netrwLex	netrwPlain
    1              0.000006  hi default link netrwLib	DiffChange
    1              0.000007  hi default link netrwMakefile	DiffChange
    1              0.000004  hi default link netrwYacc	netrwPlain
    1              0.000007  hi default link netrwPix	Special
                            
    1              0.000007  hi default link netrwBak	netrwGray
    1              0.000004  hi default link netrwCompress	netrwGray
    1              0.000004  hi default link netrwSpecFile	netrwGray
    1              0.000004  hi default link netrwObj	netrwGray
    1              0.000004  hi default link netrwTags	netrwGray
    1              0.000004  hi default link netrwTilde	netrwGray
    1              0.000004  hi default link netrwTmp	netrwGray
    1              0.000001 endif
                            
                             " set up netrwGray to be understated (but not Ignore'd or Conceal'd, as those
                             " can be hard/impossible to read). Users may override this in a colorscheme by
                             " specifying netrwGray highlighting.
   53              0.000229  redir => s:netrwgray
   53              0.000279   sil hi netrwGray
   53              0.000156  redir END
   53              0.000238  if s:netrwgray !~ 'guifg'
   53              0.000198   if has("gui") && has("gui_running")
                               if &bg == "dark"
                                exe "hi netrwGray gui=NONE guifg=gray30"
                               else
                                exe "hi netrwGray gui=NONE guifg=gray70"
                               endif
                              else
   53              0.000537    hi link netrwGray	Folded
   53              0.000109   endif
   53              0.000047  endif
                            
                            " Current Syntax: {{{1
   53              0.000135 let   b:current_syntax = "netrwlist"
                            " ---------------------------------------------------------------------
                            " vim: ts=8 fdm=marker

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2017 C.Brabandt
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 let s:untracked_jobs = {}
    1              0.000001 let s:mq_jobs        = {}
    1              0.000001 let s:po_jobs        = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000003 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000002 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000002 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("[%s]", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000002 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000004 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                            
    1              0.000001   function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
    1              0.000006   function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
    1              0.000002   function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
    1              0.000001   function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
    1              0.000002   function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
                                else
                                  let cmd = ['sh', '-c', a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function! airline#async#get_msgfmt_stat(cmd, file)
                                if g:airline#init#is_windows || !executable('msgfmt')
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000002 elseif has("nvim")
                              " NVim specific functions
                            
                              function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
                              function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
                              function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
                              function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
                              function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
                                else
                                  let cmd = ['sh', '-c', a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                            endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000002 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                let id = jobstart(cmd, config)
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/ale/autoload/ale/statusline.vim
Sourced 1 time
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
                            " Author: KabbAmine <amine.kabb@gmail.com>
                            " Description: Statusline related function(s)
                            
    1              0.000005 function! s:CreateCountDict() abort
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
                                return {
                                \   '0': 0,
                                \   '1': 0,
                                \   'error': 0,
                                \   'warning': 0,
                                \   'info': 0,
                                \   'style_error': 0,
                                \   'style_warning': 0,
                                \   'total': 0,
                                \}
                            endfunction
                            
                            " Update the buffer error/warning count with data from loclist.
    1              0.000002 function! ale#statusline#Update(buffer, loclist) abort
                                if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
                                let l:count = s:CreateCountDict()
                                let l:count.total = len(l:loclist)
                            
                                for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
                                        let l:count.error += 1
                                    endif
                                endfor
                            
                                " Set keys for backwards compatibility.
                                let l:count[0] = l:count.error + l:count.style_error
                                let l:count[1] = l:count.total - l:count[0]
                            
                                let g:ale_buffer_info[a:buffer].count = l:count
                            endfunction
                            
                            " Get the counts for the buffer, and update the counts if needed.
    1              0.000002 function! s:GetCounts(buffer) abort
                                if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
                                if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
                                return g:ale_buffer_info[a:buffer].count
                            endfunction
                            
                            " Returns a Dictionary with counts for use in third party integrations.
    1              0.000002 function! ale#statusline#Count(buffer) abort
                                " The Dictionary is copied here before exposing it to other plugins.
                                return copy(s:GetCounts(a:buffer))
                            endfunction
                            
                            " This is the historical format setting which could be configured before.
    1              0.000002 function! s:StatusForListFormat() abort
                                let [l:error_format, l:warning_format, l:no_errors] = g:ale_statusline_format
                                let l:counts = s:GetCounts(bufnr(''))
                            
                                " Build strings based on user formatting preferences.
                                let l:errors = l:counts[0] ? printf(l:error_format, l:counts[0]) : ''
                                let l:warnings = l:counts[1] ? printf(l:warning_format, l:counts[1]) : ''
                            
                                " Different formats based on the combination of errors and warnings.
                                if empty(l:errors) && empty(l:warnings)
                                    let l:res = l:no_errors
                                elseif !empty(l:errors) && !empty(l:warnings)
                                    let l:res = printf('%s %s', l:errors, l:warnings)
                                else
                                    let l:res = empty(l:errors) ? l:warnings : l:errors
                                endif
                            
                                return l:res
                            endfunction
                            
                            " Returns a formatted string that can be integrated in the statusline.
                            "
                            " This function is deprecated, and should not be used. Use the airline plugin
                            " instead, or write your own status function with ale#statusline#Count()
    1              0.000001 function! ale#statusline#Status() abort
                                if !exists('g:ale_statusline_format')
                                    return 'OK'
                                endif
                            
                                if type(g:ale_statusline_format) == type([])
                                    return s:StatusForListFormat()
                                endif
                            
                                return ''
                            endfunction

SCRIPT  /Users/cicloid/dotfiles/vim/.vim/plugged/vim-misc/autoload/xolox/misc/escape.vim
Sourced 1 time
Total time:   0.000266
 Self time:   0.000266

count  total (s)   self (s)
                            " String escaping functions.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: May 19, 2013
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000005 function! xolox#misc#escape#pattern(string) " {{{1
                              " Takes a single string argument and converts it into a [:substitute]
                              " [subcmd] / [substitute()] [subfun] pattern string that matches the given
                              " string literally.
                              "
                              " [subfun]: http://vimdoc.sourceforge.net/htmldoc/eval.html#substitute()
                              " [subcmd]: http://vimdoc.sourceforge.net/htmldoc/change.html#:substitute
                              if type(a:string) == type('')
                                let string = escape(a:string, '^$.*\~[]')
                                return substitute(string, '\n', '\\n', 'g')
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! xolox#misc#escape#substitute(string) " {{{1
                              " Takes a single string argument and converts it into a [:substitute]
                              " [subcmd] / [substitute()] [subfun] replacement string that inserts the
                              " given string literally.
                              if type(a:string) == type('')
                                let string = escape(a:string, '\&~%')
                                return substitute(string, '\n', '\\r', 'g')
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#misc#escape#shell(string) " {{{1
                              " Takes a single string argument and converts it into a quoted command line
                              " argument.
                              "
                              " I was going to add a long rant here about Vim's ['shellslash' option]
                              " [shellslash], but really, it won't make any difference. Let's just suffice
                              " to say that I have yet to encounter a single person out there who uses
                              " this option for its intended purpose (running a UNIX style shell on
                              " Microsoft Windows).
                              "
                              " [shellslash]: http://vimdoc.sourceforge.net/htmldoc/options.html#'shellslash'
                              if xolox#misc#os#is_win()
                                try
                                  let ssl_save = &shellslash
                                  set noshellslash
                                  return shellescape(a:string)
                                finally
                                  let &shellslash = ssl_save
                                endtry
                              else
                                return shellescape(a:string)
                              endif
                            endfunction
                            
                            " vim: ts=2 sw=2 et

FUNCTION  LaTeXtoUnicode#Init()
Called 1 time
Total time:   0.000381
 Self time:   0.000337

count  total (s)   self (s)
    1              0.000003   let wait_insert_enter = a:0 > 0 ? a:1 : 1
                            
    1              0.000002   if !wait_insert_enter
    1              0.000004     augroup L2UInit
    1              0.000244       autocmd!
    1              0.000001     augroup END
    1              0.000001   endif
                            
    1   0.000034   0.000025   call s:L2U_UnsetTab()
    1   0.000020   0.000017   call s:L2U_UnsetAutoSub()
                            
    1   0.000041   0.000020   call s:L2U_SetTab(wait_insert_enter)
    1   0.000028   0.000017   call s:L2U_SetAutoSub(wait_insert_enter)

FUNCTION  <SNR>117_YRSetPrevOP()
Called 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000006     let s:yr_prev_op_code     = a:op_code
    1              0.000007     let s:yr_prev_op_mode     = a:mode
    1              0.000002     let s:yr_prev_count       = a:count
    1              0.000004     let s:yr_prev_changenr    = changenr()
    1              0.000002     let s:yr_prev_reg         = a:reg
    1              0.000014     let s:yr_prev_reg_unnamed = getreg('"')
    1              0.000007     let s:yr_prev_reg_small   = getreg('-')
    1              0.000006     let s:yr_prev_reg_insert  = getreg('.')
    1              0.000004     let s:yr_prev_vis_lstart  = line("'<")
    1              0.000003     let s:yr_prev_vis_lend    = line("'>")
    1              0.000003     let s:yr_prev_vis_cstart  = col("'<")
    1              0.000003     let s:yr_prev_vis_cend    = col("'>")
    1              0.000005     let s:yr_prev_reg_expres  = histget('=', -1)
                            
    1              0.000002     if a:mode == 'n'
                                    " In normal mode, the change has already
                                    " occurred, therefore we can mark the
                                    " actual position of the change.
    1              0.000009         let s:yr_prev_chg_lstart  = line("'[")
    1              0.000005         let s:yr_prev_chg_lend    = line("']")
    1              0.000003         let s:yr_prev_chg_cstart  = col("'[")
    1              0.000004         let s:yr_prev_chg_cend    = col("']")
    1              0.000001     else
                                    " If in operator pending mode, the change
                                    " has not yet occurred.  Therefore we cannot
                                    " use the '[ and ]' markers.  But we can
                                    " store the current line position.
                                    let s:yr_prev_chg_lstart  = line(".")
                                    let s:yr_prev_chg_lend    = line(".")
                                    let s:yr_prev_chg_cstart  = col(".")
                                    let s:yr_prev_chg_cend    = col(".")
                                endif
                            
                                " If storing the last change position (using '[, '])
                                " is not good enough, then another option is to:
                                " Use :redir on the :changes command
                                " and grab the last item.  Store this value
                                " and compare it is YRDoRepeat.

FUNCTION  <SNR>3_SynSet()
Called 62 times
Total time:   0.336931
 Self time:   0.129240

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   62              0.001576   syn clear
   62              0.000187   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
   62              0.000178   let s = expand("<amatch>")
   62              0.000092   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
   62              0.000080   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
  124              0.000530     for name in split(s, '\.')
   62   0.332965   0.125274       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   62              0.000180     endfor
   62              0.000043   endif

FUNCTION  netrw#CheckIfRemote()
Called 36 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
                            "  call Dfunc("netrw#CheckIfRemote()")
   36              0.000268   if expand("%") =~ '^\a\{3,}://'
                            "   call Dret("netrw#CheckIfRemote 1")
                               return 1
                              else
                            "   call Dret("netrw#CheckIfRemote 0")
   36              0.000016    return 0
                              endif

FUNCTION  xolox#misc#path#encode()
Called 2 times
Total time:   0.000097
 Self time:   0.000044

count  total (s)   self (s)
                              " Encode a pathname so it can be used as a filename. This uses URL encoding
                              " to encode special characters.
    2              0.000002   if s:windows_compatible
                                let mask = '[*|\\/:"<>?%]'
                              elseif xolox#misc#os#is_mac()
    2              0.000004     let mask = '[\\/%:]'
    2              0.000002   else
                                let mask = '[\\/%]'
                              endif
    2              0.000015   return substitute(a:path, mask, '\=printf("%%%x", char2nr(submatch(0)))', 'g')

FUNCTION  <SNR>22_Swift()
Called 8 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    8              0.000017   if !empty(&filetype)
    8              0.000005     return
                              endif
                            
                              let line = getline(1)
                              if line =~ "^#!.*swift"
                                setfiletype swift
                              endif

FUNCTION  <SNR>214_NetrwOpenFile()
Called 1 time
Total time:   0.061427
 Self time:   0.001864

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
    1              0.000008   let ykeep= @@
    1              0.000005   call inputsave()
    1              0.000886   let fname= input("Enter filename: ")
    1              0.000010   call inputrestore()
    1              0.000023   if fname !~ '[/\\]'
    1              0.000005    if exists("b:netrw_curdir")
    1              0.000003     if exists("g:netrw_quiet")
                                 let netrw_quiet_keep = g:netrw_quiet
                                endif
    1              0.000002     let g:netrw_quiet = 1
                                " save position for benefit of Rexplore
    1              0.000016     let s:rexposn_{bufnr("%")}= winsaveview()
                            "    call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
    1              0.000018     if b:netrw_curdir =~ '/$'
                                 exe "NetrwKeepj e ".fnameescape(b:netrw_curdir.fname)
                                else
    1   0.060419   0.000856      exe "e ".fnameescape(b:netrw_curdir."/".fname)
    1              0.000001     endif
    1              0.000003     if exists("netrw_quiet_keep")
                                 let g:netrw_quiet= netrw_quiet_keep
                                else
    1              0.000001      unlet g:netrw_quiet
    1              0.000001     endif
    1              0.000000    endif
    1              0.000001   else
                               exe "NetrwKeepj e ".fnameescape(fname)
                              endif
    1              0.000003   let @@= ykeep
                            "  call Dret("s:NetrwOpenFile")

FUNCTION  <SNR>182_lock_file_path()
Called 2 times
Total time:   0.000131
 Self time:   0.000100

count  total (s)   self (s)
    2   0.000041   0.000010   let directory = xolox#misc#option#get('session_lock_directory', '')
    2              0.000004   if empty(directory)
                                " Stale lock files can be really annoying, especially after a reboot
                                " because that just shouldn't happen - it's always a bug. References:
                                "  - https://github.com/xolox/vim-session/issues/97
                                "  - https://github.com/xolox/vim-session/issues/110
                                " One simple way to give a large group of users what they want is to use a
                                " volatile directory that is specifically meant for storing lock files.
                                " I've decided to make this the default when possible. The best reference
                                " I've been able to find on the proper system wide location for lock files
                                " is the following (yes, I know, it's Linux specific, so sue me):
                                " http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/var.html
    2              0.000004     let global_lock_directory = '/var/lock'
    2              0.000047     if filewritable(global_lock_directory) == 2
                                  let directory = global_lock_directory
                                endif
    2              0.000001   endif
    2              0.000005   if !empty(directory)
                                let pathname = xolox#misc#path#merge(directory, xolox#misc#path#encode(a:session_path))
                              else
    2              0.000003     let pathname = a:session_path
    2              0.000002   endif
    2              0.000004   return pathname . '.lock'

FUNCTION  <SNR>109_Map()
Called 74 times
Total time:   0.106648
 Self time:   0.006553

count  total (s)   self (s)
                              " Set mappings:
   74              0.000066   try
   74              0.000127     let save_keymap = &keymap
   74              0.000118     let save_iminsert = &iminsert
   74              0.000087     let save_imsearch = &imsearch
   74              0.000287     let save_cpo = &cpo
   74              0.000555     set keymap=
   74              0.000340     set cpo&vim
   74   0.003038   0.001953     silent! doautocmd <nomodeline> User delimitMate_map
   74   0.002300   0.000374     if s:get('autoclose')
   74   0.069123   0.000321       call s:AutoClose()
   74              0.000042     else
                                  call s:NoAutoClose()
                                endif
   74   0.028548   0.000266     call s:ExtraMappings()
   74              0.000069   finally
   74              0.000459     let &cpo = save_cpo
   74              0.000336     let &keymap = save_keymap
   74              0.000304     let &iminsert = save_iminsert
   74              0.000184     let &imsearch = save_imsearch
   74              0.000069   endtry
                            
   74              0.000112   let b:delimitMate_enabled = 1

FUNCTION  airline#util#exec_funcrefs()
Called 82 times
Total time:   0.047475
 Self time:   0.004384

count  total (s)   self (s)
  396              0.000486     for Fn in a:list
  396   0.045672   0.002581       let code = call(Fn, a:000)
  396              0.000384       if code != 0
   82              0.000080         return code
                                  endif
  314              0.000219     endfor
                                return 0

FUNCTION  RailsDetect()
Called 151 times
Total time:   0.047984
 Self time:   0.047984

count  total (s)   self (s)
  151              0.000350   if exists('b:rails_root')
                                return 1
                              endif
  151              0.002716   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
  151              0.000826   if fn =~# ':[\/]\{2\}'
                                return 0
                              endif
  151              0.000882   if !isdirectory(fn)
   24              0.000071     let fn = fnamemodify(fn, ':h')
   24              0.000029   endif
  151              0.040991   let file = findfile('config/environment.rb', escape(fn, ', ').';')
  151              0.000635   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
                                let b:rails_root = fnamemodify(file, ':p:h:h')
                                return 1
                              endif

FUNCTION  <SNR>211_print_status()
Called 432 times
Total time:   0.018768
 Self time:   0.018768

count  total (s)   self (s)
  432              0.000834 	let result = a:format
  432              0.004119 	let result = substitute(result, '%#\(.\{-}\)#', '<anzustatushighlight>\1<\/anzustatushighlight>', "g")
  432              0.002288 	let result = substitute(result, '%i', a:index, "g")
  432              0.001778 	let result = substitute(result, '%l', a:len, "g")
  432              0.001875 	let result = substitute(result, '%w', a:wrap, "g")
  432              0.001641 	let result = substitute(result, '%p', a:pattern, "g")
                            	" Fix \<homu\> to view
  432              0.004421 	let result = substitute(result, '%/', substitute(histget("/", -1), '\\', '\\\\', "g"), "g")
  432              0.000546 	return result

FUNCTION  <SNR>159_format_name()
Called 14 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   14              0.000020     return a:name

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000008   if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
    4              0.000004     return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  <SNR>45_buffer_spec()
Called 265 times
Total time:   0.007547
 Self time:   0.004066

count  total (s)   self (s)
  265              0.000677     let bufname = bufname(self['#'])
  265   0.006734   0.003253     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>110_get()
Called 2612 times
Total time:   0.037956
 Self time:   0.037956

count  total (s)   self (s)
 2612              0.002210   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
  244              0.000951     let bufoptions = get(s:options, bufnr('%'), {})
  244              0.000938     return deepcopy(get(bufoptions, a:name, a:1))
                              else
 2368              0.013493     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  airline#extensions#netrw#sortstring()
Called 179 times
Total time:   0.002224
 Self time:   0.002224

count  total (s)   self (s)
  179              0.001362   let order = (get(g:, 'netrw_sort_direction', 'n') =~ 'n') ? '+' : '-'
  179              0.000717   return g:netrw_sort_by . (g:airline_symbols.space) . '[' . order . ']'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 48 times
Total time:   0.001426
 Self time:   0.001426

count  total (s)   self (s)
   48              0.001350   return fnamemodify(s:file, ':p:h')

FUNCTION  ale#linter#Get()
Called 143 times
Total time:   0.034283
 Self time:   0.015509

count  total (s)   self (s)
  143              0.000313     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
  283              0.001246     for l:original_filetype in split(a:original_filetypes, '\.')
  140   0.008580   0.000918         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
  140   0.005359   0.000742         let l:linter_names = s:GetLinterNames(l:original_filetype)
  140   0.007198   0.000703         let l:all_linters = ale#linter#GetAll(l:filetype)
  140              0.000226         let l:filetype_linters = []
                            
  140              0.000632         if type(l:linter_names) == type('') && l:linter_names is# 'all'
  140              0.000271             let l:filetype_linters = l:all_linters
  140              0.000314         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
  140              0.000394         call extend(l:possibly_duplicated_linters, l:filetype_linters)
  140              0.000088     endfor
                            
  143              0.000221     let l:name_list = []
  143              0.000205     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
  205              0.000487     for l:linter in reverse(l:possibly_duplicated_linters)
   62              0.000203         if index(l:name_list, l:linter.name) < 0
   62              0.000173             call add(l:name_list, l:linter.name)
   62              0.000144             call add(l:combined_linters, l:linter)
   62              0.000039         endif
   62              0.000070     endfor
                            
  143              0.000294     return reverse(l:combined_linters)

FUNCTION  <SNR>182_prompt()
Called 1 time
Total time:   0.000373
 Self time:   0.000000

count  total (s)   self (s)
    1              0.000004   let option_value = eval(a:option_name)
    1              0.000001   if option_value == 'yes'
                                return 1
                              elseif option_value == 'no'
                                return 0
                              else
    1              0.000001     if g:session_verbose_messages
    1              0.000002       let format = "%s\n\nNote that you can permanently disable this dialog by adding the following line to your %s script:\n\n\t:let %s = 'no'"
    1   0.000019   0.000012       let prompt = printf(format, a:msg, xolox#misc#os#is_win() ? '~\_vimrc' : '~/.vimrc', a:option_name)
    1              0.000001     else
                                  let prompt = a:msg
                                endif
    1   0.000338   0.000000     return confirm(prompt, join(a:choices, "\n"), 1, 'Question')
                              endif

FUNCTION  <SNR>124_Leave()
Called 1 time
Total time:   0.000056
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000056   0.000022   call s:disableescape()

FUNCTION  <SNR>117_YRHistorySave()
Called 5 times
Total time:   0.001806
 Self time:   0.001806

count  total (s)   self (s)
    5              0.000019     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    5              0.000015     if len(s:yr_history_list) > g:yankring_max_history
                                    " Remove items which exceed the max # specified
                                    call remove(s:yr_history_list, g:yankring_max_history)
                                endif
                            
    5              0.001615     let rc = writefile(s:yr_history_list, yr_filename)
                            
    5              0.000011     if rc == 0
    5              0.000063         let s:yr_history_last_upd = getftime(yr_filename)
    5              0.000013         let s:yr_count = len(s:yr_history_list)
    5              0.000005     else
                                    call s:YRErrorMsg( 'YRHistorySave: Unable to save yankring history file: '. yr_filename )
                                endif

FUNCTION  <SNR>174_GetLinterNames()
Called 140 times
Total time:   0.004617
 Self time:   0.004617

count  total (s)   self (s)
  140              0.000447     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
  140              0.000218     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
  140              0.000366     if type(l:buffer_ale_linters) is type([])
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
  140              0.000331     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
  140              0.000330     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
  140              0.000162     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
  140              0.000381     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
  140              0.000126     return 'all'

FUNCTION  gitgutter#diff#process_hunk()
Called 4 times
Total time:   0.000559
 Self time:   0.000305

count  total (s)   self (s)
    4              0.000009   let modifications = []
    4              0.000008   let from_line  = a:hunk[0]
    4              0.000005   let from_count = a:hunk[1]
    4              0.000005   let to_line    = a:hunk[2]
    4              0.000004   let to_count   = a:hunk[3]
                            
    4   0.000046   0.000026   if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
    4   0.000075   0.000040     call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
    4   0.000223   0.000037     call gitgutter#hunk#increment_lines_removed(from_count)
                            
    4              0.000007   elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
                                call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(from_count)
                            
                              elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
    4              0.000004   return modifications

FUNCTION  airline#extensions#nrrwrgn#apply()
Called 28 times
Total time:   0.001860
 Self time:   0.001860

count  total (s)   self (s)
   28              0.000222   if exists(":WidenRegion") == 2
                                let spc = g:airline_symbols.space
                                if !exists("*nrrwrgn#NrrwRgnStatus()") || empty(nrrwrgn#NrrwRgnStatus())
                                  call a:1.add_section('airline_a', printf('%s[Narrowed%s#%d]', spc, spc, b:nrrw_instn))
                                  let bufname=(get(b:, 'orig_buf', 0) ? bufname(b:orig_buf) : substitute(bufname('%'), '^Nrrwrgn_\zs.*\ze_\d\+$', submatch(0), ''))
                                  call a:1.add_section('airline_c', spc.bufname.spc)
                                  call a:1.split()
                                else
                                  let dict=nrrwrgn#NrrwRgnStatus()
                                  let vmode = { 'v': 'Char ', 'V': 'Line ', '': 'Block '}
                                  let mode = dict.visual ? vmode[dict.visual] : vmode['V']
                                  let winwidth = winwidth(0)
                                  if winwidth < 80
                                    let mode = mode[0]
                                  endif
                                  let title = (winwidth < 80 ? "Nrrw" : "Narrowed ")
                                  let multi = (winwidth < 80 ? 'M' : 'Multi')
                                  call a:1.add_section('airline_a', printf('[%s%s%s#%d]%s', (dict.multi ? multi : ""), title, mode, b:nrrw_instn, spc))
                                  let name = dict.fullname
                                  if name !=# '[No Name]'
                                    if winwidth > 100
                                      " need some space
                                      let name = fnamemodify(dict.fullname, ':~')
                                      if strlen(name) > 8
                                        " shorten name
                                        let name = substitute(name, '\(.\)[^/\\]*\([/\\]\)', '\1\2', 'g')
                                      endif
                                    else
                                      let name = fnamemodify(dict.fullname, ':t')
                                    endif
                                  endif
                                  let range=(dict.multi ? '' : printf("[%d-%d]", dict.start[1], dict.end[1]))
                                  call a:1.add_section('airline_c', printf("%s %s %s", name, range, dict.enabled ? (&encoding ==? 'utf-8'  ? "\u2713"  : '')  : '!'))
                                  call a:1.split()
                                  call a:1.add_section('airline_x', get(g:, 'airline_section_x').spc)
                                  call a:1.add_section('airline_y', spc.get(g:, 'airline_section_y').spc)
                                  call a:1.add_section('airline_z', spc.get(g:, 'airline_section_z'))
                                endif
                                return 1
                              endif

FUNCTION  airline#extensions#term#apply()
Called 28 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
   28              0.000047   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  airline#statusline()
Called 770 times
Total time:   0.014643
 Self time:   0.014643

count  total (s)   self (s)
  770              0.006452   if has_key(s:contexts, a:winnr)
  770              0.006246     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 770 times
Total time:   1.110935
 Self time:   0.069459

count  total (s)   self (s)
  770              0.002461   let context = s:contexts[a:winnr]
                            
  770              0.002554   if get(w:, 'airline_active', 1)
  733              0.001958     let l:m = mode()
  733              0.001363     if l:m ==# "i"
    7              0.000012       let l:mode = ['insert']
    7              0.000008     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
    3              0.000006       let l:mode = ['visual']
    3              0.000003     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  723              0.001661       let l:mode = ['normal']
  723              0.000512     endif
  733              0.003772     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  733              0.000541   else
   37              0.000073     let l:mode = ['inactive']
   37              0.000186     let w:airline_current_mode = get(g:airline_mode_map, '__')
   37              0.000035   endif
                            
  770              0.002071   if g:airline_detect_modified && &modified
   86              0.000288     call add(l:mode, 'modified')
   86              0.000055   endif
                            
  770              0.001263   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  770              0.003090   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  770              0.001303   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  770              0.000973   if &readonly || ! &modifiable
  179              0.000549     call add(l:mode, 'readonly')
  179              0.000110   endif
                            
  770              0.004096   let mode_string = join(l:mode)
  770              0.002934   if get(w:, 'airline_lastmode', '') != mode_string
   52   0.014867   0.000467     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   52   1.027686   0.000610     call airline#highlighter#highlight(l:mode, context.bufnr)
   52              0.000320     let w:airline_lastmode = mode_string
   52              0.000038   endif
                            
  770              0.000711   return ''

FUNCTION  <SNR>182_unescape()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                              " Undo escaping of special characters (preceded by a backslash).
    1              0.000012   let s = substitute(a:s, '\\\(.\)', '\1', 'g')
                              " Expand any environment variables in the user input.
    1              0.000008   let s = substitute(s, '\(\$[A-Za-z0-9_]\+\)', '\=expand(submatch(1))', 'g')
    1              0.000001   return s

FUNCTION  airline#util#append()
Called 3878 times
Total time:   0.035865
 Self time:   0.035865

count  total (s)   self (s)
 3878              0.007392   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 3878              0.010736   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 3878              0.009970   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>207_EchoImpl()
Called 518 times
Total time:   0.154550
 Self time:   0.028683

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  518              0.002185     if mode() isnot# 'n'
    4              0.000006         return
                                endif
                            
  514   0.104664   0.004168     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
  514              0.001590     let l:buffer = bufnr('')
  514   0.030580   0.005209     let [l:info, l:loc] = s:FindItemAtCursor()
                            
  514              0.001273     if !empty(l:loc)
                                    let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                    let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    execute 'echo'
                                    let l:info.echoed = 0
                                endif

FUNCTION  <SNR>45_repo()
Called 1365 times
Total time:   0.032658
 Self time:   0.032658

count  total (s)   self (s)
 1365              0.008809   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
 1365              0.001836   if dir !=# ''
 1365              0.003340     if has_key(s:repos, dir)
 1365              0.003293       let repo = get(s:repos, dir)
 1365              0.000894     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
 1365              0.008463     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  ale#events#QuitRecently()
Called 2 times
Total time:   0.000118
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000011     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    2   0.000105   0.000023     return l:time && ale#util#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>78_shellslash()
Called 90 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
   90              0.000209   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
   90              0.000092     return a:path
                              endif

FUNCTION  <SNR>205_ShouldOpen()
Called 62 times
Total time:   0.002191
 Self time:   0.000761

count  total (s)   self (s)
   62   0.001753   0.000323     let l:val = ale#Var(a:buffer, 'open_list')
   62              0.000208     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   62              0.000142     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>182_vim_instance_id()
Called 2 times
Total time:   0.000287
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000010   let id = {'pid': getpid()}
    2              0.000005   if !empty(v:servername)
                                let id['servername'] = v:servername
                              endif
    2   0.000257   0.000019   if !xolox#session#include_tabs() || xolox#session#is_tab_scoped()
                                let id['tabpage'] = tabpagenr()
                              endif
    2              0.000002   return id

FUNCTION  xolox#session#save_colors()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Save the current color scheme and background color. The first argument is
                              " expected to be a list, it will be extended with the lines to be added to
                              " the session script.
    1              0.000005   call add(a:commands, 'if &background != ' . string(&background))
    1              0.000004   call add(a:commands, "\tset background=" . &background)
    1              0.000002   call add(a:commands, 'endif')
    1              0.000007   if exists('g:colors_name') && type(g:colors_name) == type('') && g:colors_name != ''
    1              0.000003     let template = "if !exists('g:colors_name') || g:colors_name != %s | colorscheme %s | endif"
    1              0.000011     call add(a:commands, printf(template, string(g:colors_name), fnameescape(g:colors_name)))
    1              0.000001   endif

FUNCTION  <SNR>182_check_special_window()
Called 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
                              " If we detected a special window and the argument to the command is not a
                              " pathname, this variable should be set to false to disable normalization.
    1              0.000002   let do_normalize_path = 1
    1              0.000004   let bufname = expand('%:t')
    1              0.000003   if exists('b:NERDTreeRoot')
                                if !has_key(s:nerdtrees, bufnr('%'))
                                  let command = 'NERDTree'
                                  let argument = b:NERDTreeRoot.path.str()
                                  let s:nerdtrees[bufnr('%')] = 1
                                else
                                  let command = 'NERDTreeMirror'
                                  let argument = ''
                                endif
                              elseif bufname == '[BufExplorer]'
                                let command = 'BufExplorer'
                                let argument = ''
                              elseif bufname == '__Tag_List__'
                                let command = 'Tlist'
                                let argument = ''
                              elseif exists('g:proj_running') && g:proj_running == bufnr('%')
                                let command = 'Project'
                                let argument = expand('%:p')
                              elseif exists('b:ConqueTerm_Idx')
                                let command = 'ConqueTerm'
                                let argument = g:ConqueTerm_Terminals[b:ConqueTerm_Idx]['program_name']
                                let do_normalize_path = 0
                              elseif &filetype == 'netrw'
                                let command = 'edit'
                                let argument = bufname('%')
                              elseif &buftype == 'quickfix'
                                let command = 'cwindow'
                                let argument = ''
                              endif
    1              0.000002   if exists('command')
                                call s:jump_to_window(a:session, tabpagenr(), winnr())
                                call add(a:session, 'let s:bufnr_save = bufnr("%")')
                                call add(a:session, 'let s:cwd_save = getcwd()')
                                if argument == ''
                                  call add(a:session, command)
                                else
                                  if do_normalize_path
                                    let argument = fnamemodify(argument, ':~')
                                    if xolox#session#options_include('slash')
                                      let argument = substitute(argument, '\', '/', 'g')
                                    endif
                                  endif
                                  call add(a:session, command . ' ' . fnameescape(argument))
                                endif
                                call s:cleanup_after_plugin(a:session, 's:bufnr_save')
                                call add(a:session, 'execute "cd" fnameescape(s:cwd_save)')
                                return 1
                              endif

FUNCTION  <SNR>142_LocalBrowse()
Called 33 times
Total time:   0.435474
 Self time:   0.002938

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
   33              0.000103   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
   33              0.000121   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
    8   0.433574   0.001038    sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
    8              0.000030    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
    8              0.000004   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
   25              0.000134   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>109_Unmap()
Called 61 times
Total time:   0.051616
 Self time:   0.045237

count  total (s)   self (s)
   61   0.008731   0.003559   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
 2013              0.001667   for map in imaps
 1952              0.025608     if maparg(map, "i") =~# '^<Plug>delimitMate'
  854              0.001108       if map == '|'
                                    let map = '<Bar>'
                                  endif
  854              0.004230       exec 'silent! iunmap <buffer> ' . map
  854              0.000423     endif
 1952              0.001446   endfor
   61   0.002862   0.001655   silent! doautocmd <nomodeline> User delimitMate_unmap
   61              0.000209   let b:delimitMate_enabled = 0

FUNCTION  ctrlp#utils#writecache()
Called 9 times
Total time:   0.009461
 Self time:   0.009269

count  total (s)   self (s)
    9   0.000285   0.000093 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    9              0.009136 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    9              0.000023 	en

FUNCTION  ale#linter#ResolveFiletype()
Called 140 times
Total time:   0.007662
 Self time:   0.001796

count  total (s)   self (s)
  140   0.006816   0.000950     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
  140              0.000406     if type(l:filetype) != type([])
  140              0.000205         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#highlight#RemoveHighlights()
Called 87 times
Total time:   0.001197
 Self time:   0.001197

count  total (s)   self (s)
   87              0.000394     for l:match in getmatches()
                                    if l:match.group =~# '^ALE'
                                        call matchdelete(l:match.id)
                                    endif
                                endfor

FUNCTION  <SNR>207_StopCursorTimer()
Called 492 times
Total time:   0.003848
 Self time:   0.003848

count  total (s)   self (s)
  492              0.000854     if s:cursor_timer != -1
  484              0.001229         call timer_stop(s:cursor_timer)
  484              0.000763         let s:cursor_timer = -1
  484              0.000335     endif

FUNCTION  <SNR>152_is_excluded_window()
Called 64 times
Total time:   0.002735
 Self time:   0.002735

count  total (s)   self (s)
   64              0.000169   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  256              0.000268   for matchw in g:airline_exclude_filenames
  192              0.001157     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  192              0.000100   endfor
                            
   64              0.000077   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   64              0.000035   return 0

FUNCTION  <SNR>117_YRCheckClipboard()
Called 1 time
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
    1              0.000002     if g:yankring_clipboard_monitor == 1
                                    " If the clipboard has changed record it inside the yankring
                                    " echomsg "YRCheckClipboard[".len(@*)."][".@*.']['.s:yr_prev_clipboard_star.']'
    1              0.000008         if has('unnamedplus') && &clipboard =~ '\<unnamedplus\>'
                                        if len(@+) > 0 && @+ != s:yr_prev_clipboard_plus
                                            let elem    = s:YRMRUElemFormat(   getreg('+') , getregtype('+') )
                                            let found   = s:YRMRUHas('s:yr_history_list', elem)
                            
                                            " Only add the item to the "top" of the ring if it is
                                            " not in the ring already.
                                            if found == -1
                                                call YRRecord3("+")
                                            endif
                                            let s:yr_prev_clipboard_plus = @+
                                        endif
                                    else
    1              0.000212             if len(@*) > 0 && @* != s:yr_prev_clipboard_star
                                            let elem    = s:YRMRUElemFormat(   getreg('*') , getregtype('*') )
                                            let found   = s:YRMRUHas('s:yr_history_list', elem)
                            
                                            " Only add the item to the "top" of the ring if it is
                                            " not in the ring already.
                                            if found == -1
                                                call YRRecord3("*")
                                            endif
                                            let s:yr_prev_clipboard_star = @*
                                        endif
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  netrw#UserMaps()
Called 18 times
Total time:   0.000401
 Self time:   0.000401

count  total (s)   self (s)
                            "  call Dfunc("netrw#UserMaps(islocal=".a:islocal.")")
                            "  call Decho("g:Netrw_UserMaps ".(exists("g:Netrw_UserMaps")? "exists" : "does NOT exist"),'~'.expand("<slnum>"))
                            
                               " set up usermaplist
   18              0.000067    if exists("g:Netrw_UserMaps") && type(g:Netrw_UserMaps) == 3
                            "    call Decho("g:Netrw_UserMaps has type 3<List>",'~'.expand("<slnum>"))
                                for umap in g:Netrw_UserMaps
                            "     call Decho("type(umap[0]<".string(umap[0]).">)=".type(umap[0])." (should be 1=string)",'~'.expand("<slnum>"))
                            "     call Decho("type(umap[1])=".type(umap[1])." (should be 1=string)",'~'.expand("<slnum>"))
                                 " if umap[0] is a string and umap[1] is a string holding a function name
                                 if type(umap[0]) == 1 && type(umap[1]) == 1
                            "      call Decho("nno <buffer> <silent> ".umap[0]." :call s:UserMaps(".a:islocal.",".string(umap[1]).")<cr>",'~'.expand("<slnum>"))
                                  exe "nno <buffer> <silent> ".umap[0]." :call <SID>UserMaps(".a:islocal.",'".umap[1]."')<cr>"
                                  else
                                   call netrw#ErrorMsg(s:WARNING,"ignoring usermap <".string(umap[0])."> -- not a [string,funcref] entry",99)
                                 endif
                                endfor
                               endif
                            "  call Dret("netrw#UserMaps")

FUNCTION  ale#sign#FindCurrentSigns()
Called 35 times
Total time:   0.007940
 Self time:   0.000483

count  total (s)   self (s)
   35   0.001206   0.000223     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   35   0.006691   0.000217     return ale#sign#ParseSigns(l:line_list)

FUNCTION  indent_guides#disable()
Called 109 times
Total time:   0.004728
 Self time:   0.001163

count  total (s)   self (s)
  109              0.000362   let g:indent_guides_autocmds_enabled = 0
  109   0.004117   0.000552   call indent_guides#clear_matches()

FUNCTION  gitgutter#sign#update_signs()
Called 22 times
Total time:   0.008738
 Self time:   0.001033

count  total (s)   self (s)
   22   0.004955   0.000209   call gitgutter#sign#find_current_signs()
                            
   22              0.000101   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
   22   0.001025   0.000158   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
   22              0.000067   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
   22              0.000020   if flicker_possible
    1   0.000060   0.000019     call gitgutter#sign#add_dummy_sign()
    1              0.000001   endif
                            
   22   0.000901   0.000111   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
   22   0.001340   0.000111   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
   22              0.000022   if flicker_possible
    1   0.000051   0.000019     call gitgutter#sign#remove_dummy_sign(0)
    1              0.000001   endif

FUNCTION  <SNR>74_Setup()
Called 62 times
Total time:   0.021284
 Self time:   0.000610

count  total (s)   self (s)
   62   0.020966   0.000292   call s:Detect(a:path)
   62              0.000124   if exists('b:rake_root')
                                silent doautocmd User Rake
                              endif

FUNCTION  ale#statusline#Count()
Called 936 times
Total time:   0.026089
 Self time:   0.008294

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  936   0.025179   0.007384     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>214_NetrwListSettings()
Called 18 times
Total time:   0.018996
 Self time:   0.002966

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
   18              0.000044   let fname= bufname("%")
                            "  "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro nornu",'~'.expand("<slnum>"))
   18   0.000437   0.000356   setl bt=nofile nobl ma nonu nowrap noro nornu
                            "  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
   18   0.017476   0.001527   exe "sil! keepalt file ".fnameescape(fname)
   18              0.000070   if g:netrw_use_noswf
   18              0.000104    setl noswf
   18              0.000010   endif
                            "  call Dredir("ls!")
                            "  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
   18              0.000120   exe "setl ts=".(g:netrw_maxfilenamelen+1)
   18              0.000478   setl isk+=.,~,-
   18              0.000030   if g:netrw_fastbrowse > a:islocal
                               setl bh=hide
                              else
   18              0.000079    setl bh=delete
   18              0.000010   endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwListSettings")

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 22 times
Total time:   0.000867
 Self time:   0.000668

count  total (s)   self (s)
   22   0.000125   0.000093   let bufnr = gitgutter#utility#bufnr()
   22              0.000025   let signs_to_remove = []  " list of [<id (number)>, ...]
   22              0.000030   let remove_all_signs = 1
   22   0.000251   0.000084   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
   25              0.000059   for line_number in keys(old_gitgutter_signs)
    3              0.000011     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
    3              0.000004       let remove_all_signs = 0
    3              0.000001     endif
    3              0.000002   endfor
   22              0.000065   let s:remove_all_old_signs = remove_all_signs
   22              0.000024   return signs_to_remove

FUNCTION  <SNR>117_YRYankRange()
Called 1 time
Total time:   0.001658
 Self time:   0.000196

count  total (s)   self (s)
                            
    1   0.000056   0.000013     let user_register  = s:YRRegister()
    1              0.000010     let default_buffer = ((&clipboard=~'\<unnamed\>')?'*':((&clipboard=~'\<unnamedplus\>' && has('unnamedplus'))?'+':'"'))
                            
                                " Default command mode to normal mode 'n'
    1              0.000002     let cmd_mode = 'n'
    1              0.000001     if a:0 > 0
                                    " Change to visual mode, if command executed via
                                    " a visual map
    1              0.000002         let cmd_mode = ((a:1 == 'v') ? 'v' : 'n')
    1              0.000000     endif
                            
    1              0.000001     if cmd_mode == 'v'
                                    " We are yanking either an entire line, or a range
    1              0.000095         exec "normal! gv". (user_register==default_buffer?'':'"'.user_register). 'y'
    1              0.000003         if a:do_delete_selection == 1
                                        exec "normal! gv". (user_register==default_buffer?'':'"'.user_register). 'd'
                                    endif
    1              0.000000     else
                                    " In normal mode, always yank the complete line, since this
                                    " command is for a range.  YRYankCount is used for parts
                                    " of a single line
                                    if a:do_delete_selection == 1
                                        exec a:firstline . ',' . a:lastline . 'delete '.user_register
                                    else
                                        exec a:firstline . ',' . a:lastline . 'yank ' . user_register
                                    endif
                                endif
                            
    1              0.000002     if user_register == '_'
                                    " Black hole register, ignore
                                    return
                                endif
                            
    1   0.000129   0.000024     call s:YRSetPrevOP('', '', user_register, 'n')
    1   0.001330   0.000016     call YRRecord(user_register)

FUNCTION  airline#extensions#quickfix#apply()
Called 46 times
Total time:   0.000468
 Self time:   0.000468

count  total (s)   self (s)
   46              0.000129   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#themes#get_highlight()
Called 1916 times
Total time:   0.222456
 Self time:   0.012070

count  total (s)   self (s)
 1916   0.221869   0.011483   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>182_eat_trailing_line()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                              " Remove matching, trailing strings from a list of strings.
    3              0.000009   if a:session[-1] == a:line
    3              0.000008     call remove(a:session, -1)
    3              0.000003   endif

FUNCTION  <SNR>214_NetrwSetSort()
Called 18 times
Total time:   0.045115
 Self time:   0.045115

count  total (s)   self (s)
                            "  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
   18              0.000034   let ykeep= @@
   18              0.000031   if w:netrw_liststyle == s:LONGLIST
                               let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
                              else
   18              0.000033    let seqlist  = g:netrw_sort_sequence
   18              0.000012   endif
                              " sanity check -- insure that * appears somewhere
   18              0.000023   if seqlist == ""
                               let seqlist= '*'
                              elseif seqlist !~ '\*'
                               let seqlist= seqlist.',*'
                              endif
   18              0.000020   let priority = 1
  252              0.000350   while seqlist != ""
  234              0.000613    if seqlist =~ ','
  216              0.005244     let seq     = substitute(seqlist,',.*$','','e')
  216              0.008753     let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
  216              0.000136    else
   18              0.000019     let seq     = seqlist
   18              0.000015     let seqlist = ""
   18              0.000006    endif
  234              0.000244    if priority < 10
  162              0.000432     let spriority= "00".priority.g:netrw_sepchr
  162              0.000145    elseif priority < 100
   72              0.000165     let spriority= "0".priority.g:netrw_sepchr
   72              0.000039    else
                                let spriority= priority.g:netrw_sepchr
                               endif
                            "   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">",'~'.expand("<slnum>"))
                            
                               " sanity check
  234              0.000477    if w:netrw_bannercnt > line("$")
                                " apparently no files were left after a Hiding pattern was used
                            "    call Dret("SetSort : no files left after hiding")
                                return
                               endif
  234              0.000258    if seq == '*'
   18              0.000026     let starpriority= spriority
   18              0.000011    else
  216              0.009541     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
  216              0.000536     call histdel("/",-1)
                                " sometimes multiple sorting patterns will match the same file or directory.
                                " The following substitute is intended to remove the excess matches.
  216              0.008603     exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
  216              0.001027     NetrwKeepj call histdel("/",-1)
  216              0.000132    endif
  234              0.000417    let priority = priority + 1
  234              0.000513   endwhile
   18              0.000044   if exists("starpriority")
   18              0.002317    exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
   18              0.000109    NetrwKeepj call histdel("/",-1)
   18              0.000014   endif
                            
                              " Following line associated with priority -- items that satisfy a priority
                              " pattern get prefixed by ###/ which permits easy sorting by priority.
                              " Sometimes files can satisfy multiple priority patterns -- only the latest
                              " priority pattern needs to be retained.  So, at this point, these excess
                              " priority prefixes need to be removed, but not directories that happen to
                              " be just digits themselves.
   18              0.001156   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
   18              0.000099   NetrwKeepj call histdel("/",-1)
   18              0.000042   let @@= ykeep
                            
                            "  call Dret("SetSort")

FUNCTION  fugitive#buffer()
Called 73 times
Total time:   0.002405
 Self time:   0.000417

count  total (s)   self (s)
   73   0.002365   0.000377   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  gitgutter#sign#find_current_signs()
Called 22 times
Total time:   0.004746
 Self time:   0.004084

count  total (s)   self (s)
   22   0.000100   0.000075   let bufnr = gitgutter#utility#bufnr()
   22              0.000030   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
   22              0.000028   let other_signs = []      " [<line_number (number),...]
   22              0.000024   let dummy_sign_placed = 0
                            
   22              0.000057   redir => signs
   22              0.000200     silent execute "sign place buffer=" . bufnr
   22              0.000050   redir END
                            
   61              0.000592   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   39              0.000846     let components  = split(sign_line)
   39              0.000210     let name        = split(components[2], '=')[1]
   39              0.000128     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   39              0.000209       let line_number = str2nr(split(components[0], '=')[1])
   39              0.000104       if name =~# 'GitGutter'
    3              0.000015         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
    3              0.000008         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
    3              0.000012         let gitgutter_signs[line_number] = {'id': id, 'name': name}
    3              0.000000       else
   36              0.000074         call add(other_signs, line_number)
   36              0.000024       endif
   39              0.000016     end
   39              0.000020   endfor
                            
   22   0.000346   0.000115   call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
   22   0.000281   0.000082   call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
   22   0.000281   0.000074   call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)

FUNCTION  ale#highlight#UpdateHighlights()
Called 68 times
Total time:   0.006447
 Self time:   0.005462

count  total (s)   self (s)
   68              0.000715     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   68   0.001428   0.000443     call ale#highlight#RemoveHighlights()
                            
   68              0.000109     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:line = l:item.lnum
                                    let l:col = l:item.col
                                    let l:end_line = get(l:item, 'end_lnum', l:line)
                                    let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
                                    call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
                                endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   68              0.000091     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  xolox#misc#path#decode()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                              " Decode a pathname previously encoded with `xolox#misc#path#encode()`.
    1              0.000005   return substitute(a:encoded_path, '%\(\x\x\?\)', '\=nr2char("0x" . submatch(1))', 'g')

FUNCTION  <SNR>214_LocalListing()
Called 18 times
Total time:   0.076012
 Self time:   0.046435

count  total (s)   self (s)
                            "  call Dfunc("s:LocalListing()")
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                            "  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist",'~'.expand("<slnum>")) |endif
                            "  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist",'~'.expand("<slnum>"))|endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " get the list of files contained in the current directory
   18              0.000032   let dirname    = b:netrw_curdir
   18              0.000050   let dirnamelen = strlen(b:netrw_curdir)
   18   0.008790   0.000123   let filelist   = s:NetrwGlob(dirname,"*",0)
   18   0.003975   0.000233   let filelist   = filelist + s:NetrwGlob(dirname,".*",0)
                            "  call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                            
   18              0.000154   if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                              elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
                                " include ../ in the glob() entry if its missing
                            "   call Decho("forcibly including on \"..\"",'~'.expand("<slnum>"))
                               let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
                            "   call Decho("filelist=".string(filelist),'~'.expand("<slnum>"))
                              endif
                            
                            "  call Decho("before while: dirname   <".dirname.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: dirnamelen<".dirnamelen.">",'~'.expand("<slnum>"))
                            "  call Decho("before while: filelist  =".string(filelist),'~'.expand("<slnum>"))
                            
   18              0.000044   if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
                               let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
                               let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
                            "   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy),'~'.expand("<slnum>"))
                            "   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen,'~'.expand("<slnum>"))
                              endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
  273              0.000331   for filename in filelist
                            "   call Decho(" ",'~'.expand("<slnum>"))
                            "   call Decho("for filename in filelist: filename<".filename.">",'~'.expand("<slnum>"))
                            
  255              0.002427    if getftype(filename) == "link"
                                " indicate a symbolic link
                            "    call Decho("indicate <".filename."> is a symbolic link with trailing @",'~'.expand("<slnum>"))
    9              0.000017     let pfile= filename."@"
                            
    9              0.000013    elseif getftype(filename) == "socket"
                                " indicate a socket
                            "    call Decho("indicate <".filename."> is a socket with trailing =",'~'.expand("<slnum>"))
                                let pfile= filename."="
                            
                               elseif getftype(filename) == "fifo"
                                " indicate a fifo
                            "    call Decho("indicate <".filename."> is a fifo with trailing |",'~'.expand("<slnum>"))
                                let pfile= filename."|"
                            
                               elseif isdirectory(s:NetrwFile(filename))
                                " indicate a directory
                            "    call Decho("indicate <".filename."> is a directory with trailing /",'~'.expand("<slnum>"))
   99              0.000204     let pfile= filename."/"
                            
   99              0.000353    elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(s:NetrwFile(filename))
  147              0.001247     if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
                                  " indicate an executable
                            "      call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                  let pfile= filename."*"
                                 else
                                  " normal file
                                  let pfile= filename
                                 endif
                                elseif executable(filename)
                                 " indicate an executable
                            "     call Decho("indicate <".filename."> is executable with trailing *",'~'.expand("<slnum>"))
                                 let pfile= filename."*"
                                else
                                 " normal file
  147              0.000232      let pfile= filename
  147              0.000081     endif
                            
  147              0.000078    else
                                " normal file
                                let pfile= filename
                               endif
                            "   call Decho("pfile<".pfile."> (after *@/ appending)",'~'.expand("<slnum>"))
                            
  255              0.002651    if pfile =~ '//$'
                                let pfile= substitute(pfile,'//$','/','e')
                            "    call Decho("change // to /: pfile<".pfile.">",'~'.expand("<slnum>"))
                               endif
  255              0.000699    let pfile= strpart(pfile,dirnamelen)
  255              0.001602    let pfile= substitute(pfile,'^[/\\]','','e')
                            "   call Decho("filename<".filename.">",'~'.expand("<slnum>"))
                            "   call Decho("pfile   <".pfile.">",'~'.expand("<slnum>"))
                            
  255              0.000465    if w:netrw_liststyle == s:LONGLIST
                                let sz   = getfsize(filename)
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                let fsz  = strpart("               ",1,15-strlen(sz)).sz
                                let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
                            "    call Decho("longlist support: sz=".sz." fsz=".fsz,'~'.expand("<slnum>"))
                               endif
                            
  255              0.000643    if     g:netrw_sort_by =~# "^t"
                                " sort by time (handles time up to 1 quintillion seconds, US)
                            "    call Decho("getftime(".filename.")=".getftime(filename),'~'.expand("<slnum>"))
                                let t  = getftime(filename)
                                let ft = strpart("000000000000000000",1,18-strlen(t)).t
                            "    call Decho("exe NetrwKeepj put ='".ft.'/'.filename."'",'~'.expand("<slnum>"))
                                let ftpfile= ft.'/'.pfile
                                sil! NetrwKeepj put=ftpfile
                            
                               elseif g:netrw_sort_by =~ "^s"
                                " sort by size (handles file sizes up to 1 quintillion bytes, US)
                            "    call Decho("getfsize(".filename.")=".getfsize(filename),'~'.expand("<slnum>"))
                                let sz   = getfsize(filename)
                                if g:netrw_sizestyle =~# "[hH]"
                                 let sz= s:NetrwHumanReadable(sz)
                                endif
                                let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
                            "    call Decho("exe NetrwKeepj put ='".fsz.'/'.filename."'",'~'.expand("<slnum>"))
                                let fszpfile= fsz.'/'.pfile
                                sil! NetrwKeepj put =fszpfile
                            
                               else
                                " sort by name
                            "    call Decho("exe NetrwKeepj put ='".pfile."'",'~'.expand("<slnum>"))
  255              0.001679     sil! NetrwKeepj put=pfile
  255              0.000183    endif
  255              0.000163   endfor
                            
                              " cleanup any windows mess at end-of-line
   18              0.000751   sil! NetrwKeepj g/^$/d
   18              0.000245   sil! NetrwKeepj %s/\r$//e
   18              0.000064   call histdel("/",-1)
                            "  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
   18              0.000183   exe "setl ts=".(g:netrw_maxfilenamelen+1)
                            
                            "  call Dret("s:LocalListing")

FUNCTION  <SNR>209_buffer_exec()
Called 24 times
Total time:   0.020303
 Self time:   0.000824

count  total (s)   self (s)
   24   0.000614   0.000247   let current_buffer = gitgutter#utility#bufnr()
   24   0.000800   0.000105   call gitgutter#utility#set_buffer(a:buffer)
                            
   24   0.002941   0.000104   if gitgutter#utility#is_active()
   24   0.015319   0.000178     call a:fn()
   24              0.000011   endif
                            
   24   0.000523   0.000084   call gitgutter#utility#set_buffer(current_buffer)

FUNCTION  <SNR>160_airline_ale_get_line_number()
Called 936 times
Total time:   0.002200
 Self time:   0.002200

count  total (s)   self (s)
  936              0.000991   if a:cnt == 0
  936              0.000724     return ''
                              endif
                            
                              let buffer       = bufnr('')
                              let problem_type = (a:type ==# 'error') ? 'E' : 'W'
                              let problems     = copy(ale#engine#GetLoclist(buffer))
                            
                              call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
                              if empty(problems)
                                return ''
                              endif
                            
                              let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  airline#parts#filetype()
Called 498 times
Total time:   0.003049
 Self time:   0.003049

count  total (s)   self (s)
  498              0.002771   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 46 times
Total time:   0.001423
 Self time:   0.001141

count  total (s)   self (s)
   46              0.000160   if &ft == 'netrw'
   18              0.000039     let spc = g:airline_symbols.space
                            
   18   0.000177   0.000099     call a:1.add_section('airline_a', spc.'netrw'.spc)
   18              0.000054     if exists('*airline#extensions#branch#get_head')
   18   0.000130   0.000080       call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
   18              0.000013     endif
   18   0.000106   0.000058     call a:1.add_section('airline_c', spc.'%f'.spc)
   18   0.000091   0.000042     call a:1.split()
   18   0.000136   0.000079     call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
   18              0.000015     return 1
                              endif

FUNCTION  xolox#misc#persist#save()
Called 1 time
Total time:   0.029838
 Self time:   0.000039

count  total (s)   self (s)
                              " Write a Vim value like a number, string, list or dictionary to a file
                              " using [string()][] and [writefile()][]. The first argument is the filename
                              " of the file to write (a string) and the second argument is the value to
                              " write (any value).
                              "
                              " This function writes the serialized value to an intermediate file which is
                              " then renamed into place atomically. This avoids issues with concurrent
                              " processes where for example a producer has written a partial file which is
                              " read by a consumer before the file is complete. In this case the consumer
                              " would read a corrupt value. The rename trick avoids this problem.
                              "
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
                              " [writefile()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#writefile()
    1   0.029833   0.000034   return xolox#misc#perm#update(a:filename, split(string(a:value), "\n"))

FUNCTION  xolox#session#find_current_session()
Called 1 time
Total time:   0.000341
 Self time:   0.000059

count  total (s)   self (s)
                              " Find the name of the current tab scoped or global session. Returns a
                              " string. If no session is active an empty string is returned.
    2              0.000003   for variable in ['t:this_session', 'v:this_session']
    2              0.000007     if exists(variable)
    1              0.000002       let filename = eval(variable)
    1              0.000002       if !empty(filename)
    1              0.000011         let directory = fnamemodify(filename, ':p:h')
    1   0.000277   0.000009         if xolox#misc#path#equals(directory, g:session_directory)
    1   0.000023   0.000009           return xolox#session#path_to_name(filename)
                                    endif
                                  endif
                                endif
    1              0.000003   endfor
                              return ''

FUNCTION  airline#parts#iminsert()
Called 554 times
Total time:   0.003436
 Self time:   0.003436

count  total (s)   self (s)
  554              0.001298   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  554              0.000392   return ''

FUNCTION  <SNR>211_searchpos_all()
Called 34 times
Total time:   0.002478
 Self time:   0.002478

count  total (s)   self (s)
   34              0.000118 	let old_pos =getpos(".")
   34              0.000046 	let result = []
   34              0.000033 	try
   34              0.000316 		call setpos(".", [0, line("$"), strlen(getline("$")), 0])
   38              0.000053 		while 1
   38              0.001083 			silent! let pos = searchpos(a:pattern, "w")
   38              0.000155 			if pos == [0, 0] || index(result, pos) != -1
   34              0.000047 				break
                            			endif
    4              0.000009 			call add(result, pos)
    4              0.000010 			if len(result) >= g:anzu_search_limit
                            				break
                            			endif
    4              0.000003 		endwhile
   34              0.000042 	finally
   34              0.000086 		call setpos(".", old_pos)
   34              0.000032 	endtry
   34              0.000046 	return result

FUNCTION  gitgutter#sign#remove_signs()
Called 22 times
Total time:   0.000790
 Self time:   0.000518

count  total (s)   self (s)
   22   0.000106   0.000079   let bufnr = gitgutter#utility#bufnr()
   22   0.000255   0.000111   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
   14   0.000151   0.000050     let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
   14              0.000060     execute "sign unplace * buffer=" . bufnr
   14              0.000014     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
   14              0.000008   else
    8              0.000013     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    8              0.000005   endif

FUNCTION  <SNR>171_get_seperator()
Called 276 times
Total time:   0.194966
 Self time:   0.003165

count  total (s)   self (s)
  276   0.068262   0.001482   if s:should_change_group(a:prev_group, a:group)
  250   0.126380   0.001359     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
   26              0.000049     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>152_check_defined_section()
Called 28 times
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
   28              0.000161   if !exists('w:airline_section_{a:name}')
   28              0.000123     let w:airline_section_{a:name} = g:airline_section_{a:name}
   28              0.000017   endif

FUNCTION  gitgutter#utility#use_known_shell()
Called 37 times
Total time:   0.000998
 Self time:   0.000998

count  total (s)   self (s)
   37              0.000088   if has('unix')
   37              0.000075     if &shell !=# 'sh'
   37              0.000073       let s:shell = &shell
   37              0.000093       let s:shellcmdflag = &shellcmdflag
   37              0.000065       let s:shellredir = &shellredir
   37              0.000166       let &shell = 'sh'
   37              0.000163       set shellcmdflag=-c
   37              0.000089       set shellredir=>%s\ 2>&1
   37              0.000023     endif
   37              0.000017   endif

FUNCTION  <SNR>214_NetrwGetBuffer()
Called 18 times
Total time:   0.142344
 Self time:   0.004374

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
   18              0.000045   let dirname= a:dirname
                            
                              " re-use buffer if possible {{{3
                            "  call Decho("--re-use a buffer if possible--",'~'.expand("<slnum>"))
   18              0.000052   if !exists("s:netrwbuf")
    1              0.000001    let s:netrwbuf= {}
    1              0.000001   endif
   18   0.000710   0.000135   if has_key(s:netrwbuf,s:NetrwFullPath(dirname))
   14   0.000426   0.000079    let bufnum= s:netrwbuf[s:NetrwFullPath(dirname)]
                            "   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnum)
   14              0.000033    if !bufexists(bufnum)
                                call remove(s:netrwbuf,s:NetrwFullPath(dirname))
                                let bufnum= -1
                               endif
   14              0.000007   else
                            "   call Decho("lookup netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."] not a key")
    4              0.000004    let bufnum= -1
    4              0.000002   endif
                            
                              " get enew buffer and name it -or- re-use buffer {{{3
   18              0.000017   if bufnum < 0      " get enew buffer and name it
                            "   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)",'~'.expand("<slnum>"))
    4   0.107855   0.000045    call s:NetrwEnew(dirname)
                            "   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)",'~'.expand("<slnum>"))
                               " name the buffer
    4              0.000015    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                " Got enew buffer; transform into a NetrwTreeListing
                            "    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --",'~'.expand("<slnum>"))
                                if !exists("s:netrw_treelistnum")
                                 let s:netrw_treelistnum= 1
                                else
                                 let s:netrw_treelistnum= s:netrw_treelistnum + 1
                                endif
                                let w:netrw_treebufnr= bufnr("%")
                            "    call Decho("  exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum),'~'.expand("<slnum>"))
                                exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
                                if g:netrw_use_noswf
                                 setl nobl bt=nofile noswf
                                else
                                 setl nobl bt=nofile
                                endif
                                nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[[')<cr>
                                nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']]')<cr>
                                nnoremap <silent> <buffer> []       :sil call <SID>TreeListMove('[]')<cr>
                                nnoremap <silent> <buffer> ][       :sil call <SID>TreeListMove('][')<cr>
                            "    call Decho("  tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr,'~'.expand("<slnum>"))
                               else
                            "    let v:errmsg   = "" " Decho
    4              0.000028     let escdirname = fnameescape(dirname)
                            "    call Decho("  errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
                            "    call Decho('  exe sil! keepalt file '.escdirname,'~'.expand("<slnum>"))
                            "    let v:errmsg= "" " Decho
    4   0.005585   0.000426     exe 'sil! keepj keepalt file '.escdirname
                            "    call Decho("  errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">",'~'.expand("<slnum>"))
                                " enter the new buffer into the s:netrwbuf dictionary
    4   0.000154   0.000032     let s:netrwbuf[s:NetrwFullPath(dirname)]= bufnr("%")
                            "    call Decho("update netrwbuf dictionary: s:netrwbuf[".s:NetrwFullPath(dirname)."]=".bufnr("%"),'~'.expand("<slnum>"))
                            "    call Decho("netrwbuf dictionary=".string(s:netrwbuf),'~'.expand("<slnum>"))
    4              0.000002    endif
                            "   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
    4              0.000003   else " Re-use the buffer
                            "   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)",'~'.expand("<slnum>"))
   14              0.000053    let eikeep= &ei
   14              0.000103    setl ei=all
   14              0.000162    if getline(2) =~# '^" Netrw Directory Listing'
                            "    call Decho("  getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum,'~'.expand("<slnum>"))
    7              0.000308     exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
    7              0.000006    else
                            "    call Decho("  getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum,'~'.expand("<slnum>"))
    7              0.000334     exe "sil! NetrwKeepj noswapfile keepalt b ".bufnum
    7              0.000006    endif
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
   14              0.000044    if bufname("%") == '.'
                            "    call Decho("exe sil! keepalt file ".fnameescape(getcwd()),'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj keepalt file ".fnameescape(getcwd())
                               endif
   14              0.000063    let &ei= eikeep
                            
   14              0.000048    if line("$") <= 1 && getline(1) == ""
                                " empty buffer
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
                                return 0
                            
                               elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
                            "    call Decho("g:netrw_fastbrowse=".g:netrw_fastbrowse." a:islocal=".a:islocal.": clear buffer",'~'.expand("<slnum>"))
   14   0.013587   0.000157     NetrwKeepj call s:NetrwListSettings(a:islocal)
   14              0.000425     sil NetrwKeepj %d _
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
   14              0.000017     return 0
                            
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "    call Decho("--re-use tree listing--",'~'.expand("<slnum>"))
                            "    call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                                sil NetrwKeepj %d _
                                NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
                                return 0
                            
                               else
                            "    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwGetBuffer 1<buffer not cleared>")
                                return 1
                               endif
                              endif
                            
                              " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
                              "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
                              "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
                              "  med    1         D      H
                              "  fast   2         H      H
                            "  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--",'~'.expand("<slnum>"))
    4              0.000009   let fname= expand("%")
    4   0.005607   0.000041   NetrwKeepj call s:NetrwListSettings(a:islocal)
                            "  call Decho("exe sil! keepalt file ".fnameescape(fname),'~'.expand("<slnum>"))
    4   0.005369   0.000408   exe "sil! NetrwKeepj keepalt file ".fnameescape(fname)
                            
                              " delete all lines from buffer {{{3
                            "  call Decho("--delete all lines from buffer--",'~'.expand("<slnum>"))
                            "  call Decho("  clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
    4              0.000026   sil! keepalt NetrwKeepj %d _
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwGetBuffer 0<cleared buffer>")
    4              0.000004   return 0

FUNCTION  <SNR>159_update_branch()
Called 647 times
Total time:   0.251840
 Self time:   0.073275

count  total (s)   self (s)
  647              0.040807   let b:airline_fname_path = get(b:, 'airline_fname_path', exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h"))
 1941              0.004515   for vcs in keys(s:vcs_config)
 1294   0.189611   0.011046     call {s:vcs_config[vcs].update_branch}(b:airline_fname_path)
 1294              0.004758     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
   13              0.000037       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
   13              0.000021       unlet! b:airline_head
   13              0.000005     endif
 1294              0.001012   endfor

FUNCTION  <SNR>217_on_exit_untracked()
Called 19 times
Total time:   0.001267
 Self time:   0.000476

count  total (s)   self (s)
   19   0.001054   0.000263     call s:untracked_output(self, self.buf)
   19              0.000065     if has_key(s:untracked_jobs, self.file)
   11              0.000043       call remove(s:untracked_jobs, self.file)
   11              0.000007     endif

FUNCTION  gitgutter#utility#system()
Called 1 time
Total time:   0.014767
 Self time:   0.000532

count  total (s)   self (s)
    1   0.000034   0.000005   call gitgutter#debug#log(a:cmd, a:000)
                            
    1   0.000016   0.000003   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
    1   0.014692   0.000499     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    1              0.000006   endif
    1              0.000007   return output

FUNCTION  gitgutter#process_buffer()
Called 37 times
Total time:   0.065742
 Self time:   0.005015

count  total (s)   self (s)
   37   0.001192   0.000194   call gitgutter#utility#use_known_shell()
                            
   37   0.000936   0.000156   call gitgutter#utility#set_buffer(a:bufnr)
   37   0.002529   0.000140   if gitgutter#utility#is_active()
   24              0.000040     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
   24              0.000016     try
   24   0.000120   0.000068       if !a:realtime || gitgutter#utility#has_fresh_changes()
   22   0.052603   0.001139         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
   22              0.000120         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
   22              0.000009       endif
   24              0.000113     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
   24   0.004393   0.001430     execute "silent doautocmd" s:nomodeline "User GitGutter"
   24              0.000036   else
   13   0.000891   0.000087     call gitgutter#hunk#reset()
   13              0.000011   endif
                            
   37   0.001586   0.000309   call gitgutter#utility#restore_shell()

FUNCTION  gitgutter#hunk#summary()
Called 463 times
Total time:   0.010691
 Self time:   0.004265

count  total (s)   self (s)
  463   0.010322   0.003896   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>78_Setup()
Called 62 times
Total time:   0.017163
 Self time:   0.000489

count  total (s)   self (s)
   62   0.016995   0.000321   if s:Detect(a:path)
                                silent doautocmd User Bundler
                              endif

FUNCTION  <SNR>172_build_sections()
Called 92 times
Total time:   0.024635
 Self time:   0.004109

count  total (s)   self (s)
  496              0.000478   for key in a:keys
  404              0.000905     if (key == 'warning' || key == 'error') && !a:context.active
   72              0.000054       continue
                                endif
  332   0.021913   0.001387     call s:add_section(a:builder, a:context, key)
  332              0.000235   endfor

FUNCTION  xolox#session#save_features()
Called 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
                              " Save the current state of the following Vim features:
                              "
                              " - Whether syntax highlighting is enabled (`:syntax on`)
                              " - Whether file type detection is enabled (`:filetype on`)
                              " - Whether file type plug-ins are enabled (`:filetype plugin on`)
                              " - Whether file type indent plug-ins are enabled (`:filetype indent on`)
                              "
                              " The first argument is expected to be a list, it will be extended with the
                              " lines to be added to the session script.
    1              0.000002   let template = "if exists('%s') != %i | %s %s | endif"
    5              0.000017   for [global, command] in [ ['g:syntax_on', 'syntax'], ['g:did_load_filetypes', 'filetype'], ['g:did_load_ftplugin', 'filetype plugin'], ['g:did_indent_on', 'filetype indent']]
    4              0.000013     let active = exists(global)
    4              0.000007     let toggle = active ? 'on' : 'off'
    4              0.000026     call add(a:commands, printf(template, global, active, command, toggle))
    4              0.000004   endfor

FUNCTION  <SNR>43_GetMarkLine()
Called 953 times
Total time:   0.014266
 Self time:   0.014266

count  total (s)   self (s)
  953              0.001118     if v:version < 700
                                    let lnum = line(a:mark)
                                else
  953              0.004298         let pos = getpos(a:mark)
  953              0.001538         let lnum = pos[1]
  953              0.001890         if pos[0] && bufnr("%") != pos[0]
   95              0.000095             let lnum = 0
   95              0.000052         endif
  953              0.000480     endif
  953              0.000737     return lnum

FUNCTION  <SNR>57_dopopd()
Called 14 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   14              0.000075   if !exists('w:fzf_dir') || s:fzf_getcwd() != w:fzf_dir[1]
   14              0.000012     return
                              endif
                              execute 'lcd' s:escape(w:fzf_dir[0])
                              unlet w:fzf_dir

FUNCTION  <SNR>186_RunLinter()
Called 26 times
Total time:   0.005265
 Self time:   0.000756

count  total (s)   self (s)
   26              0.000076     if !empty(a:linter.lsp)
                                    return s:CheckWithLSP(a:buffer, a:linter)
                                else
   26   0.000406   0.000207         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   26   0.004484   0.000174         if ale#engine#IsExecutable(a:buffer, l:executable)
                                        return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
   26              0.000026     endif
                            
   26              0.000023     return 0

FUNCTION  <SNR>158_get_hunks()
Called 468 times
Total time:   0.035618
 Self time:   0.012815

count  total (s)   self (s)
  468              0.002866   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    9              0.000028     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    9              0.000016       let b:source_func = 's:get_hunks_gitgutter'
    9              0.000012     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    9              0.000004   endif
  468   0.025550   0.002747   return {b:source_func}()

FUNCTION  gitgutter#utility#not_git_dir()
Called 48 times
Total time:   0.003051
 Self time:   0.001625

count  total (s)   self (s)
   48   0.002998   0.001572   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  fugitive#detect()
Called 61 times
Total time:   0.076372
 Self time:   0.014806

count  total (s)   self (s)
   61              0.000600   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
   61              0.000133   if !exists('b:git_dir')
   12   0.007778   0.000093     let dir = fugitive#extract_git_dir(a:path)
   12              0.000015     if dir !=# ''
   12              0.000019       let b:git_dir = dir
   12   0.007315   0.000156       if empty(fugitive#buffer().path())
    1              0.000049         silent! exe haslocaldir() ? 'lcd .' : 'cd .'
    1              0.000001       endif
   12              0.000007     endif
   12              0.000005   endif
   61              0.000112   if exists('b:git_dir')
   61              0.000459     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
   61              0.000144     if !exists('g:fugitive_no_maps')
   61              0.003388       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
   61              0.001178       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
   61              0.000056     endif
   61   0.002247   0.000253     let buffer = fugitive#buffer()
   61              0.001383     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
   61   0.000720   0.000497     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
   61              0.000743       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
   61              0.000792       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
   61              0.000033     endif
   61              0.000042     try
   61              0.000478       let [save_mls, &modelines] = [&mls, 0]
   61   0.018358   0.000273       call s:define_commands()
   61   0.027692   0.001272       doautocmd User Fugitive
   61              0.000085     finally
   61              0.000342       let &mls = save_mls
   61              0.000056     endtry
   61              0.000024   endif

FUNCTION  <SNR>160_ale_refresh()
Called 4 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    4              0.000013   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  <SNR>182_jump_to_window()
Called 1 time
Total time:   0.000128
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004   call add(a:session, a:window . 'wincmd w')
    1   0.000117   0.000003   if xolox#session#include_tabs()
    1              0.000004     call add(a:session, 'tabnext ' . a:tabpage)
    1              0.000000   endif

FUNCTION  <SNR>45_repo_dir()
Called 1400 times
Total time:   0.008377
 Self time:   0.008377

count  total (s)   self (s)
 1400              0.007910   return join([self.git_dir]+a:000,'/')

FUNCTION  gitgutter#utility#getbufvar()
Called 613 times
Total time:   0.007608
 Self time:   0.007608

count  total (s)   self (s)
  613              0.004128   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  613              0.001605   if has_key(dict, a:varname)
  597              0.001132     return dict[a:varname]
                              else
   16              0.000010     if a:0
   15              0.000013       return a:1
                                endif
    1              0.000000   endif

FUNCTION  ale#Var()
Called 2056 times
Total time:   0.058820
 Self time:   0.058820

count  total (s)   self (s)
 2056              0.008212     let l:nr = str2nr(a:buffer)
 2056              0.006466     let l:full_name = 'ale_' . a:variable_name
                            
 2056              0.005009     if bufexists(l:nr)
 2056              0.006697         let l:vars = getbufvar(l:nr, '')
 2056              0.004572     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
 2056              0.009656     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  gitgutter#utility#shellescape()
Called 75 times
Total time:   0.002166
 Self time:   0.001798

count  total (s)   self (s)
   75              0.001291   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   53              0.000062     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
   22              0.000067     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>43_NameOfMark()
Called 953 times
Total time:   0.008376
 Self time:   0.008376

count  total (s)   self (s)
  953              0.001193 	let name = a:mark
  953              0.003314 	if a:mark =~# '\W'
  156              0.000460 		let name = stridx(s:all_marks, a:mark) + 10
  156              0.000081 	endif
  953              0.000848 	return name

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 22 times
Total time:   0.001229
 Self time:   0.000881

count  total (s)   self (s)
   22   0.000087   0.000064   let bufnr = gitgutter#utility#bufnr()
   22   0.000241   0.000084   let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
   22   0.000228   0.000089   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
   26              0.000033   for line in a:modified_lines
    4              0.000007     let line_number = line[0]  " <number>
    4              0.000009     if index(other_signs, line_number) == -1  " don't clobber others' signs
    4   0.000068   0.000046       let name = gitgutter#utility#highlight_name_for_change(line[1])
    4              0.000011       if !has_key(old_gitgutter_signs, line_number)  " insert
    1   0.000026   0.000019         let id = gitgutter#sign#next_sign_id()
    1              0.000010         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
    1              0.000001       else  " update if sign has changed
    3              0.000006         let old_sign = old_gitgutter_signs[line_number]
    3              0.000006         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
    3              0.000000       endif
    4              0.000002     endif
    4              0.000002   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>22_SelectJavascript()
Called 9 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    9              0.000048   if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
                                set ft=javascript
                              endif

FUNCTION  ale#ShouldDoNothing()
Called 657 times
Total time:   0.118215
 Self time:   0.058336

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  657              0.003536     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files
  657              0.005620     if index(g:ale_filetype_blacklist, getbufvar(a:buffer, '&filetype')) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode
  657              0.003275     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
  657              0.004498     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
  657              0.001449     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox
  657   0.013654   0.003807     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if ALE is disabled.
  657   0.025950   0.004223     if !ale#Var(a:buffer, 'enabled')
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
  657   0.032393   0.004088     if ale#FileTooLarge()
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  657              0.008941     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
  657              0.000639     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 468 times
Total time:   0.035881
 Self time:   0.003253

count  total (s)   self (s)
  468   0.035467   0.002839   return airline#extensions#ale#get('error')

FUNCTION  <SNR>205_BufWinId()
Called 31 times
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
   31              0.000242     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  <SNR>154_invoke_funcrefs()
Called 82 times
Total time:   0.364075
 Self time:   0.003292

count  total (s)   self (s)
   82   0.002228   0.000444   let builder = airline#builder#new(a:context)
   82   0.048234   0.000759   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   82              0.000068   if err == 1
   82   0.312032   0.000508     let a:context.line = builder.build()
   82              0.000583     let s:contexts[a:context.winnr] = a:context
   82              0.000750     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   82              0.000043   endif

FUNCTION  <SNR>22_L2UTrigger()
Called 33 times
Total time:   0.007854
 Self time:   0.007854

count  total (s)   self (s)
   33              0.000150   augroup L2UInit
   33              0.007403     autocmd!
   33              0.000231     autocmd InsertEnter *            let g:did_insert_enter = 1 | call LaTeXtoUnicode#Init(0)
   33              0.000024   augroup END

FUNCTION  xolox#session#auto_save()
Called 1 time
Total time:   0.068411
 Self time:   0.000315

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000001   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
                              endif
    1              0.000002   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
                                return
                              endif
                              " Get the name of the session for automatic saving.
    1   0.000024   0.000010   let name = xolox#misc#option#get('session_autosave_to')
    1              0.000001   if empty(name)
                                " Get the name of the active session (if any).
    1   0.000349   0.000008     let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
    1              0.000003     if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
    1              0.000001   endif
                              " Prompt the user to save the active/first/default session?
    1              0.000001   if !empty(name)
    1   0.000009   0.000006     let is_tab_scoped = xolox#session#is_tab_scoped()
    1              0.000002     let msg = "Do you want to save your %s before quitting Vim?"
    1   0.000408   0.000023     if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
    1              0.000008       if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
    1              0.000002         let bang = ''
    1              0.000001       endif
    1              0.000001       if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
    1   0.067567   0.000214         call xolox#session#save_cmd(name, bang, 'SaveSession')
    1              0.000003       endif
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  20()
Called 440 times
Total time:   0.001445
 Self time:   0.001445

count  total (s)   self (s)
  440              0.001329   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>214_PerformListing()
Called 18 times
Total time:   0.787579
 Self time:   0.009916

count  total (s)   self (s)
                            "  call Dfunc("s:PerformListing(islocal=".a:islocal.")")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Decho("settings: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)",'~'.expand("<slnum>"))
                            
                              " set up syntax highlighting {{{3
                            "  call Decho("--set up syntax highlighting (ie. setl ft=netrw)",'~'.expand("<slnum>"))
   18   0.366163   0.000148   sil! setl ft=netrw
                            
   18   0.248718   0.000206   NetrwKeepj call s:NetrwSafeOptions()
   18              0.000126   setl noro ma
                            "  call Decho("setl noro ma bh=".&bh,'~'.expand("<slnum>"))
                            
                            "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
                            "   call Decho("(netrw) Processing your browsing request...",'~'.expand("<slnum>"))
                            "  endif								" Decho
                            
                            "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
   18              0.000088   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " force a refresh for tree listings
                            "   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                               sil! NetrwKeepj %d _
                              endif
                            
                              " save current directory on directory history list
   18   0.003395   0.000216   NetrwKeepj call s:NetrwBookHistHandler(3,b:netrw_curdir)
                            
                              " Set up the banner {{{3
   18              0.000019   if g:netrw_banner
                            "   call Decho("--set up banner",'~'.expand("<slnum>"))
   18              0.000187    NetrwKeepj call setline(1,'" ============================================================================')
   18              0.000038    if exists("g:netrw_pchk")
                                " this undocumented option allows pchk to run with different versions of netrw without causing spurious
                                " failure detections.
                                NetrwKeepj call setline(2,'" Netrw Directory Listing')
                               else
   18              0.000152     NetrwKeepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   18              0.000007    endif
   18              0.000030    if exists("g:netrw_pchk")
                                let curdir= substitute(b:netrw_curdir,expand("$HOME"),'~','')
                               else
   18              0.000033     let curdir= b:netrw_curdir
   18              0.000008    endif
   18              0.000040    if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
                                NetrwKeepj call setline(3,'"   '.substitute(curdir,'/','\\','g'))
                               else
   18              0.000086     NetrwKeepj call setline(3,'"   '.curdir)
   18              0.000006    endif
   18              0.000040    let w:netrw_bannercnt= 3
   18              0.000149    NetrwKeepj exe "sil! NetrwKeepj ".w:netrw_bannercnt
   18              0.000008   else
                            "   call Decho("--no banner",'~'.expand("<slnum>"))
                               NetrwKeepj 1
                               let w:netrw_bannercnt= 1
                              endif
                            "  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr(),'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            
   18              0.000035   let sortby= g:netrw_sort_by
   18              0.000083   if g:netrw_sort_direction =~# "^r"
                               let sortby= sortby." reversed"
                              endif
                            
                              " Sorted by... {{{3
   18              0.000012   if g:netrw_banner
                            "   call Decho("--handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
   18              0.000058    if g:netrw_sort_by =~# "^n"
                            "   call Decho("directories will be sorted by name",'~'.expand("<slnum>"))
                                " sorted by name
   18              0.000145     NetrwKeepj put ='\"   Sorted by      '.sortby
   18              0.000112     NetrwKeepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
   18              0.000039     let w:netrw_bannercnt= w:netrw_bannercnt + 2
   18              0.000013    else
                            "   call Decho("directories will be sorted by size or time",'~'.expand("<slnum>"))
                                " sorted by size or date
                                NetrwKeepj put ='\"   Sorted by '.sortby
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
   18              0.000085    exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
   18              0.000011   endif
                            
                              " show copy/move target, if any
   18              0.000012   if g:netrw_banner
   18              0.000043    if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
                            "    call Decho("--show copy/move target<".s:netrwmftgt.">",'~'.expand("<slnum>"))
                                NetrwKeepj put =''
                                if s:netrwmftgt_islocal
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
                                else
                                 sil! NetrwKeepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               else
                            "    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt",'~'.expand("<slnum>"))
   18              0.000007    endif
   18              0.000077    exe "sil! NetrwKeepj ".w:netrw_bannercnt
   18              0.000013   endif
                            
                              " Hiding...  -or-  Showing... {{{3
   18              0.000016   if g:netrw_banner
                            "   call Decho("--handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)",'~'.expand("<slnum>"))
   18              0.000035    if g:netrw_list_hide != "" && g:netrw_hide
                                if g:netrw_hide == 1
                                 NetrwKeepj put ='\"   Hiding:        '.g:netrw_list_hide
                                else
                                 NetrwKeepj put ='\"   Showing:       '.g:netrw_list_hide
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
   18              0.000073    exe "NetrwKeepj ".w:netrw_bannercnt
                            
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   18              0.000067    let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
                            "   call Decho("quickhelp   =".quickhelp,'~'.expand("<slnum>"))
   18              0.000136    NetrwKeepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
   18              0.000096    NetrwKeepj put ='\" =============================================================================='
   18              0.000035    let w:netrw_bannercnt= w:netrw_bannercnt + 2
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
   18              0.000009   endif
                            
                              " bannercnt should index the line just after the banner
   18              0.000012   if g:netrw_banner
   18              0.000025    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   18              0.000077    exe "sil! NetrwKeepj ".w:netrw_bannercnt
                            "   call Decho("--w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"),'~'.expand("<slnum>"))
                            "  else " Decho
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
   18              0.000008   endif
                            
                              " get list of files
                            "  call Decho("--Get list of files - islocal=".a:islocal,'~'.expand("<slnum>"))
   18              0.000018   if a:islocal
   18   0.076219   0.000207    NetrwKeepj call s:LocalListing()
   18              0.000016   else " remote
                               NetrwKeepj let badresult= s:NetrwRemoteListing()
                               if badresult
                            "    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            "    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
                                return
                               endif
                              endif
                            
                              " manipulate the directory listing (hide, sort) {{{3
   18              0.000048   if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= 0
                              endif
                            "  call Decho("--manipulate directory listing (hide, sort)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)",'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
   18              0.000049   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "   call Decho("manipulate directory listing (hide)",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">",'~'.expand("<slnum>"))
   18              0.000037    if g:netrw_hide && g:netrw_list_hide != ""
                                NetrwKeepj call s:NetrwListHide()
                               endif
   18              0.000038    if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">",'~'.expand("<slnum>"))
                            
   18              0.000068     if g:netrw_sort_by =~# "^n"
                                 " sort by name
   18   0.045296   0.000181      NetrwKeepj call s:NetrwSetSort()
                            
   18              0.000052      if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
   18              0.000065       if g:netrw_sort_direction =~# 'n'
                                   " normal direction sorting
   18              0.000358        exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
   18              0.000015       else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
   18              0.000010      endif
                                 " remove priority pattern prefix
                            "     call Decho("remove priority pattern prefix",'~'.expand("<slnum>"))
   18              0.001180      exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
   18              0.000092      NetrwKeepj call histdel("/",-1)
                            
   18              0.000019     elseif g:netrw_sort_by =~# "^ext"
                                 " sort by extension
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g+/+s/^/001'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+[./]+s/^/002'.g:netrw_sepchr.'/'
                                 NetrwKeepj call histdel("/",-1)
                                 exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$v+['.g:netrw_sepchr.'/]+s/^\(.*\.\)\(.\{-\}\)$/\2'.g:netrw_sepchr.'&/e'
                                 NetrwKeepj call histdel("/",-1)
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                                   " normal direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 endif
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^.\{-}'.g:netrw_sepchr.'//e'
                                 NetrwKeepj call histdel("/",-1)
                            
                                elseif a:islocal
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction,'~'.expand("<slnum>"))
                                  if g:netrw_sort_direction =~# 'n'
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                            "       call Decho('exe sil NetrwKeepj '.w:netrw_bannercnt.',$sort!','~'.expand("<slnum>"))
                                   exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
                                 NetrwKeepj call histdel("/",-1)
                                 endif
                                endif
                            
   18              0.000017    elseif g:netrw_sort_direction =~# 'r'
                            "    call Decho('(s:PerformListing) reverse the sorted listing','~'.expand("<slnum>"))
                                if !g:netrw_banner || w:netrw_bannercnt < line('$')
                                 exe 'sil! NetrwKeepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
                                 call histdel("/",-1)
                                endif
                               endif
   18              0.000010   endif
                            "  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                              " convert to wide/tree listing {{{3
                            "  call Decho("--modify display if wide/tree listing style",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)",'~'.expand("<slnum>"))
   18   0.001794   0.000168   NetrwKeepj call s:NetrwWideListing()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)",'~'.expand("<slnum>"))
   18   0.000904   0.000156   NetrwKeepj call s:NetrwTreeListing(b:netrw_curdir)
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)",'~'.expand("<slnum>"))
                            
                              " resolve symbolic links if local and (thin or tree)
   18              0.000056   if a:islocal && (w:netrw_liststyle == s:THINLIST || (exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST))
                            "   call Decho("--resolve symbolic links if local and thin|tree",'~'.expand("<slnum>"))
   18   0.003514   0.000381    g/@$/call s:ShowLink()
   18              0.000011   endif
                            
   18              0.000080   if exists("w:netrw_bannercnt") && (line("$") >= w:netrw_bannercnt || !g:netrw_banner)
                               " place cursor on the top-left corner of the file listing
                            "   call Decho("--place cursor on top-left corner of file listing",'~'.expand("<slnum>"))
   18              0.000066    exe 'sil! '.w:netrw_bannercnt
   18              0.000179    sil! NetrwKeepj norm! 0
                            "   call Decho("  tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
   18              0.000010   else
                            "   call Decho("--did NOT place cursor on top-left corner",'~'.expand("<slnum>"))
                            "   call Decho("  w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'),'~'.expand("<slnum>"))
                            "   call Decho("  line($)=".line("$"),'~'.expand("<slnum>"))
                            "   call Decho("  g:netrw_banner=".(exists("g:netrw_banner")? g:netrw_banner : 'n/a'),'~'.expand("<slnum>"))
                              endif
                            
                              " record previous current directory
   18              0.000051   let w:netrw_prvdir= b:netrw_curdir
                            "  call Decho("--record netrw_prvdir<".w:netrw_prvdir.">",'~'.expand("<slnum>"))
                            
                              " save certain window-oriented variables into buffer-oriented variables {{{3
                            "  call Decho("--save some window-oriented variables into buffer oriented variables",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)",'~'.expand("<slnum>"))
   18   0.000811   0.000126   NetrwKeepj call s:SetBufWinVars()
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)",'~'.expand("<slnum>"))
   18   0.032595   0.000168   NetrwKeepj call s:NetrwOptionRestore("w:")
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)",'~'.expand("<slnum>"))
                            
                              " set display to netrw display settings
                            "  call Decho("--set display to netrw display settings (".g:netrw_bufsettings.")",'~'.expand("<slnum>"))
   18   0.000528   0.000317   exe "setl ".g:netrw_bufsettings
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)",'~'.expand("<slnum>"))
   18              0.000027   if g:netrw_liststyle == s:LONGLIST
                            "   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1),'~'.expand("<slnum>"))
                               exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              endif
                            
   18              0.000035   if exists("s:treecurpos")
                            "   call Decho("s:treecurpos exists; restore posn",'~'.expand("<slnum>"))
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)",'~'.expand("<slnum>"))
                            "   call Decho("restoring posn to s:treecurpos<".string(s:treecurpos).">",'~'.expand("<slnum>"))
                               NetrwKeepj call winrestview(s:treecurpos)
                               unlet s:treecurpos
                              endif
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)",'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol()." line($)=".line("$"),'~'.expand("<slnum>"))
                            "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")

FUNCTION  <SNR>22_DetectElixir()
Called 9 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    9              0.000029   if getline(1) =~ '^#!.*\<elixir\>'
                                call s:setf('elixir')
                              endif

FUNCTION  <SNR>45_repo_head_ref()
Called 647 times
Total time:   0.047789
 Self time:   0.039829

count  total (s)   self (s)
  647   0.022556   0.018164   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
  647   0.023349   0.019781   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>45_buffer_getline()
Called 183 times
Total time:   0.000886
 Self time:   0.000886

count  total (s)   self (s)
  183              0.000799   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  <SNR>45_buffer_type()
Called 61 times
Total time:   0.012754
 Self time:   0.007432

count  total (s)   self (s)
   61   0.000349   0.000202   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
   26              0.000049     let type = 'directory'
   26              0.000038   elseif self.spec() == ''
   27              0.000029     let type = 'null'
   27              0.000009   else
    8              0.000010     let type = 'file'
    8              0.000004   endif
   61              0.000053   if a:0
   61              0.000528     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>45_cpath()
Called 56 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
   56              0.000130   if exists('+fileignorecase') && &fileignorecase
   56              0.000127     return tolower(a:path)
                              else
                                return a:path
                              endif

FUNCTION  anzu#search_status()
Called 498 times
Total time:   0.005703
 Self time:   0.005703

count  total (s)   self (s)
  498              0.005245 	return substitute(s:status_cache, '<anzustatushighlight>.\{-}<\/anzustatushighlight>', "", "g")

FUNCTION  <SNR>78_FindBundlerLock()
Called 90 times
Total time:   0.021303
 Self time:   0.020691

count  total (s)   self (s)
   90   0.001074   0.000462   let path = s:shellslash(a:path)
   90              0.002185   let fn = fnamemodify(path,':s?[\/]$??')
   90              0.000111   let ofn = ""
   90              0.000091   let nfn = fn
  733              0.000955   while fn != ofn
  643              0.004463     if filereadable(fn.'/Gemfile.lock')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/Gemfile.lock')
                                elseif filereadable(fn.'/gems.locked')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/gems.locked')
                                endif
  643              0.000734     let ofn = fn
  643              0.001447     let fn = fnamemodify(ofn,':h')
  643              0.000460   endwhile
   90              0.000075   return ''

FUNCTION  <SNR>182_session_is_locked()
Called 1 time
Total time:   0.001501
 Self time:   0.000099

count  total (s)   self (s)
    1   0.000038   0.000010   if !xolox#session#locking_enabled()
                                return 0
                              endif
    1   0.000244   0.000006   let session_path = xolox#session#name_to_path(a:session_name)
    1   0.000075   0.000010   let lock_file = s:lock_file_path(session_path)
    1              0.000032   if filereadable(lock_file)
    1   0.000173   0.000011     let this_instance = s:vim_instance_id()
    1   0.000923   0.000014     let other_instance = xolox#misc#persist#load(lock_file)
    1              0.000006     let arguments = [g:xolox#session#version, string(a:session_name)]
    1              0.000003     if this_instance == other_instance
                                  " Session belongs to current Vim instance and tab page.
    1              0.000001       return 0
                                elseif this_instance['pid'] == other_instance['pid']
                                  if has_key(other_instance, 'tabpage')
                                    let msg = "session.vim %s: The %s session is already loaded in tab page %s."
                                    call add(arguments, other_instance['tabpage'])
                                  else
                                    let msg = "session.vim %s: The %s session is already loaded in this Vim."
                                  endif
                                else
                                  let msg = "session.vim %s: The %s session is locked by another Vim instance %s."
                                  if has_key(other_instance, 'servername')
                                    call add(arguments, 'named ' . other_instance['servername'])
                                  else
                                    call add(arguments, 'with PID ' . other_instance['pid'])
                                  endif
                                  let msg .= " If that doesn't seem right maybe you forcefully closed Vim or it crashed?"
                                endif
                                let msg .= " Use the command ':%s! %s' to override."
                                call extend(arguments, [a:command, a:session_name])
                                call call('xolox#misc#msg#warn', [msg] + arguments)
                                return 1
                              endif

FUNCTION  <SNR>218_CreateCountDict()
Called 30 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   30              0.000181     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#events#EnterEvent()
Called 33 times
Total time:   0.003283
 Self time:   0.001559

count  total (s)   self (s)
                                " When entering a buffer, we are no longer quitting it.
   33              0.000394     call setbufvar(a:buffer, 'ale_quitting', 0)
   33              0.000217     let l:filetype = getbufvar(a:buffer, '&filetype')
   33              0.000356     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
   33   0.002041   0.000317     call s:LintOnEnter(a:buffer)

FUNCTION  <SNR>214_ComposePath()
Called 59 times
Total time:   0.004122
 Self time:   0.004122

count  total (s)   self (s)
                            "  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")
                            
   59              0.000160   if has("amiga")
                            "   call Decho("amiga",'~'.expand("<slnum>"))
                               let ec = a:base[s:Strlen(a:base)-1]
                               if ec != '/' && ec != ':'
                                let ret = a:base."/" . a:subdir
                               else
                                let ret = a:base.a:subdir
                               endif
                            
                              elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               let ret= a:subdir
                            
                              elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows",'~'.expand("<slnum>"))
                               if a:base =~ '[/\\]$'
                                let ret= a:base.a:subdir
                               else
                                let ret= a:base.'/'.a:subdir
                               endif
                            
                              elseif a:base =~ '^\a\{3,}://'
                            "   call Decho("remote linux/macos",'~'.expand("<slnum>"))
                               let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
                               let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
                               if a:subdir == '../'
                                if curpath =~ '[^/]/[^/]\+/$'
                                 let curpath= substitute(curpath,'[^/]\+/$','','')
                                else
                                 let curpath=""
                                endif
                                let ret= urlbase.curpath
                               else
                                let ret= urlbase.curpath.a:subdir
                               endif
                            "   call Decho("urlbase<".urlbase.">",'~'.expand("<slnum>"))
                            "   call Decho("curpath<".curpath.">",'~'.expand("<slnum>"))
                            "   call Decho("ret<".ret.">",'~'.expand("<slnum>"))
                            
                              else
                            "   call Decho("local linux/macos",'~'.expand("<slnum>"))
   59              0.000395    let ret = substitute(a:base."/".a:subdir,"//","/","g")
   59              0.000257    if a:base =~ '^//'
                                " keeping initial '//' for the benefit of network share listing support
                                let ret= '/'.ret
                               endif
   59              0.000157    let ret= simplify(ret)
   59              0.000031   endif
                            
                            "  call Dret("s:ComposePath ".ret)
   59              0.000057   return ret

FUNCTION  <SNR>214_RestorePosn()
Called 76 times
Total time:   0.000913
 Self time:   0.000913

count  total (s)   self (s)
                            "  call Dfunc("s:RestorePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
   76              0.000315   if has_key(a:posndict,bufnr("%"))
   59              0.000360    call winrestview(a:posndict[bufnr("%")])
                            "   call Decho("restoring posn: posndict[".bufnr("%")."]=".string(a:posndict[bufnr("%")]),'~'.expand("<slnum>"))
   59              0.000024   endif
                            "  call Dret("s:RestorePosn")

FUNCTION  ctrlp#mrufiles#cachefile()
Called 9 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    9              0.000141 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    9              0.000011 	retu s:cafile

FUNCTION  xolox#session#save_state()
Called 1 time
Total time:   0.004020
 Self time:   0.001146

count  total (s)   self (s)
                              " Wrapper for the [:mksession] [] command that slightly massages the
                              " generated Vim script to get rid of some strange quirks in the way Vim
                              " generates sessions. Also implements support for buffers with content that
                              " was generated by other Vim plug-ins. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
    1              0.000009   let tempfile = tempname()
    1              0.000002   let ssop_save = &sessionoptions
    1              0.000001   try
                                " The default value of &sessionoptions includes "options" which causes
                                " :mksession to include all Vim options and mappings in generated session
                                " scripts. This can significantly increase the size of session scripts
                                " which makes them slower to generate and evaluate. It can also be a bit
                                " buggy, e.g. it breaks Ctrl-S when :runtime mswin.vim has been used. The
                                " value of &sessionoptions is changed temporarily to avoid these issues.
    1              0.000011     set ssop-=options
    1              0.000480     execute 'mksession' fnameescape(tempfile)
    1              0.000149     let lines = readfile(tempfile)
                                " Remove the mode line added by :mksession because we'll add our own in
                                " xolox#session#save_session().
    1   0.000051   0.000038     call s:eat_trailing_line(lines, '" vim: set ft=vim :')
                                " Remove the "SessionLoadPost" event firing at the end of the :mksession
                                " output. We will fire the event ourselves when we're really done.
    1   0.000013   0.000006     call s:eat_trailing_line(lines, 'unlet SessionLoad')
    1   0.000011   0.000005     call s:eat_trailing_line(lines, 'doautoall SessionLoadPost')
    1   0.000482   0.000013     call xolox#session#save_special_windows(lines)
    1   0.000104   0.000004     if !xolox#session#include_tabs()
                                  " Customize the output of :mksession for tab scoped sessions.
                                  let buffers = tabpagebuflist()
                                  call map(lines, 's:tabpage_filter(buffers, v:val)')
                                endif
    1   0.002472   0.000213     call extend(a:commands, map(lines, 's:state_filter(v:val)'))
                                " Re-implement Vim's special handling of the initial, empty buffer.
    1              0.000003     call add(a:commands, "if exists('s:wipebuf')")
    1              0.000003     call add(a:commands, "  if empty(bufname(s:wipebuf))")
    1   0.000031   0.000011     call s:cleanup_after_plugin(a:commands, 's:wipebuf')
    1              0.000002     call add(a:commands, "  endif")
    1              0.000002     call add(a:commands, "endif")
    1              0.000002     return 1
                              finally
    1              0.000010     let &sessionoptions = ssop_save
    1              0.000162     call delete(tempfile)
    1              0.000002   endtry

FUNCTION  xolox#misc#perm#set()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                              " Set the permissions (the second argument) of the pathname given as the
                              " first argument. Expects a permissions value created by
                              " `xolox#misc#perm#get()`.
    1              0.000003   if !empty(a:perms)
                                let pathname = xolox#misc#path#absolute(a:fname)
                                let [owner, group, mode] = a:perms
                                if s:run('chown %s:%s %s', owner, group, pathname) && s:run('chmod %s %s', mode, pathname)
                                  call xolox#misc#msg#debug("vim-misc %s: Successfully set %s owner to %s, group to %s and permissions to %s.", g:xolox#misc#version, pathname, owner, group, mode)
                                  return 1
                                endif
                              endif
    1              0.000001   return 0

FUNCTION  xolox#session#is_tab_scoped()
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                              " Determine whether the current session is tab scoped or global. Returns 1
                              " (true) when the session is tab scoped, 0 (false) otherwise.
    3              0.000010   return exists('t:this_session')

FUNCTION  <SNR>204_GroupLoclistItems()
Called 35 times
Total time:   0.000775
 Self time:   0.000775

count  total (s)   self (s)
   35              0.000070     let l:grouped_items = []
   35              0.000049     let l:last_lnum = -1
                            
   35              0.000067     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
   35              0.000047     return l:grouped_items

FUNCTION  gitgutter#diff#is_added()
Called 4 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    4              0.000016   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>205_CloseWindowIfNeeded()
Called 31 times
Total time:   0.001976
 Self time:   0.000334

count  total (s)   self (s)
   31   0.001910   0.000268     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
   31              0.000027         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  <SNR>56_has()
Called 202 times
Total time:   0.007274
 Self time:   0.007274

count  total (s)   self (s)
  202              0.002676   let file = matchstr(a:file, '[^!].*')
  202              0.000544   if file =~# '\*'
                                let found = !empty(glob(a:root . '/' . file))
                              elseif file =~# '/$'
                                let found = isdirectory(a:root . '/' . file)
                              else
  202              0.001834     let found = filereadable(a:root . '/' . file)
  202              0.000121   endif
  202              0.000562   return a:file =~# '^!' ? !found : found

FUNCTION  airline#extensions#anzu#apply()
Called 28 times
Total time:   0.000783
 Self time:   0.000167

count  total (s)   self (s)
   28   0.000774   0.000158 	call airline#extensions#append_to_section("y", " %{anzu#search_status()}")

FUNCTION  xolox#misc#path#absolute()
Called 5 times
Total time:   0.000753
 Self time:   0.000419

count  total (s)   self (s)
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
    5              0.000016   if type(a:path) == type('')
    5              0.000006     let path = a:path
                                " Make the pathname absolute.
    5              0.000025     if path =~ '^\~'
                                  " Expand ~ to $HOME.
    3              0.000014       let path = $HOME . '/' . path[1:]
    3              0.000006     elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
    5              0.000188     let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
    5   0.000227   0.000034     let parts = xolox#misc#path#split(path)
    5              0.000009     if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
    5   0.000121   0.000022     return xolox#misc#path#join(parts)
                              endif
                              return ''

FUNCTION  <SNR>167_hl_group_exists()
Called 3993 times
Total time:   0.050179
 Self time:   0.050179

count  total (s)   self (s)
 3993              0.016372   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
 3993              0.002435   return 1

FUNCTION  ale#cursor#EchoCursorWarning()
Called 518 times
Total time:   0.202780
 Self time:   0.014327

count  total (s)   self (s)
  518   0.201735   0.013282     return ale#CallWithCooldown('dont_echo_until', function('s:EchoImpl'), [])

FUNCTION  xolox#session#include_tabs()
Called 8 times
Total time:   0.001010
 Self time:   0.000057

count  total (s)   self (s)
                              " Check whether Vim's [sessionoptions] [] option includes the `tabpages`
                              " keyword. Returns 1 (true) when it does, 0 (false) otherwise.
    8   0.001000   0.000047   return xolox#session#options_include('tabpages')

FUNCTION  ctrlp#utils#readfile()
Called 9 times
Total time:   0.001639
 Self time:   0.001639

count  total (s)   self (s)
    9              0.000189 	if filereadable(a:file)
    9              0.001368 		let data = readfile(a:file)
    9              0.000035 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    9              0.000008 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>45_sub()
Called 812 times
Total time:   0.016210
 Self time:   0.016210

count  total (s)   self (s)
  812              0.015821   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>217_on_stdout()
Called 5 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    5              0.000055     let self.buf .= a:msg

FUNCTION  YRMapsExpression()
Called 4 times
Total time:   0.000604
 Self time:   0.000604

count  total (s)   self (s)
    4              0.000012     let cmds     = a:motion
                                " echomsg "YRMapsE:".localtime()
                                " echomsg "YRMapsE 1:".cmds.":".v:operator.":".s:yr_maps_created_zap
                            
    4              0.000028     if (a:motion =~ '\.' && s:yr_remove_omap_dot == 1) || a:motion =~ '@'
                                    " If we are repeating a series of commands we must
                                    " unmap the _zap_ keys so that the user is not
                                    " prompted when a command is replayed.
                                    " These maps must be re-instated in YRRecord3()
                                    " after the action of the replay is completed.
                                    call s:YRMapsDelete('remove_only_zap_keys')
                                endif
                            
                                " Check if we are in operator-pending mode
    4              0.000062     if a:motion =~ '\('.substitute(g:yankring_zap_keys, ' ', '\\|', 'g').'\)'
                                    if a:motion =~ '\(/\|?\)'
                                        let zapto = (a:0==0 ? "" : input("YR:Enter string:"))
                                        if zapto != ""
                                            let zapto = zapto . "\<CR>"
                                        else
                                            let zapto = "\<C-C>"
                                        endif
                                    else
                                        let zapto = (a:0==0 ? "" : s:YRGetChar())
                                    endif
                            
                                    if zapto == "\<C-C>"
                                        " Abort if the user hits Control C
                                        call s:YRWarningMsg( "YR:Aborting command:".v:operator.a:motion )
                                        return "\<C-C>"
                                    endif
                            
                                    let cmds = cmds . zapto
                                endif
                            
                                " There are a variety of commands which do not change the
                                " registers, so these operators should be ignored when
                                " determining which operations to record
                                " Simple example is '=' which simply formats the
                                " the selected text.
    4              0.000245     if ' \('.escape(join(split(g:yankring_ignore_operator), '\|'), '/.*~$^[]' ).'\) ' !~ escape(v:operator, '/.*~$^[]')
                                    " Check if we are performing an action that will
                                    " take us into insert mode
    4              0.000027         if '[cCsS]' !~ escape(v:operator, '/.*~$^[]') && a:motion !~ '@'
                                    " if '[cCsS]' !~ escape(v:operator, '/.*~$^[]')
                                        " If we have not entered insert mode, feed the call
                                        " to record the current change when the function ends.
                                        " This is necessary since omaps do not update registers
                                        " until the function completes.
                                        " The InsertLeave event will handle the motions
                                        " that place us in insert mode and record the
                                        " changes when insert mode ends.
                                        " let cmds .= a:sid. "yrrecord ".a:motion
    4              0.000014             let cmds .= a:sid. "yrrecord"
    4              0.000001         endif
    4              0.000002     endif
                            
                                " This will not work since we are already executing an expression
                                " if a:motion =~ '@'
                                "     let cmds = 'normal! ' . cmds
                                " endif
                            
                                " YRRecord3() will use this value to determine what operation
                                " the user just initiated.
    4              0.000021     let s:yr_last_motion = cmds
                            
                                " echomsg "YRMapsE 5:".a:motion.":'".cmds."':".s:yr_maps_created_zap
    4              0.000005     return cmds
                            

FUNCTION  gitgutter#diff#parse_hunk()
Called 11 times
Total time:   0.000390
 Self time:   0.000390

count  total (s)   self (s)
   11              0.000179   let matches = matchlist(a:line, s:hunk_re)
   11              0.000026   if len(matches) > 0
    4              0.000023     let from_line  = str2nr(matches[1])
    4              0.000014     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    4              0.000009     let to_line    = str2nr(matches[3])
    4              0.000023     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    4              0.000009     return [from_line, from_count, to_line, to_count]
                              else
    7              0.000006     return []
                              end

FUNCTION  airline#extensions#keymap#status()
Called 554 times
Total time:   0.006405
 Self time:   0.006405

count  total (s)   self (s)
  554              0.003026   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  554              0.002878     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>109_setup()
Called 74 times
Total time:   0.277012
 Self time:   0.004184

count  total (s)   self (s)
   74              0.000142   let swap = a:0 && a:1 == 2
   74              0.000099   let enable = a:0 && a:1
   74              0.000080   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
   74              0.000191   if get(b:, 'delimitMate_enabled', 0)
   61   0.052187   0.000571     call s:Unmap()
                                " Switch
   61              0.000070     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
   61              0.000036   endif
   74              0.000054   if disable
                                " Just disable the mappings.
                                return
                              endif
   74              0.000078   if !a:0
                                " Check if this file type is excluded:
   74              0.000367     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
   74              0.000155     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
   74              0.000027   endif
                              " Initialize settings:
   74   0.115003   0.000439   if ! s:init()
                                " Something went wrong.
                                return
                              endif
   74              0.000242   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
   74   0.106959   0.000311     call s:Map()
   74              0.000071     if a:0
                                  echo "delimitMate is enabled."
                                endif
   74              0.000045   endif

FUNCTION  <SNR>175_L2U_Setup()
Called 95 times
Total time:   0.004259
 Self time:   0.003647

count  total (s)   self (s)
                            
   95   0.001022   0.000410   call s:L2U_SetupGlobal()
                            
                              " Keep track of whether LaTeX-to-Unicode is activated
                              " (used when filetype changes)
   95              0.000275   if !has_key(b:, "l2u_enabled")
   13              0.000025     let b:l2u_enabled = 0
   13              0.000009   endif
                            
                              " Did we install the L2U tab mappings?
   95              0.000188   if !has_key(b:, "l2u_tab_set")
   13              0.000017     let b:l2u_tab_set = 0
   13              0.000008   endif
   95              0.000167   if !has_key(b:, "l2u_cmdtab_set")
   13              0.000014     let b:l2u_cmdtab_set = 0
   13              0.000009   endif
                            
                              " Did we activate the L2U as-you-type substitutions?
   95              0.000179   if !has_key(b:, "l2u_autosub_set")
   13              0.000016     let b:l2u_autosub_set = 0
   13              0.000006   endif
                            
                              " Following are some flags used to pass information between the function which
                              " attempts the LaTeX-to-Unicode completion and the fallback function
                            
                              " Was a (possibly partial) completion found?
   95              0.000169   let b:l2u_found_completion = 0
                              " Is the cursor just after a single backslash
   95              0.000164   let b:l2u_singlebslash = 0
                              " Backup value of the completeopt settings
                              " (since we temporarily add the 'longest' setting while
                              "  attempting LaTeX-to-Unicode)
   95              0.000262   let b:l2u_backup_commpleteopt = &completeopt
                              " Are we in the middle of a L2U tab completion?
   95              0.000119   let b:l2u_tab_completing = 0
                              " Are we calling the tab fallback?
   95              0.000125   let b:l2u_in_fallback = 0
                            

FUNCTION  xolox#misc#path#split()
Called 5 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
    5              0.000015   if type(a:path) == type('')
    5              0.000006     if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
    5              0.000024       let absolute = (a:path =~ '^/')
    5              0.000043       let segments = split(a:path, '/\+')
    5              0.000015       return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []

FUNCTION  ale#events#QuitEvent()
Called 4 times
Total time:   0.000321
 Self time:   0.000126

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    4   0.000301   0.000106     call setbufvar(a:buffer, 'ale_quitting', ale#util#ClockMilliseconds())

FUNCTION  <SNR>214_NetrwBookHistRead()
Called 1 time
Total time:   0.000992
 Self time:   0.000172

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistRead()")
    1              0.000004   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
    1              0.000001   let ykeep= @@
    1              0.000002   if !exists("s:netrw_initbookhist")
    1   0.000315   0.000015    let home    = s:NetrwHome()
    1              0.000002    let savefile= home."/.netrwbook"
    1   0.000052   0.000016    if filereadable(s:NetrwFile(savefile))
                            "    call Decho("sourcing .netrwbook",'~'.expand("<slnum>"))
                                exe "keepalt NetrwKeepj so ".savefile
                               endif
    1              0.000002    if g:netrw_dirhistmax > 0
    1              0.000002     let savefile= home."/.netrwhist"
    1   0.000058   0.000023     if filereadable(s:NetrwFile(savefile))
                            "    call Decho("sourcing .netrwhist",'~'.expand("<slnum>"))
    1   0.000527   0.000078      exe "keepalt NetrwKeepj so ".savefile
    1              0.000001     endif
    1              0.000002     let s:netrw_initbookhist= 1
    1              0.000010     au VimLeave * call s:NetrwBookHistSave()
    1              0.000001    endif
    1              0.000000   endif
    1              0.000008   let @@= ykeep
                            "  call Dret("s:NetrwBookHistRead")

FUNCTION  <SNR>214_NetrwInit()
Called 76 times
Total time:   0.001885
 Self time:   0.001885

count  total (s)   self (s)
                            " call Decho("varname<".a:varname."> value=".a:value,'~'.expand("<slnum>"))
   76              0.000205   if !exists(a:varname)
   75              0.000154    if type(a:value) == 0
   32              0.000151     exe "let ".a:varname."=".a:value
   32              0.000051    elseif type(a:value) == 1 && a:value =~ '^[{[]'
    2              0.000015     exe "let ".a:varname."=".a:value
    2              0.000004    elseif type(a:value) == 1
   41              0.000259     exe "let ".a:varname."="."'".a:value."'"
   41              0.000035    else
                                exe "let ".a:varname."=".a:value
                               endif
   75              0.000036   endif

FUNCTION  ale#sign#SetSigns()
Called 35 times
Total time:   0.019798
 Self time:   0.002639

count  total (s)   self (s)
   35              0.000149     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
   35   0.008331   0.000391     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   35   0.001399   0.000338     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   35   0.000998   0.000223     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   35   0.005655   0.000303     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   35   0.002316   0.000285     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   35              0.000088     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   35              0.000061     for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
   35              0.000072     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  <SNR>117_YRWindowUpdate()
Called 6 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    6              0.000032     let orig_win_bufnr = bufwinnr('%')
                            
                                " Switch to the yankring buffer
                                " only if it is already visible
    6              0.000027     if bufwinnr(s:yr_buffer_id) != -1
                                    call s:YRShow(0)
                                    " Switch back to the original buffer
                                    exec orig_win_bufnr . "wincmd w"
                                endif

FUNCTION  gitgutter#diff#process_hunks()
Called 22 times
Total time:   0.000901
 Self time:   0.000342

count  total (s)   self (s)
   22              0.000069   let modified_lines = []
   26              0.000040   for hunk in a:hunks
    4   0.000626   0.000067     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
    4              0.000004   endfor
   22              0.000029   return modified_lines

FUNCTION  <SNR>209_build_command()
Called 22 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   22              0.000045   if has('unix')
   22              0.000037     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  18()
Called 82 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
   82              0.000247   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>214_NetrwCommands()
Called 18 times
Total time:   0.001028
 Self time:   0.001028

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")
                            
   18              0.000198   com! -nargs=* -complete=file -bang	NetrwMB	call s:NetrwBookmark(<bang>0,<f-args>)
   18              0.000114   com! -nargs=*			    	NetrwC	call s:NetrwSetChgwin(<q-args>)
   18              0.000406   com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"win#".winnr()." not a former netrw window",79)|endif
   18              0.000020   if a:islocal
   18              0.000125    com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(1,<f-args>)
   18              0.000014   else
                               com! -buffer -nargs=+ -complete=file	MF	call s:NetrwMarkFiles(0,<f-args>)
                              endif
   18              0.000084   com! -buffer -nargs=? -complete=file	MT	call s:NetrwMarkTarget(<q-args>)
                            
                            "  call Dret("s:NetrwCommands")

FUNCTION  <SNR>209_on_stdout_vim()
Called 11 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   11              0.000103   call add(self.stdoutbuffer, a:data)

FUNCTION  gitgutter#sign#add_dummy_sign()
Called 1 time
Total time:   0.000041
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000005   0.000003   let bufnr = gitgutter#utility#bufnr()
    1   0.000010   0.000003   if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    1              0.000013     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    1   0.000012   0.000004     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
    1              0.000000   endif

FUNCTION  <SNR>123_crend()
Called 1 time
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000003   let n = ""
    1              0.000010   if !exists("b:endwise_addition") || !exists("b:endwise_words") || !exists("b:endwise_syngroups")
                                return n
                              end
    1              0.000049   let synids = join(map(split(b:endwise_syngroups, ','), 'hlID(v:val)'), ',')
    1              0.000012   let wordchoice = '\%('.substitute(b:endwise_words,',','\\|','g').'\)'
    1              0.000003   if exists("b:endwise_pattern")
                                let beginpat = substitute(b:endwise_pattern,'&',substitute(wordchoice,'\\','\\&','g'),'g')
                              else
    1              0.000003     let beginpat = '\<'.wordchoice.'\>'
    1              0.000001   endif
    1              0.000003   let lnum = line('.') - 1
    1              0.000008   let space = matchstr(getline(lnum),'^\s*')
    1              0.000022   let col  = match(getline(lnum),beginpat) + 1
    1              0.000011   let word  = matchstr(getline(lnum),beginpat)
    1              0.000012   let endword = substitute(word,'.*',b:endwise_addition,'')
    1              0.000004   let y = n.endword."\<C-O>O"
    1              0.000004   if b:endwise_addition[0:1] ==# '\='
    1              0.000002     let endpat = '\w\@<!'.endword.'\w\@!'
    1              0.000000   else
                                let endpat = '\w\@<!'.substitute('\w\+', '.*', b:endwise_addition, '').'\w\@!'
                              endif
    1              0.000008   let synidpat  = '\%('.substitute(synids,',','\\|','g').'\)'
    1              0.000001   if a:always
                                return y
                              elseif col <= 0 || synID(lnum,col,1) !~ '^'.synidpat.'$'
    1              0.000002     return n
                              elseif getline('.') !~ '^\s*#\=$'
                                return n
                              endif
                              let line = s:mysearchpair(beginpat,endpat,synidpat)
                              " even is false if no end was found, or if the end found was less
                              " indented than the current line
                              let even = strlen(matchstr(getline(line),'^\s*')) >= strlen(space)
                              if line == 0
                                let even = 0
                              endif
                              if !even && line == line('.') + 1
                                return y
                              endif
                              if even
                                return n
                              endif
                              return y

FUNCTION  gitgutter#utility#filename()
Called 28 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   28              0.000095   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>109_AutoClose()
Called 74 times
Total time:   0.068802
 Self time:   0.037907

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
   74              0.000095   let i = 0
  296   0.008755   0.001849   while i < len(s:get('matchpairs_list'))
  222   0.011810   0.001866     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
  222   0.010710   0.001781     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
  222              0.006996     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
  222              0.003598     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
  222              0.000285     let i += 1
  222              0.000147   endwhile
                            
                              " Exit from inside the matching pair:
  296   0.002035   0.000517   for delim in s:get('right_delims')
  222              0.000393     let delim = delim == '|' ? '<bar>' : delim
  222              0.004538     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
  222              0.003236     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
  222              0.000359   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
  296   0.002359   0.000564   for delim in s:get('quotes_list')
  222              0.000258     if delim == '|'
                                  let delim = '<Bar>'
                                endif
  222              0.004857     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
  222              0.003237     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
  222              0.000170   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
   74   0.002102   0.000299   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  <SNR>171_get_accented_line()
Called 440 times
Total time:   0.022574
 Self time:   0.022574

count  total (s)   self (s)
  440              0.000514   if a:self._context.active
  296              0.000358     let contents = []
  296              0.002189     let content_parts = split(a:contents, '__accent')
  704              0.000896     for cpart in content_parts
  408              0.004525       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  408              0.000994       call add(contents, cpart)
  408              0.000514     endfor
  296              0.000969     let line = join(contents, a:group)
  296              0.001862     let line = substitute(line, '__restore__', a:group, 'g')
  296              0.000193   else
  144              0.003324     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  144              0.000919     let line = substitute(line, '%#__restore__#', '', 'g')
  144              0.000078   endif
  440              0.000388   return line

FUNCTION  ale#engine#InitBufferInfo()
Called 35 times
Total time:   0.000751
 Self time:   0.000751

count  total (s)   self (s)
   35              0.000206     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
    8              0.000064         let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
    8              0.000006         return 1
                                endif
                            
   27              0.000024     return 0

FUNCTION  <SNR>214_NetrwBrowseUpDir()
Called 1 time
Total time:   0.088315
 Self time:   0.000222

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
    1              0.000013   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt-1
                               " this test needed because occasionally this function seems to be incorrectly called
                               " when multiple leftmouse clicks are taken when atop the one line help in the banner.
                               " I'm allowing the very bottom line to permit a "-" exit so that one may escape empty
                               " directories.
                            "   call Dret("s:NetrwBrowseUpDir : cursor not in file area")
                               return
                              endif
                            
    1              0.000005   if !exists("w:netrw_liststyle") || w:netrw_liststyle != s:TREELIST
    1   0.000098   0.000016    call s:SavePosn(s:netrw_nbcd)
    1              0.000002   endif
                            
    1              0.000046   norm! 0
    1              0.000008   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                            "   call Decho("case: treestyle",'~'.expand("<slnum>"))
                               let curline= getline(".")
                               let swwline= winline() - 1
                               if exists("w:netrw_treetop")
                                let b:netrw_curdir= w:netrw_treetop
                               endif
                               let curdir= b:netrw_curdir
                               if a:islocal
                                call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
                               else
                                call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
                               endif
                               if !search('\c^'.s:treedepthstring.curline,'cw')
                                if !search('\c^'.curline,'cw')
                                 sil! NetrwKeepj 1
                                endif
                               endif
                               exe "sil! NetrwKeepj norm! z\<cr>"
                               while winline() < swwline
                                let curwinline= winline()
                                exe "sil! NetrwKeepj norm! \<c-y>"
                                if curwinline == winline()
                                 break
                                endif
                               endwhile
                              else
                            "   call Decho("case: not treestyle",'~'.expand("<slnum>"))
    1              0.000004    if exists("b:netrw_curdir")
    1              0.000002     let curdir= b:netrw_curdir
    1              0.000001    else
                                let curdir= expand(getcwd())
                               endif
    1              0.000001    if a:islocal
    1   0.088015   0.000012     call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
    1              0.000000    else
                                call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
                               endif
    1              0.000003    if has_key(s:netrw_nbcd,bufnr("%"))
    1   0.000012   0.000004     call s:RestorePosn(s:netrw_nbcd)
    1              0.000001    elseif exists("w:netrw_bannercnt")
                            "    call Decho("moving to line#".w:netrw_bannercnt,'~'.expand("<slnum>"))
                                exe w:netrw_bannercnt
                               else
                                1
                               endif
    1              0.000001   endif
    1              0.000031   let curdir= substitute(curdir,'^.*[\/]','','')
    1              0.000008   call search('\<'.curdir.'\>','wc')
                            "  call Dret("s:NetrwBrowseUpDir")

FUNCTION  <SNR>45_repo_tree()
Called 35 times
Total time:   0.001373
 Self time:   0.001116

count  total (s)   self (s)
   35   0.000524   0.000383   if self.dir() =~# '/\.git$'
   35   0.000293   0.000177     let dir = self.dir()[0:-6]
   35              0.000080     if dir !~# '/'
                                  let dir .= '/'
                                endif
   35              0.000020   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
   35              0.000046   if dir ==# ''
                                call s:throw('no work tree')
                              else
   35              0.000134     return join([dir]+a:000,'/')
                              endif

FUNCTION  xolox#session#path_to_name()
Called 1 time
Total time:   0.000014
 Self time:   0.000009

count  total (s)   self (s)
                              " Convert the absolute pathname of a session script (the first argument,
                              " expected to be a string) to a session name. This function assumes the
                              " absolute pathname refers to the configured session directory, but it does
                              " not check for it nor does it require it (it simple takes the base name
                              " of the absolute pathname of the session script and decodes it). Returns a
                              " string.
    1   0.000012   0.000007   return xolox#misc#path#decode(fnamemodify(a:path, ':t:r'))

FUNCTION  xolox#misc#timer#start()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                              " Start a timer. This returns a list which can later be passed to
                              " `xolox#misc#timer#stop()`.
    2              0.000013   return [s:unique_marker, s:has_reltime ? reltime() : localtime()]

FUNCTION  ctrlp#utils#mkdir()
Called 9 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    9              0.000148 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    9              0.000008 	retu a:dir

FUNCTION  <SNR>214_NetrwFullPath()
Called 36 times
Total time:   0.001044
 Self time:   0.001044

count  total (s)   self (s)
                            "  " call Dfunc("s:NetrwFullPath(filename<".a:filename.">)")
   36              0.000060   let filename= a:filename
   36              0.000165   if filename !~ '^/'
                               let filename= resolve(getcwd().'/'.filename)
                              endif
   36              0.000346   if filename != "/" && filename =~ '/$'
   18              0.000186    let filename= substitute(filename,'/$','','')
   18              0.000043   endif
                            "  " call Dret("s:NetrwFullPath <".filename.">")
   36              0.000036   return filename

FUNCTION  airline#extensions#default#apply()
Called 64 times
Total time:   0.031572
 Self time:   0.002926

count  total (s)   self (s)
   64              0.000119   let winnr = a:context.winnr
   64              0.000088   let active = a:context.active
                            
   64   0.000507   0.000307   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   28   0.006282   0.000170     call s:build_sections(a:builder, a:context, s:layout[0])
   28              0.000019   else
   36   0.001466   0.000190     let text = s:get_section(winnr, 'c')
   36              0.000056     if empty(text)
                                  let text = ' %f%m '
                                endif
   36   0.000348   0.000209     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   36              0.000017   endif
                            
   64   0.002693   0.000457   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   64   0.000371   0.000211   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   64   0.018934   0.000411     call s:build_sections(a:builder, a:context, s:layout[1])
   64              0.000032   endif
                            
   64              0.000035   return 1

FUNCTION  ale#FileTooLarge()
Called 657 times
Total time:   0.028305
 Self time:   0.010213

count  total (s)   self (s)
  657   0.024609   0.006517     let l:max = ale#Var(bufnr(''), 'maximum_file_size')
                            
  657              0.002871     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>167_exec_separator()
Called 958 times
Total time:   0.434450
 Self time:   0.031712

count  total (s)   self (s)
  958              0.001425   if pumvisible()
                                return
                              endif
  958   0.118590   0.004825   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  958   0.112978   0.004287   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  958              0.002646   let group = a:from.'_to_'.a:to.a:suffix
  958              0.000875   if a:inverse
  212              0.000842     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  212              0.000117   else
  746              0.002881     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  746              0.000409   endif
  958              0.003202   let a:dict[group] = colors
  958   0.185529   0.005247   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>45_buffer_repo()
Called 71 times
Total time:   0.002013
 Self time:   0.000489

count  total (s)   self (s)
   71   0.001989   0.000465   return s:repo(self.getvar('git_dir'))

FUNCTION  <SNR>44_TmuxWinCmd()
Called 11 times
Total time:   0.154620
 Self time:   0.000390

count  total (s)   self (s)
   11   0.000203   0.000108   if s:InTmuxSession()
   11   0.154312   0.000177     call s:TmuxAwareNavigate(a:direction)
   11              0.000010   else
                                call s:VimNavigate(a:direction)
                              endif

FUNCTION  gitgutter#sign#next_sign_id()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001   let next_id = s:next_sign_id
    1              0.000003   let s:next_sign_id += 1
    1              0.000001   return next_id

FUNCTION  ale#engine#IsCheckingBuffer()
Called 101 times
Total time:   0.001052
 Self time:   0.001052

count  total (s)   self (s)
  101              0.000439     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  101              0.000449     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  ale#pattern_options#SetOptions()
Called 40 times
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
   40              0.000177     if !g:ale_pattern_options_enabled || empty(g:ale_pattern_options)
   40              0.000039         return
                                endif
                            
                                " The items will only be sorted whenever the patterns change.
                                if g:ale_pattern_options != s:last_pattern_options
                                    let s:last_pattern_options = deepcopy(g:ale_pattern_options)
                                    " The patterns are sorted, so they are applied consistently.
                                    let s:sorted_items = sort(   items(g:ale_pattern_options),   function('s:CmpPatterns'))
                                endif
                            
                                let l:filename = expand('#' . a:buffer . ':p')
                            
                                for [l:pattern, l:options] in s:sorted_items
                                    if match(l:filename, l:pattern) >= 0
                                        for [l:key, l:value] in items(l:options)
                                            call setbufvar(a:buffer, l:key, l:value)
                                        endfor
                                    endif
                                endfor

FUNCTION  <SNR>214_NetrwBrowse()
Called 18 times
Total time:   0.978821
 Self time:   0.007359

count  total (s)   self (s)
   18              0.000095   if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                            "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
                            "  call Decho("modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Dredir("ls!")
                            
                              " save alternate-file's filename if w:netrw_rexlocal doesn't exist
                              " This is useful when one edits a local file, then :e ., then :Rex
   18              0.000070   if a:islocal && !exists("w:netrw_rexfile") && bufname("#") != ""
    3              0.000008    let w:netrw_rexfile= bufname("#")
                            "   call Decho("setting w:netrw_rexfile<".w:netrw_rexfile."> win#".winnr(),'~'.expand("<slnum>"))
    3              0.000003   endif
                            
                              " s:NetrwBrowse : initialize history {{{3
   18              0.000040   if !exists("s:netrw_initbookhist")
    1   0.001013   0.000021    NetrwKeepj call s:NetrwBookHistRead()
    1              0.000000   endif
                            
                              " s:NetrwBrowse : simplify the dirname (especially for ".."s in dirnames) {{{3
   18              0.000153   if a:dirname !~ '^\a\{3,}://'
   18              0.000059    let dirname= simplify(a:dirname)
   18              0.000012   else
                               let dirname= a:dirname
                              endif
                            
   18              0.000038   if exists("s:netrw_skipbrowse")
                               unlet s:netrw_skipbrowse
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
                               return
                              endif
                            
                              " s:NetrwBrowse : sanity checks: {{{3
   18              0.000044   if !exists("*shellescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
                            "   call Dret("s:NetrwBrowse : missing shellescape()")
                               return
                              endif
   18              0.000038   if !exists("*fnameescape")
                               NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
                            "   call Dret("s:NetrwBrowse : missing fnameescape()")
                               return
                              endif
                            
                              " s:NetrwBrowse : save options: {{{3
   18   0.007689   0.000122   call s:NetrwOptionSave("w:")
                            
                              " s:NetrwBrowse : re-instate any marked files {{{3
   18              0.000112   if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("clearing marked files",'~'.expand("<slnum>"))
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              endif
                            
   18              0.000056   if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
                               " s:NetrwBrowse : set up "safe" options for local directory/file {{{3
                            "   call Decho("handle w:netrw_acdkeep:",'~'.expand("<slnum>"))
                            "   call Decho("NetrwKeepj lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")",'~'.expand("<slnum>"))
                               call s:NetrwLcd(dirname)
                               call s:NetrwSafeOptions()
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            
                              elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
                               " s:NetrwBrowse :  remote regular file handler {{{3
                            "   call Decho("handle remote regular file: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if bufname(dirname) != ""
                            "    call Decho("edit buf#".bufname(dirname)." in win#".winnr(),'~'.expand("<slnum>"))
                                exe "NetrwKeepj b ".bufname(dirname)
                               else
                                " attempt transfer of remote regular file
                            "    call Decho("attempt transfer as regular file<".dirname.">",'~'.expand("<slnum>"))
                            
                                " remove any filetype indicator from end of dirname, except for the
                                " "this is a directory" indicator (/).
                                " There shouldn't be one of those here, anyway.
                                let path= substitute(dirname,'[*=@|]\r\=$','','e')
                            "    call Decho("new path<".path.">",'~'.expand("<slnum>"))
                                call s:RemotePathAnalysis(dirname)
                            
                                " s:NetrwBrowse : remote-read the requested file into current buffer {{{3
                                call s:NetrwEnew(dirname)
                                call s:NetrwSafeOptions()
                                setl ma noro
                            "    call Decho("setl ma noro",'~'.expand("<slnum>"))
                                let b:netrw_curdir = dirname
                                let url            = s:method."://".((s:user == "")? "" : s:user."@").s:machine.(s:port ? ":".s:port : "")."/".s:path
                            "    call Decho("exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")",'~'.expand("<slnum>"))
                                exe "sil! NetrwKeepj keepalt file ".fnameescape(url)
                                exe "sil! NetrwKeepj keepalt doau BufReadPre ".fnameescape(s:fname)
                                sil call netrw#NetRead(2,url)
                                " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
                            "    call Decho("url<".url.">",'~'.expand("<slnum>"))
                            "    call Decho("s:path<".s:path.">",'~'.expand("<slnum>"))
                            "    call Decho("s:fname<".s:fname.">",'~'.expand("<slnum>"))
                                if s:path =~ '.bz2'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
                                elseif s:path =~ '.gz'
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
                                else
                                 exe "sil NetrwKeepj keepalt doau BufReadPost ".fnameescape(s:fname)
                                endif
                               endif
                            
                               " s:NetrwBrowse : save certain window-oriented variables into buffer-oriented variables {{{3
                               call s:SetBufWinVars()
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("setl ma nomod",'~'.expand("<slnum>"))
                               setl ma nomod noro
                            "   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            
                            "   call Dret("s:NetrwBrowse : file<".s:fname.">")
                               return
                              endif
                            
                              " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
   18   0.000935   0.000116   call s:UseBufWinVars()
                            
                              " set up some variables {{{3
   18              0.000041   let b:netrw_browser_active = 1
   18              0.000026   let dirname                = dirname
   18              0.000046   let s:last_sort_by         = g:netrw_sort_by
                            
                              " set up menu {{{3
   18   0.002298   0.000184   NetrwKeepj call s:NetrwMenu(1)
                            
                              " get/set-up buffer {{{3
                            "  call Decho("saving position across a buffer refresh",'~'.expand("<slnum>"))
   18              0.000066   let svpos  = winsaveview()
                            "  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
   18   0.142505   0.000161   let reusing= s:NetrwGetBuffer(a:islocal,dirname)
                            
                              " maintain markfile highlighting
   18              0.000242   if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("bufnr(%)=".bufnr('%'),'~'.expand("<slnum>"))
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/",'~'.expand("<slnum>"))
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("2match none",'~'.expand("<slnum>"))
   18              0.000028    2match none
   18              0.000011   endif
   18              0.000033   if reusing && line("$") > 1
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                               setl noma nomod nowrap
                            "   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwBrowse : re-using not-cleared buffer")
                               return
                              endif
                            
                              " set b:netrw_curdir to the new directory name {{{3
                            "  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")",'~'.expand("<slnum>"))
   18              0.000064   let b:netrw_curdir= dirname
   18              0.000466   if b:netrw_curdir =~ '[/\\]$'
    9              0.000210    let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
    9              0.000009   endif
   18              0.000432   if b:netrw_curdir =~ '\a:$' && (has("win32") || has("win95") || has("win64") || has("win16"))
                               let b:netrw_curdir= b:netrw_curdir."/"
                              endif
   18              0.000022   if b:netrw_curdir == ''
                               if has("amiga")
                                " On the Amiga, the empty string connotes the current directory
                                let b:netrw_curdir= getcwd()
                               else
                                " under unix, when the root directory is encountered, the result
                                " from the preceding substitute is an empty string.
                                let b:netrw_curdir= '/'
                               endif
                              endif
   18              0.000023   if !a:islocal && b:netrw_curdir !~ '/$'
                               let b:netrw_curdir= b:netrw_curdir.'/'
                              endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
                            
                              " ------------
                              " (local only) {{{3
                              " ------------
   18              0.000017   if a:islocal
                            "   call Decho("local only:",'~'.expand("<slnum>"))
                            
                               " Set up ShellCmdPost handling.  Append current buffer to browselist
   18   0.000924   0.000139    call s:LocalFastBrowser()
                            
                              " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
   18              0.000022    if !g:netrw_keepdir
                            "    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"),'~'.expand("<slnum>"))
                                if !exists("&l:acd") || !&l:acd
                                 call s:NetrwLcd(b:netrw_curdir)
                                endif
                               endif
                            
                              " --------------------------------
                              " remote handling: {{{3
                              " --------------------------------
   18              0.000013   else
                            "   call Decho("remote only:",'~'.expand("<slnum>"))
                            
                               " analyze dirname and g:netrw_list_cmd {{{3
                            "   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">",'~'.expand("<slnum>"))
                               if dirname =~# "^NetrwTreeListing\>"
                                let dirname= b:netrw_curdir
                            "    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">",'~'.expand("<slnum>"))
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                let dirname= substitute(b:netrw_curdir,'\\','/','g')
                                if dirname !~ '/$'
                                 let dirname= dirname.'/'
                                endif
                                let b:netrw_curdir = dirname
                            "    call Decho("(liststyle is TREELIST) dirname<".dirname.">",'~'.expand("<slnum>"))
                               else
                                let dirname = substitute(dirname,'\\','/','g')
                            "    call Decho("(normal) dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                            
                               let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
                               if dirname !~ dirpat
                                if !exists("g:netrw_quiet")
                                 NetrwKeepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
                                endif
                                NetrwKeepj call s:NetrwOptionRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                setl noma nomod nowrap
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
                                return
                               endif
                               let b:netrw_curdir= dirname
                            "   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)",'~'.expand("<slnum>"))
                              endif  " (additional remote handling)
                            
                              " -----------------------
                              " Directory Listing: {{{3
                              " -----------------------
   18   0.028000   0.000158   NetrwKeepj call s:NetrwMaps(a:islocal)
   18   0.001221   0.000193   NetrwKeepj call s:NetrwCommands(a:islocal)
   18   0.787812   0.000233   NetrwKeepj call s:PerformListing(a:islocal)
                            
                              " restore option(s)
   18   0.000423   0.000084   call s:NetrwOptionRestore("w:")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
                              " If there is a rexposn: restore position with rexposn
                              " Otherwise            : set rexposn
   18              0.000065   if exists("s:rexposn_".bufnr("%"))
                            "   call Decho("restoring posn to s:rexposn_".bufnr('%')."<".string(s:rexposn_{bufnr('%')}).">",'~'.expand("<slnum>"))
   14              0.000120    NetrwKeepj call winrestview(s:rexposn_{bufnr('%')})
   14              0.000050    if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                                NetrwKeepj exe w:netrw_bannercnt
                               endif
   14              0.000005   else
    4   0.000099   0.000046    NetrwKeepj call s:SetRexDir(a:islocal,b:netrw_curdir)
    4              0.000002   endif
   18              0.000088   if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
                               let &l:bexpr= "netrw#BalloonHelp()"
                            "   call Decho("set up balloon help: l:bexpr=".&l:bexpr,'~'.expand("<slnum>"))
                               setl beval
                              endif
                            
                              " restore position
   18              0.000015   if reusing
                            "   call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
                               call winrestview(svpos)
                              endif
                            
                              " The s:LocalBrowseRefresh() function is called by an autocmd
                              " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
                              " However, s:NetrwBrowse() causes the FocusGained event to fire the firstt time.
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
   18              0.000012   return

FUNCTION  airline#highlighter#add_separator()
Called 332 times
Total time:   0.160738
 Self time:   0.004500

count  total (s)   self (s)
  332              0.001853   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  332   0.158699   0.002461   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#ale#get()
Called 936 times
Total time:   0.073043
 Self time:   0.041903

count  total (s)   self (s)
  936              0.003014   if !exists(':ALELint')
                                return ''
                              endif
                            
  936              0.001965   let is_err = a:type ==# 'error'
  936              0.002199   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  936              0.001411   let is_err = a:type ==# 'error'
  936   0.033115   0.006017   let counts = ale#statusline#Count(bufnr(''))
  936              0.001860   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  936              0.004156   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  936              0.001938     let errors = counts.error + counts.style_error
  936              0.001873     let num = is_err ? errors : counts.total - errors
  936              0.000624   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  936   0.013582   0.009540   return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)

FUNCTION  <SNR>189_show_message()
Called 1 time
Total time:   0.028864
 Self time:   0.028827

count  total (s)   self (s)
                              " The implementation of info() and warn().
    1              0.000003   let nargs = len(a:args)
    1              0.000001   if nargs == 1
                                let message = a:args[0]
                              elseif nargs >= 2
    1   0.000059   0.000022     let args = map(copy(a:args), 's:coerce_argument(v:val)')
    1              0.000005     let message = call('printf', args)
    1              0.000001   endif
    1              0.000003   if exists('message')
    1              0.000001     try
                                  " Temporarily disable Vim's |hit-enter| prompt and mode display.
    1              0.000002       if !exists('s:more_save')
    1              0.000005         let s:more_save = &more
    1              0.000002         let s:ruler_save = &ruler
    1              0.000002         let s:smd_save = &showmode
    1              0.000001       endif
    1              0.000008       set nomore noshowmode
    1              0.000005       if winnr('$') == 1 | set noruler | endif
    1              0.000016       augroup PluginXoloxHideMode
    1              0.000013         autocmd! CursorHold,CursorHoldI * call s:clear_message()
    1              0.000002       augroup END
    1              0.000015       execute 'echohl' a:hlgroup
                                  " Redraw to avoid the |hit-enter| prompt. We use :silent to avoid issues
                                  " like this one: https://github.com/xolox/vim-easytags/issues/69.
    1              0.027829       silent! redraw
    2              0.000498       for line in split(message, "\n")
    1              0.000034         echomsg line
    1              0.000002       endfor
    1              0.000003       if g:xolox_message_buffer > 0
    1              0.000008         call add(g:xolox_messages, message)
    1              0.000003         if len(g:xolox_messages) > g:xolox_message_buffer
                                      call remove(g:xolox_messages, 0)
                                    endif
    1              0.000001       endif
    1              0.000001     finally
                                  " Always clear message highlighting, even when interrupted by Ctrl-C.
    1              0.000007       echohl none
    1              0.000000     endtry
    1              0.000000   endif

FUNCTION  gitgutter#utility#set_buffer()
Called 85 times
Total time:   0.001914
 Self time:   0.001914

count  total (s)   self (s)
   85              0.000161   let s:bufnr = a:bufnr
   85              0.001668   let s:file = resolve(bufname(a:bufnr))

FUNCTION  anzu#get_on_pattern_pos()
Called 490 times
Total time:   0.050828
 Self time:   0.038542

count  total (s)   self (s)
  490              0.001107 	if a:pat == ""
                            		return getpos(".")
                            	endif
  490              0.001829 	let pos = getpos(".")
  490              0.011101 	let first = searchpos(a:pat, 'nWbc')
  490              0.006038 	let last  = searchpos(a:pat, 'nWeb')
  490   0.007337   0.003776 	if s:pos_less_equal(last, first)
  466              0.005814 		let last  = searchpos(a:pat, 'nWec')
  466              0.000422 	endif
  490   0.012459   0.003734 	if s:clamp_pos(pos[1:2], first, last)
   34              0.000083 		return [0, first[0], first[1], 0]
                            	endif
  456              0.000589 	return pos

FUNCTION  airline#util#wrap()
Called 4481 times
Total time:   0.021605
 Self time:   0.021605

count  total (s)   self (s)
 4481              0.009226   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 4481              0.004216   return a:text

FUNCTION  <SNR>117_YRWinLeave()
Called 14 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                                " Track which window we are last in.  We will use this information
                                " to determine where we need to paste any contents, or which
                                " buffer to return to.
                            
   14              0.000061     if s:yr_buffer_id < 0
                                    " The yankring window has never been activated
   14              0.000015         return
                                endif
                            
                                if winbufnr(winnr()) == s:yr_buffer_id
                                    " Ignore leaving the yankring window
                                    return
                                endif
                            
                                if bufwinnr(s:yr_buffer_id) != -1
                                    " YankRing window is visible, so save off the previous buffer ids
                                    let s:yr_buffer_last_winnr = winnr()
                                    let s:yr_buffer_last       = winbufnr(s:yr_buffer_last_winnr)
                                " else
                                "     let s:yr_buffer_last_winnr = -1
                                "     let s:yr_buffer_last       = -1
                                endif

FUNCTION  gitgutter#debug#log()
Called 23 times
Total time:   0.000828
 Self time:   0.000828

count  total (s)   self (s)
   23              0.000036   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>211_searchpos()
Called 490 times
Total time:   0.018980
 Self time:   0.016502

count  total (s)   self (s)
  490              0.002880 	let bufnr = get(a:, 1, bufnr("%"))
  490              0.001259 	let uncache = get(a:, 2, 0)
  490              0.000458 	if uncache
                            		return s:searchpos_all(a:pattern)
                            	endif
  490              0.001892 	let cache = getbufvar(bufnr, "anzu_searchpos_cache")
  490              0.001551 	if type(cache) == type("")
   12              0.000014 		unlet cache
   12              0.000014 		let cache = {}
   12              0.000020 	endif
                            
  490              0.001400 	if has_key(cache, a:pattern)
  456              0.001828 		return deepcopy(cache[a:pattern])
                            	endif
   34   0.002733   0.000255 	let searchpos = s:searchpos_all(a:pattern)
   34              0.000105 	let cache[a:pattern] = searchpos
   34              0.000155 	call setbufvar(bufnr, "anzu_searchpos_cache", cache)
   34              0.000040 	return searchpos

FUNCTION  xolox#session#get_label()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                              " Get a human readable label based on the scope (tab scoped or global) and
                              " name of a session. The first argument is the name (a string) and the
                              " second argument is a boolean indicating the scope of the session; 1 (true)
                              " means tab scoped and 0 (false) means global scope. Returns a string.
    2              0.000004   if a:name == g:session_default_name
    2              0.000004     let description = 'default editing session'
    2              0.000000   else
                                let description = printf('editing session %s', string(a:name))
                              endif
    2              0.000002   if a:is_tab_scoped
                                let description = printf('tab scoped %s', description)
                              endif
    2              0.000002   return description

FUNCTION  ale#events#FileTypeEvent()
Called 62 times
Total time:   0.029868
 Self time:   0.001409

count  total (s)   self (s)
   62              0.000265     let l:filetype = getbufvar(a:buffer, 'ale_original_filetype', '')
                            
                                " If we're setting the filetype for the first time after it was blank,
                                " and the option for linting on enter is off, then we should set this
                                " filetype as the original filetype. Otherwise ALE will still appear to
                                " lint files because of the BufEnter event, etc.
   62   0.001683   0.000387     if empty(l:filetype) && !ale#Var(a:buffer, 'lint_on_enter')
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                                elseif a:new_filetype isnot# l:filetype
   62   0.027452   0.000289         call ale#Queue(300, 'lint_file', a:buffer)
   62              0.000042     endif

FUNCTION  <SNR>159_init_buffer()
Called 13 times
Total time:   0.000327
 Self time:   0.000327

count  total (s)   self (s)
   13              0.000055   let b:buffer_vcs_config = {}
   39              0.000079   for vcs in keys(s:vcs_config)
   26              0.000098     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
   26              0.000018   endfor
   13              0.000022   unlet! b:airline_head

FUNCTION  <SNR>78_ProjectionistDetect()
Called 28 times
Total time:   0.008131
 Self time:   0.000568

count  total (s)   self (s)
   28   0.007725   0.000162   if s:Detect(get(g:, 'projectionist_file', ''))
                                call projectionist#append(fnamemodify(b:bundler_lock, ':h'), { 'Gemfile': {'dispatch': ['bundle', '--gemfile={file}'], 'alternate': 'Gemfile.lock'}, 'gems.rb': {'dispatch': ['bundle', '--gemfile={file}'], 'alternate': 'gems.locked'}, 'gems.locked': {'alternate': 'gems.rb'}, 'Gemfile.lock': {'alternate': 'Gemfile'}})
                                for projections in bundler#project().projections_list()
                                  call projectionist#append(fnamemodify(b:bundler_lock, ':h'), projections)
                                endfor
                              endif

FUNCTION  <SNR>45_repo_head()
Called 647 times
Total time:   0.099684
 Self time:   0.024286

count  total (s)   self (s)
  647   0.066815   0.005477     let head = s:repo().head_ref()
                            
  647              0.007483     if head =~# '^ref: '
  647   0.018636   0.004576       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
  647              0.000802     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
  647              0.000682     return branch

FUNCTION  <SNR>175_L2U_file_type_regex()
Called 190 times
Total time:   0.002279
 Self time:   0.002279

count  total (s)   self (s)
  190              0.000408   if type(a:ft) == 3
                                let file_types = "\\%(" . join(a:ft, "\\|") . "\\)"
                              elseif type(a:ft) == 1
  190              0.000244     let file_types = a:ft
  190              0.000092   else
                                echoerr "invalid file_type specification"
                              endif
  190              0.000357   return "^" . file_types . "$"

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 2 times
Total time:   0.000292
 Self time:   0.000217

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    4              0.000011   for handler in g:xolox#misc#cursorhold#handlers
    2              0.000006     let function = handler['function']
    2              0.000006     let last_run = get(handler, 'last_run', 0)
    2              0.000005     let interval = get(handler, 'interval', 4)
    2   0.000062   0.000035     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
    2              0.000010     let time_until_next_run = (last_run + interval) - localtime()
    2              0.000002     if time_until_next_run > 0
    1   0.000014   0.000006       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
    1              0.000000     else
    1   0.000016   0.000007       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    1   0.000075   0.000044       call call(function, get(handler, 'arguments', []))
    1              0.000006       let handler['last_run'] = localtime()
    1              0.000001     endif
    2              0.000002   endfor

FUNCTION  <SNR>54_readfile()
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000003   try
    2              0.000064     return readfile(a:fname)
                              catch
                                call xolox#misc#msg#warn("vim-misc %s: Failed to read temporary file (%s) with %s of external command: %s! (external command: %s)", g:xolox#misc#version, a:fname, a:label, v:exception, a:cmd)
                                return []
                              endtry

FUNCTION  gitgutter#utility#extension()
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000017   return fnamemodify(s:file, ':e')

FUNCTION  <SNR>214_SetBufWinVars()
Called 18 times
Total time:   0.000685
 Self time:   0.000685

count  total (s)   self (s)
                            "  call Dfunc("s:SetBufWinVars() win#".winnr())
   18              0.000081   if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
   18              0.000063   if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
   18              0.000058   if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
   18              0.000070   if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
   18              0.000059   if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
   18              0.000059   if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
   18              0.000057   if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
   18              0.000088   if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
   18              0.000059   if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
   18              0.000051   if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
                            "  call Dret("s:SetBufWinVars")

FUNCTION  <SNR>109_init()
Called 74 times
Total time:   0.114564
 Self time:   0.022872

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
   74   0.004528   0.000422   call s:option_init("autoclose", 1)
                              " matchpairs
   74   0.004330   0.000663   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
   74   0.009753   0.004062   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
   74   0.002043   0.000248   let pairs = s:get('matchpairs_list')
   74              0.000685   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
   74   0.005935   0.000861   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
   74   0.006178   0.000863   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
   74   0.003563   0.000276   call s:option_init("quotes", "\" ' `")
   74   0.006395   0.001170   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
   74   0.003390   0.000267   call s:option_init("nesting_quotes", [])
                              " excluded_regions
   74   0.003542   0.000298   call s:option_init("excluded_regions", "Comment")
   74   0.006005   0.000759   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
   74   0.002028   0.000365   let enabled = len(s:get('excluded_regions_list')) > 0
   74   0.003517   0.000289   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
   74              0.000280   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
   74              0.000243   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
   74   0.003381   0.000262   call s:option_init("expand_space", 0)
                              " expand_cr
   74              0.000298   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
   74              0.000232   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
   74              0.000695   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
   74   0.003266   0.000263   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
   74   0.003758   0.000458   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
   74   0.003295   0.000254   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
   74   0.003438   0.000331   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[£$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
   74   0.002403   0.000754   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
   74              0.000331   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
   74              0.000266   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
   74              0.000249   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
   74   0.003713   0.000347   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
   74   0.003353   0.000274   call s:option_init("apostrophes", "")
   74   0.005627   0.000856   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
   74   0.003313   0.000243   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
   74   0.003315   0.000265   call s:option_init("balance_matchpairs", 0)
                              " eol marker
   74   0.003424   0.000243   call s:option_init("insert_eol_marker", 1)
   74   0.003768   0.000476   call s:option_init("eol_marker", "")
                              " Everything is fine.
   74              0.000059   return 1

FUNCTION  <SNR>60_mergelists()
Called 9 times
Total time:   0.006667
 Self time:   0.004553

count  total (s)   self (s)
    9   0.002645   0.000773 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    9              0.003168 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    9              0.000519 	let mrufs = s:mrufs + diskmrufs
    9   0.000323   0.000081 	retu s:chop(mrufs)

FUNCTION  <SNR>45_buffer_path()
Called 12 times
Total time:   0.006748
 Self time:   0.001089

count  total (s)   self (s)
   12   0.000490   0.000132   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
   12              0.000013   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
   11   0.001171   0.000127     let rev = self.spec()[strlen(self.repo().tree()) : -1]
   11              0.000007   endif
   12   0.000485   0.000090   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  airline#util#getwinvar()
Called 688 times
Total time:   0.002157
 Self time:   0.002157

count  total (s)   self (s)
  688              0.001971     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  xolox#misc#timer#stop()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [verbose] option to one
                              " (1) or higher.
                              "
                              " This function has the same argument handling as Vim's [printf()] [printf]
                              " function with one difference: At the point where you want the elapsed time
                              " to be embedded, you write `%s` and you pass the list returned by
                              " `xolox#misc#timer#start()` as an argument.
                              "
                              " [verbose]: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
                              " [printf]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
    2              0.000010   if (g:timer_enabled || &verbose >= g:timer_verbosity)
                                call call('xolox#misc#msg#info', map(copy(a:000), 'xolox#misc#timer#convert(v:val)'))
                              endif

FUNCTION  <SNR>44_ShouldForwardNavigationBackToTmux()
Called 11 times
Total time:   0.000663
 Self time:   0.000663

count  total (s)   self (s)
   11              0.000532   if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
                                return 0
                              endif
   11              0.000017   return a:tmux_last_pane || a:at_tab_page_edge

FUNCTION  <SNR>117_YRMRUElemFormat()
Called 6 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
    6              0.000043     let elem    = a:element
    6              0.000012     if g:yankring_max_element_length != 0
    6              0.000023         let elem    = strpart(a:element, 0, g:yankring_max_element_length)
    6              0.000008         if (g:yankring_warn_on_truncate > 0)
    6              0.000030             let bytes = len (a:element) - len(elem)
    6              0.000006             if (bytes > 0)
                                            call s:YRWarningMsg("Yankring truncated its element by ". bytes. " bytes due to a g:yankring_max_element_length of ". g:yankring_max_element_length )
                                        endif
    6              0.000003         endif
    6              0.000003     endif
    6              0.000013     if s:yr_history_version == 'v1'
                                    let elem    = escape(elem, '@')
                                    let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
                                else
    6              0.000082         let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
    6              0.000004     endif
                                " Append the regtype to the end so we have it available
    6              0.000016     let elem    = elem.",".a:element_type
                            
    6              0.000007     return elem

FUNCTION  gitgutter#hunk#hunks()
Called 22 times
Total time:   0.000335
 Self time:   0.000138

count  total (s)   self (s)
   22   0.000320   0.000123   return gitgutter#utility#getbufvar(gitgutter#utility#bufnr(), 'hunks', [])

FUNCTION  <SNR>175_L2U_UnsetTab()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002   if b:l2u_cmdtab_set
                                cunmap <buffer> <S-Tab>
                                let b:l2u_cmdtab_set = 0
                              endif
    1              0.000002   if !b:l2u_tab_set
    1              0.000001     return
                              endif
                              exec "setlocal omnifunc=" . get(b:, "prev_omnifunc", "")
                              iunmap <buffer> <Tab>
                              if empty(maparg("<Tab>", "i"))
                                call s:L2U_SetFallbackMapping(s:l2u_fallback_trigger, '<Tab>')
                              endif
                              iunmap <buffer> <Plug>L2UTab
                              exe 'iunmap <buffer> ' . s:l2u_fallback_trigger
                              augroup L2UTab
                                autocmd! * <buffer>
                              augroup END
                              let b:l2u_tab_set = 0

FUNCTION  <SNR>181_LintOnEnter()
Called 33 times
Total time:   0.001724
 Self time:   0.000678

count  total (s)   self (s)
   33   0.001468   0.000422     if ale#Var(a:buffer, 'enabled')&& g:ale_lint_on_enter&& has_key(b:, 'ale_file_changed')
                                    call remove(b:, 'ale_file_changed')
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  <SNR>214_LocalFastBrowser()
Called 18 times
Total time:   0.000785
 Self time:   0.000785

count  total (s)   self (s)
                            "  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
                            "  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"),'~'.expand("<slnum>"))
                            "  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"),'~'.expand("<slnum>"))
                            
                              " initialize browselist, a list of buffer numbers that the local browser has used
   18              0.000059   if !exists("s:netrw_browselist")
                            "   call Decho("initialize s:netrw_browselist",'~'.expand("<slnum>"))
    1              0.000001    let s:netrw_browselist= []
    1              0.000001   endif
                            
                              " append current buffer to fastbrowse list
   18              0.000079   if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
                            "   call Decho("appendng current buffer to browselist",'~'.expand("<slnum>"))
    4              0.000015    call add(s:netrw_browselist,bufnr("%"))
                            "   call Decho("browselist=".string(s:netrw_browselist),'~'.expand("<slnum>"))
    4              0.000001   endif
                            
                              " enable autocmd events to handle refreshing/removing local browser buffers
                              "    If local browse buffer is currently showing: refresh it
                              "    If local browse buffer is currently hidden : wipe it
                              "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
                              "                      =1 : medium speed, re-use directory listing for remote only
                              "                      =2 : fast   speed, always re-use directory listing when possible
   18              0.000113   if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
                               let s:netrw_events= 1
                               augroup AuNetrwEvent
                                au!
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "     call Decho("installing autocmd: ShellCmdPost",'~'.expand("<slnum>"))
                                 au ShellCmdPost			*	call s:LocalBrowseRefresh()
                                else
                            "     call Decho("installing autocmds: ShellCmdPost FocusGained",'~'.expand("<slnum>"))
                                 au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
                                endif
                               augroup END
                            
                              " user must have changed fastbrowse to its fast setting, so remove
                              " the associated autocmd events
                              elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
                            "   call Decho("remove AuNetrwEvent autcmd group",'~'.expand("<slnum>"))
                               unlet s:netrw_events
                               augroup AuNetrwEvent
                                au!
                               augroup END
                               augroup! AuNetrwEvent
                              endif
                            
                            "  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 442 times
Total time:   0.005536
 Self time:   0.005536

count  total (s)   self (s)
  442              0.001495   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    2              0.000002     return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
    1              0.000006     let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
    1              0.000003     unlet! b:airline_head
    1              0.000001   endif

FUNCTION  GetVimIndentIntern()
Called 2 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    2              0.000013   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
    2              0.000006   let cur_text = getline(v:lnum)
    2              0.000023   if cur_text !~ '^\s*\\'
    2              0.000021     while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
    2              0.000002   endif
                            
                              " At the start of the file use zero indent.
    2              0.000002   if lnum == 0
                                return 0
                              endif
    2              0.000005   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
    2              0.000006   let ind = indent(lnum)
    2              0.000010   if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
    2              0.000016     if prev_text !~ '^\s*au\%[tocmd]'
    2              0.000073       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
    2              0.000004       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
    2              0.000002     endif
    2              0.000001   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
    2              0.000057   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
    2              0.000003   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
    2              0.000018   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
    2              0.000003   return ind

FUNCTION  xolox#misc#os#is_mac()
Called 2 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                              " Returns 1 (true) when on Mac OS X, 0 (false) otherwise. You would expect
                              " this to simply check the Vim feature list, but for some obscure reason the
                              " `/usr/bin/vim` included in Mac OS X (verified on version 10.7.5) returns 0
                              " (false) in response to `has('mac')`, so we check the output of `uname`
                              " to avoid false negatives.
    2              0.000006   if !exists('s:is_mac')
                                " By default we assume we are *not* on Mac OS X.
                                let s:is_mac = 0
                                if has('mac') || has('macunix') || has('gui_mac')
                                  " If Vim's feature list indicates we are on Mac OS X, we have our answer :-).
                                  let s:is_mac = 1
                                elseif !xolox#misc#os#is_win()
                                  " Otherwise we check the output of `uname' to avoid false negatives.
                                  let result = xolox#misc#os#exec({'command': 'uname', 'check': 0})
                                  if result['exit_code'] == 0 && get(result['stdout'], 0, '') == 'Darwin'
                                    let s:is_mac = 1
                                  endif
                                endif
                              endif
    2              0.000003   return s:is_mac

FUNCTION  <SNR>74_Detect()
Called 90 times
Total time:   0.030600
 Self time:   0.001089

count  total (s)   self (s)
   90              0.000228   if !exists('b:rake_root')
   90   0.029973   0.000462     let dir = s:find_root(a:path)
   90              0.000119     if dir !=# ''
                                  let b:rake_root = dir
                                endif
   90              0.000042   endif

FUNCTION  xolox#misc#msg#debug()
Called 8 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    8              0.000032   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  <SNR>167_Get()
Called 1526 times
Total time:   0.008451
 Self time:   0.008451

count  total (s)   self (s)
 1526              0.003147   let res=get(a:dict, a:key, '')
 1526              0.001677   if res is ''
  631              0.000413     return ''
                              else
  895              0.001290     return a:prefix. res
                              endif

FUNCTION  22()
Called 82 times
Total time:   0.311524
 Self time:   0.042486

count  total (s)   self (s)
   82              0.000080   let side = 1
   82              0.000082   let line = ''
   82              0.000074   let i = 0
   82              0.000161   let length = len(self._sections)
   82              0.000073   let split = 0
   82              0.000083   let is_empty = 0
   82              0.000087   let prev_group = ''
                            
  604              0.000721   while i < length
  522              0.000977     let section = self._sections[i]
  522              0.000814     let group = section[0]
  522              0.000784     let contents = section[1]
  522              0.000618     let pgroup = prev_group
  522   0.007572   0.002255     let prev_group = s:get_prev_group(self._sections, i)
  522              0.001128     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
  522              0.000413     if is_empty
                                  let prev_group = pgroup
                                endif
  522   0.006746   0.002185     let is_empty = s:section_is_empty(self, contents)
                            
  522              0.000368     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
  522              0.000588     if group == ''
                                  let line .= contents
                                elseif group == '|'
   82              0.000073       let side = 0
   82              0.000139       let line .= contents
   82              0.000070       let split = 1
   82              0.000045     else
  440              0.000483       if prev_group == ''
   82              0.000215         let line .= '%#'.group.'#'
   82              0.000065       elseif split
   82              0.000056         if !is_empty
   82   0.042147   0.000527           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   82              0.000046         endif
   82              0.000080         let split = 0
   82              0.000045       else
  276              0.000233         if !is_empty
  276   0.196725   0.001759           let line .= s:get_seperator(self, prev_group, group, side)
  276              0.000161         endif
  276              0.000120       endif
  440   0.025838   0.003264       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  440              0.000280     endif
                            
  522              0.000884     let i = i + 1
  522              0.000492   endwhile
                            
   82              0.000093   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   36              0.003394     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   36              0.000027   endif
   82              0.000086   return line

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 23 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   23              0.000043   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
   23              0.000026   return s:using_xolox_shell

FUNCTION  <SNR>171_get_transitioned_seperator()
Called 332 times
Total time:   0.166641
 Self time:   0.005903

count  total (s)   self (s)
  332              0.000377   let line = ''
  332   0.162498   0.001760   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  332              0.001306   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  332              0.001002   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  332              0.000739   let line .= '%#'.a:group.'#'
  332              0.000314   return line

FUNCTION  ale#Queue()
Called 117 times
Total time:   0.084631
 Self time:   0.002828

count  total (s)   self (s)
  117              0.000159     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
  117              0.000380     let l:linting_flag = get(a:000, 0, '')
  117              0.000339     let l:buffer = get(a:000, 1, bufnr(''))
                            
  117   0.083109   0.001306     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 1 time
Total time:   0.000032
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000005   0.000003   let bufnr = gitgutter#utility#bufnr()
    1   0.000011   0.000004   if gitgutter#utility#getbufvar(bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    1              0.000005     execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
    1   0.000011   0.000003     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 0)
    1              0.000000   endif

FUNCTION  <SNR>167_get_array()
Called 6679 times
Total time:   0.047621
 Self time:   0.047621

count  total (s)   self (s)
 6679              0.020020   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 6679              0.024541   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  fugitive#extract_git_dir()
Called 12 times
Total time:   0.007685
 Self time:   0.004196

count  total (s)   self (s)
   12   0.000274   0.000101   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
   12              0.000079   if isdirectory(a:path)
    3              0.000099     let path = fnamemodify(a:path, ':p:s?[\/]$??')
    3              0.000002   else
    9              0.000246     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    9              0.000007   endif
   12   0.000398   0.000239   let root = s:shellslash(resolve(path))
   12              0.000014   let previous = ""
   47              0.000079   while root !=# previous
   47              0.000277     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
   47              0.000254     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
   47              0.000116     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
   47   0.001042   0.000216     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
   47   0.001010   0.000276     let dir = s:sub(root, '[\/]$', '') . '/.git'
   47              0.000301     let type = getftype(dir)
   47   0.000713   0.000148     if type ==# 'dir' && fugitive#is_git_dir(dir)
   12              0.000013       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
   35              0.000047     let previous = root
   35              0.000095     let root = fnamemodify(root, ':h')
   35              0.000034   endwhile
                              return ''

FUNCTION  gitgutter#utility#directory_of_file()
Called 23 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
   23              0.000082   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>123_abbrev()
Called 62 times
Total time:   0.000647
 Self time:   0.000647

count  total (s)   self (s)
   62              0.000173   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  <SNR>39_init()
Called 46 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   46              0.000069   if s:airline_initialized
   46              0.000034     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>74_ProjectionistDetect()
Called 28 times
Total time:   0.011528
 Self time:   0.001602

count  total (s)   self (s)
   28   0.010176   0.000250   call s:Detect(get(g:, 'projectionist_file', ''))
   28              0.000056   if exists('b:rake_root')
                                let projections = deepcopy(s:projections)
                                if isdirectory(b:rake_root.'/test')
                                  let test = 1
                                endif
                                if isdirectory(b:rake_root.'/spec')
                                  let spec = 1
                                endif
                                let projections['*'].make = split(s:project().makeprg())
                                let projections['Rakefile'].dispatch = projections['*'].make
                                let projections['rakelib/*.rake'].dispatch = projections['*'].make + ['{}']
                                let ruby = s:binstub(b:rake_root, 'ruby')
                                if ruby ==# ['ruby']
                                  let projections['test/*.rb'] = {'dispatch': ruby + ['-Itest', '-Ilib', '{file}']}
                                else
                                  let projections['test/*.rb'] = {'dispatch': ruby + ['-Itest', '{file}']}
                                endif
                                let projections['spec/*_spec.rb'].dispatch = s:binstub(b:rake_root, 'rspec') + ['{file}']
                                call filter(projections['lib/*.rb'].alternate, 'exists(v:val[0:3])')
                                call filter(projections, 'v:key[4] !=# "/" || exists(v:key[0:3])')
                                let gemspec = fnamemodify(get(split(glob(b:rake_root.'/*.gemspec'), "\n"), 0, 'Gemfile'), ':t')
                                let projections[gemspec] = {'type': 'lib'}
                                if gemspec !=# 'Gemfile'
                                  let projections[gemspec].dispatch = ['gem', 'build', '{file}']
                                endif
                                call projectionist#append(b:rake_root, projections)
                                let secondary = { 'test/*_test.rb': exists('test') ? {'type': 'spec'} : {}, 'spec/*_spec.rb': exists('spec') ? {'type': 'test'} : {}}
                                call filter(secondary, '!empty(v:val)')
                                if !empty(secondary)
                                  call projectionist#append(b:rake_root, secondary)
                                endif
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 191 times
Total time:   0.002402
 Self time:   0.002402

count  total (s)   self (s)
  191              0.000941   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  191              0.000723   let dict[a:varname] = a:val
  191              0.000588   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  xolox#misc#perm#update()
Called 1 time
Total time:   0.029799
 Self time:   0.000686

count  total (s)   self (s)
                              " Atomically update a file's contents while preserving the owner, group and
                              " mode. The first argument is the pathname of the file to update (a string).
                              " The second argument is the list of lines to be written to the file. Writes
                              " the new contents to a temporary file and renames the temporary file into
                              " place, thereby preventing readers from reading a partially written file.
                              " Returns 1 if the file is successfully updated, 0 otherwise.
                              "
                              " Note that if `xolox#misc#perm#get()` and `xolox#misc#perm#set()` cannot be
                              " used to preserve the file owner/group/mode the file is still updated using
                              " a rename (for compatibility with non-UNIX systems and incompatible
                              " `/usr/bin/stat` implementations) so in that case you can still lose the
                              " file's owner/group/mode.
    1   0.000016   0.000005   let starttime = xolox#misc#timer#start()
    1              0.000004   let temporary_file = printf('%s.tmp', a:fname)
    1   0.000023   0.000009   call xolox#misc#msg#debug("vim-misc %s: Writing new contents of %s to temporary file %s ..", g:xolox#misc#version, a:fname, temporary_file)
    1              0.000328   if writefile(a:contents, temporary_file) == 0
    1   0.029089   0.000049     call xolox#misc#perm#set(temporary_file, xolox#misc#perm#get(a:fname))
    1   0.000040   0.000013     call xolox#misc#msg#debug("vim-misc %s: Replacing %s with %s ..", g:xolox#misc#version, a:fname, temporary_file)
    1              0.000250     if rename(temporary_file, a:fname) == 0
    1   0.000036   0.000015       call xolox#misc#timer#stop("vim-misc %s: Successfully updated %s using atomic rename in %s.", g:xolox#misc#version, a:fname, starttime)
    1              0.000003       return 1
                                endif
                              endif
                              if filereadable(temporary_file)
                                call delete(temporary_file)
                              endif
                              return 0

FUNCTION  <SNR>214_NetrwGetWord()
Called 25 times
Total time:   0.005945
 Self time:   0.004413

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetWord() liststyle=".s:ShowStyle()." virtcol=".virtcol("."))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
   25              0.000175   let keepsol= &l:sol
   25              0.000207   setl nosol
                            
   25   0.001693   0.000161   call s:UseBufWinVars()
                            
                              " insure that w:netrw_liststyle is set up
   25              0.000060   if !exists("w:netrw_liststyle")
                               if exists("g:netrw_liststyle")
                                let w:netrw_liststyle= g:netrw_liststyle
                               else
                                let w:netrw_liststyle= s:THINLIST
                               endif
                            "   call Decho("w:netrw_liststyle=".w:netrw_liststyle,'~'.expand("<slnum>"))
                              endif
                            
   25              0.000132   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                               " Active Banner support
                            "   call Decho("active banner handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= "./"
                               let curline= getline('.')
                            
                               if curline =~# '"\s*Sorted by\s'
                                NetrwKeepj norm s
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "s" also works'
                            
                               elseif curline =~# '"\s*Sort sequence:'
                                let s:netrw_skipbrowse= 1
                                echo 'Press "S" to edit sorting sequence'
                            
                               elseif curline =~# '"\s*Quick Help:'
                                NetrwKeepj norm ?
                                let s:netrw_skipbrowse= 1
                            
                               elseif curline =~# '"\s*\%(Hiding\|Showing\):'
                                NetrwKeepj norm a
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "a" also works'
                            
                               elseif line("$") > w:netrw_bannercnt
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt
                               endif
                            
                              elseif w:netrw_liststyle == s:THINLIST
                            "   call Decho("thin column handling",'~'.expand("<slnum>"))
   25              0.000412    NetrwKeepj norm! 0
   25              0.000308    let dirname= substitute(getline('.'),'\t -->.*$','','')
                            
   25              0.000030   elseif w:netrw_liststyle == s:LONGLIST
                            "   call Decho("long column handling",'~'.expand("<slnum>"))
                               NetrwKeepj norm! 0
                               let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Decho("treelist handling",'~'.expand("<slnum>"))
                               let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
                               let dirname= substitute(dirname,'\t -->.*$','','')
                            
                              else
                            "   call Decho("obtain word from wide listing",'~'.expand("<slnum>"))
                               let dirname= getline('.')
                            
                               if !exists("b:netrw_cpf")
                                let b:netrw_cpf= 0
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                call histdel("/",-1)
                            "   "call Decho("computed cpf=".b:netrw_cpf,'~'.expand("<slnum>"))
                               endif
                            
                            "   call Decho("buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                               let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
                            "   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt,'~'.expand("<slnum>"))
                            "   call Decho("1: dirname<".dirname.">",'~'.expand("<slnum>"))
                               if filestart == 0
                                NetrwKeepj norm! 0ma
                               else
                                call cursor(line("."),filestart+1)
                                NetrwKeepj norm! ma
                               endif
                               let rega= @a
                               let eofname= filestart + b:netrw_cpf + 1
                               if eofname <= col("$")
                                call cursor(line("."),filestart+b:netrw_cpf+1)
                                NetrwKeepj norm! "ay`a
                               else
                                NetrwKeepj norm! "ay$
                               endif
                               let dirname = @a
                               let @a      = rega
                            "   call Decho("2: dirname<".dirname.">",'~'.expand("<slnum>"))
                               let dirname= substitute(dirname,'\s\+$','','e')
                            "   call Decho("3: dirname<".dirname.">",'~'.expand("<slnum>"))
                              endif
                            
                              " symlinks are indicated by a trailing "@".  Remove it before further processing.
   25              0.000147   let dirname= substitute(dirname,"@$","","")
                            
                              " executables are indicated by a trailing "*".  Remove it before further processing.
   25              0.000099   let dirname= substitute(dirname,"\*$","","")
                            
   25              0.000128   let &l:sol= keepsol
                            
                            "  call Dret("s:NetrwGetWord <".dirname.">")
   25              0.000042   return dirname

FUNCTION  xolox#session#save_session()
Called 1 time
Total time:   0.005492
 Self time:   0.000222

count  total (s)   self (s)
                              " Save the current Vim editing session to a Vim script using the
                              " [:mksession] [] command and some additional Vim magic provided by the
                              " vim-session plug-in. When the generated session script is later sourced
                              " using the [:source] [] command (possibly in another process or even on
                              " another machine) it will restore the editing session to its previous state
                              " (provided all of the files involved in the session are still there at
                              " their original locations).
                              "
                              " The first argument is expected to be a list, it will be extended with the
                              " lines to be added to the session script. The second argument is expected
                              " to be the filename under which the script will later be saved (it's
                              " embedded in a comment at the top of the script).
                              "
                              " [:mksession]: http://vimdoc.sourceforge.net/htmldoc/starting.html#:mksession
                              " [:source]: http://vimdoc.sourceforge.net/htmldoc/repeat.html#:source
    1   0.000123   0.000004   let is_all_tabs = xolox#session#include_tabs()
    1              0.000006   call add(a:commands, '" ' . a:filename . ':')
    1              0.000005   call add(a:commands, '" Vim session script' . (is_all_tabs ? '' : ' for a single tab page') . '.')
    1              0.000053   call add(a:commands, '" Created by session.vim ' . g:xolox#session#version . ' on ' . strftime('%d %B %Y at %H:%M:%S.'))
    1              0.000004   call add(a:commands, '" Open this file in Vim and run :source % to restore your session.')
    1              0.000002   call add(a:commands, '')
    1              0.000001   if &verbose >= 1
                                call add(a:commands, 'set verbose=' . &verbose)
                              endif
                              " We save the GUI options only for global sessions, not for tab scoped
                              " sessions. Also, if the Vim we're currently running in doesn't have GUI
                              " support, Vim will report &go as an empty string. We should never persist
                              " this value if the user didn't specifically set it! Otherwise the next time
                              " the session is restored in a GUI Vim, things will look funky :-).
    1              0.000006   if has('gui') && is_all_tabs
                                call add(a:commands, 'set guioptions=' . escape(&go, ' "\'))
                                if xolox#misc#option#get('session_persist_font', 1)
                                  call add(a:commands, 'silent! set guifont=' . escape(&gfn, ' "\'))
                                endif
                              endif
    1   0.000024   0.000009   call xolox#session#save_globals(a:commands)
    1              0.000001   if is_all_tabs
    1   0.000095   0.000013     call xolox#session#save_features(a:commands)
    1              0.000001     if g:session_persist_colors
    1   0.000043   0.000007       call xolox#session#save_colors(a:commands)
    1              0.000001     endif
    1              0.000001   endif
    1   0.000042   0.000012   call xolox#session#save_qflist(a:commands)
    1   0.004044   0.000024   call xolox#session#save_state(a:commands)
    1              0.000006   if is_all_tabs
    1   0.000989   0.000021     call xolox#session#save_fullscreen(a:commands)
    1              0.000003     call add(a:commands, 'doautoall SessionLoadPost')
    1              0.000001   else
                                call add(a:commands, 'let s:winrestcmd = winrestcmd()')
                                call add(a:commands, 'windo doautocmd SessionLoadPost')
                                call s:jump_to_window(a:commands, tabpagenr(), winnr())
                                call add(a:commands, 'silent! execute s:winrestcmd')
                              endif
    1              0.000003   call add(a:commands, 'unlet SessionLoad')
    1              0.000002   call add(a:commands, '" vim: ft=vim ro nowrap smc=128')

FUNCTION  <SNR>214_UseBufWinVars()
Called 43 times
Total time:   0.002351
 Self time:   0.002351

count  total (s)   self (s)
                            "  call Dfunc("s:UseBufWinVars()")
   43              0.000389   if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
   43              0.000222   if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
   43              0.000174   if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
   43              0.000253   if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
   43              0.000186   if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
   43              0.000206   if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
   43              0.000214   if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
   43              0.000180   if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
   43              0.000169   if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
   43              0.000174   if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
                            "  call Dret("s:UseBufWinVars")

FUNCTION  <SNR>135_ALEQueueImpl()
Called 117 times
Total time:   0.077394
 Self time:   0.006327

count  total (s)   self (s)
  117              0.000290     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
  117              0.000302     if type(a:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
  117   0.014187   0.000479     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
  117              0.000194     if a:linting_flag is# 'lint_file'
   89              0.000345         let s:should_lint_file_for_buffer[a:buffer] = 1
   89              0.000049     endif
                            
  117              0.000146     if s:lint_timer != -1
   19              0.000051         call timer_stop(s:lint_timer)
   19              0.000024         let s:lint_timer = -1
   19              0.000012     endif
                            
  117   0.027587   0.000937     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
  117              0.000199     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
   81              0.000242         if has_key(g:ale_buffer_info, a:buffer)
                                        call ale#engine#RunLinters(a:buffer, [], 1)
                                    endif
                            
   81              0.000053         return
                                endif
                            
   36              0.000040     if a:delay > 0
   19              0.000034         let s:queued_buffer_number = a:buffer
   19              0.000097         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   19              0.000011     else
   17   0.031295   0.000586         call ale#Lint(-1, a:buffer)
   17              0.000013     endif

FUNCTION  airline#util#shorten()
Called 1036 times
Total time:   0.016350
 Self time:   0.016350

count  total (s)   self (s)
 1036              0.004934   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 1036              0.001141     return a:text
                              endif

FUNCTION  <SNR>109_option_init()
Called 1702 times
Total time:   0.076274
 Self time:   0.026883

count  total (s)   self (s)
 1702              0.005309   let b = exists("b:delimitMate_" . a:name)
 1702              0.004576   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
 1702              0.001454   if !b && !g
 1702              0.002050     let value = a:default
 1702              0.001143   elseif b
                                exec "let value = b:delimitMate_" . a:name
                              else
                                exec "let value = g:delimitMate_" . a:name
                              endif
 1702   0.055160   0.005769   call s:set(a:name, value)

FUNCTION  <SNR>44_TmuxAwareNavigate()
Called 11 times
Total time:   0.154135
 Self time:   0.003032

count  total (s)   self (s)
   11              0.000061   let nr = winnr()
   11              0.000032   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
   11              0.000011   if !tmux_last_pane
   11   0.151846   0.001406     call s:VimNavigate(a:direction)
   11              0.000029   endif
   11              0.000054   let at_tab_page_edge = (nr == winnr())
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
   11   0.001400   0.000737   if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
                                if g:tmux_navigator_save_on_switch == 1
                                  try
                                    update " save the active buffer. See :help update
                                  catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
                                  endtry
                                elseif g:tmux_navigator_save_on_switch == 2
                                  try
                                    wall " save all the buffers. See :help wall
                                  catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
                                  endtry
                                endif
                                let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
                                silent call s:TmuxCommand(args)
                                if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
                                let s:tmux_is_last_pane = 1
                              else
   11              0.000029     let s:tmux_is_last_pane = 0
   11              0.000007   endif

FUNCTION  <SNR>159_update_git_branch()
Called 647 times
Total time:   0.155971
 Self time:   0.028546

count  total (s)   self (s)
  647              0.000883   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  647   0.130867   0.003442   let name = fugitive#head(7)
  647              0.001323   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
  647              0.002466   let s:git_dirs[a:path] = name
  647              0.001680   let s:vcs_config['git'].branch = name

FUNCTION  <SNR>158_get_hunks_gitgutter()
Called 468 times
Total time:   0.022803
 Self time:   0.005527

count  total (s)   self (s)
  468   0.006146   0.002816   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    9              0.000007     return ''
                              endif
  459   0.015546   0.001600   return GitGutterGetHunkSummary()

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 23 times
Total time:   0.000842
 Self time:   0.000245

count  total (s)   self (s)
   23   0.000791   0.000194   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  ale#util#BinarySearch()
Called 514 times
Total time:   0.007042
 Self time:   0.007042

count  total (s)   self (s)
  514              0.000849     let l:min = 0
  514              0.001916     let l:max = len(a:loclist) - 1
                            
  514              0.000923     while 1
  514              0.001022         if l:max < l:min
  514              0.000701             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  <SNR>74_find_root()
Called 90 times
Total time:   0.029511
 Self time:   0.028807

count  total (s)   self (s)
   90   0.004155   0.003451   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
  180              0.000787   for p in [$GEM_HOME] + split($GEM_PATH,':')
   90              0.000361     if p !=# '' && s:shellslash(p.'/gems/') ==# (root)[0 : strlen(p)+5]
                                  return simplify(s:shellslash(p.'/gems/')).matchstr(root[strlen(p)+6:-1],'[^\\/]*')
                                endif
   90              0.000067   endfor
   90              0.000118   let previous = ''
  616              0.001210   while root !=# previous && root !=# '/'
  526              0.006508     if filereadable(root.'/Rakefile') || (isdirectory(root.'/lib') && filereadable(root.'/Gemfile'))
                                  if filereadable(root.'/config/environment.rb')
                                    return ''
                                  else
                                    return root
                                  endif
                                elseif root =~# '[\/]gems[\/][0-9.]\+[\/]gems[\/][[:alnum:]._-]\+$'
                                  return root
                                endif
  526              0.000750     let previous = root
  526              0.001363     let root = fnamemodify(root, ':h')
  526              0.000542   endwhile
   90              0.000081   return ''

FUNCTION  <SNR>44_VimNavigate()
Called 11 times
Total time:   0.150440
 Self time:   0.007116

count  total (s)   self (s)
   11              0.000022   try
   11   0.148637   0.005313     execute 'wincmd ' . a:direction
   11              0.000016   catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
                              endtry

FUNCTION  <SNR>22_DetectScala()
Called 9 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    9              0.000048     if getline(1) =~# '^#!\(/usr\)\?/bin/env\s\+scalas\?'
                                    set filetype=scala
                                endif

FUNCTION  <SNR>87_wrapscan_mes()
Called 490 times
Total time:   0.002954
 Self time:   0.002954

count  total (s)   self (s)
  490              0.002110 	if !exists("s:start_pos") || !exists("s:is_back")
  490              0.000444 		return ""
                            	endif
                            	let prev_pos = s:start_pos
                            	let pos = getpos(".")
                            	let result = ""
                            	if !empty(prev_pos) && s:pos_less(pos, prev_pos) && !s:is_back
                            		let result = g:anzu_bottomtop_word
                            	elseif !empty(prev_pos) && s:pos_less(prev_pos, pos) && s:is_back
                            		let result = g:anzu_topbottom_word
                            	endif
                            	unlet s:start_pos
                            	unlet s:is_back
                            
                            	return result

FUNCTION  xolox#misc#path#join()
Called 5 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
    5              0.000017   if type(a:parts) == type([])
    5              0.000005     if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
    5              0.000038       return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''

FUNCTION  xolox#session#save_globals()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                              " Serialize the values of the global variables configured by the user with
                              " the `g:session_persist_globals` option. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
    1              0.000006   for global in g:session_persist_globals
                                call add(a:commands, printf("let %s = %s", global, string(eval(global))))
                              endfor

FUNCTION  <SNR>167_CheckDefined()
Called 4211 times
Total time:   0.083541
 Self time:   0.083541

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 4211              0.011423   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
 4211              0.011691   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 4211              0.006854   for val in a:colors
 4211              0.009689     if !empty(val) && val !=# 'NONE'
 4211              0.004018       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  LaTeXtoUnicode#Refresh()
Called 95 times
Total time:   0.009722
 Self time:   0.003184

count  total (s)   self (s)
                            
   95   0.004769   0.000510   call s:L2U_Setup()
                            
                              " by default, LaTeX-to-Unicode is only active on julia files
   95   0.001979   0.000713   let file_types = s:L2U_file_type_regex(get(g:, "latex_to_unicode_file_types", "julia"))
   95   0.001566   0.000553   let file_types_blacklist = s:L2U_file_type_regex(get(g:, "latex_to_unicode_file_types_blacklist", "$^"))
                            
   95              0.000631   if match(&filetype, file_types) < 0 || match(&filetype, file_types_blacklist) >= 0
   95              0.000108     if b:l2u_enabled
                                  call LaTeXtoUnicode#Disable()
                                else
   95              0.000061       return
                                endif
                              elseif !b:l2u_enabled
                                call LaTeXtoUnicode#Enable()
                              endif
                            

FUNCTION  airline#highlighter#highlight()
Called 52 times
Total time:   1.027076
 Self time:   0.123878

count  total (s)   self (s)
   52              0.000101   let bufnr = a:0 ? a:1 : ''
   52              0.000158   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   52              0.000433   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   52              0.000116   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
  120              0.000144   for mode in mapped
   68              0.000158     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
   68              0.000358     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   60              0.000181       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 1127              0.002524       for kvp in items(dict)
 1067              0.001899         let mode_colors = kvp[1]
 1067              0.001686         let name = kvp[0]
 1067              0.002625         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
   14              0.000023           let name = 'airline_c'.bufnr
   14              0.000009         endif
 1067   0.214440   0.006307         call airline#highlighter#exec(name.suffix, mode_colors)
                            
 3201              0.005445         for accent in keys(s:accents)
 2134              0.004795           if !has_key(p.accents, accent)
                                        continue
                                      endif
 2134              0.007428           let colors = copy(mode_colors)
 2134              0.004700           if p.accents[accent][0] != ''
 1067              0.002506             let colors[0] = p.accents[accent][0]
 1067              0.000588           endif
 2134              0.003685           if p.accents[accent][2] != ''
 1067              0.002131             let colors[2] = p.accents[accent][2]
 1067              0.000529           endif
 2134              0.003345           if len(colors) >= 5
 2134              0.006220             let colors[4] = get(p.accents[accent], 4, '')
 2134              0.001242           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
 2134   0.431331   0.014478           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
 2134              0.001756         endfor
 1067              0.000893       endfor
                            
                                  " TODO: optimize this
  686              0.001455       for sep in items(s:separators)
  626   0.282973   0.004761         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  626              0.000575       endfor
   60              0.000089     endif
   68              0.000052   endfor

FUNCTION  <SNR>209_on_exit_vim()
Called 22 times
Total time:   0.020655
 Self time:   0.000865

count  total (s)   self (s)
   22   0.020624   0.000834   call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))

FUNCTION  <SNR>159_update_untracked()
Called 647 times
Total time:   0.075644
 Self time:   0.047364

count  total (s)   self (s)
  647              0.011881   let file = expand("%:p")
  647              0.005108   if empty(file) || isdirectory(file)
  179              0.000176     return
                              endif
                            
  468              0.000739   let needs_update = 1
 1404              0.002549   for vcs in keys(s:vcs_config)
  936              0.004481     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
  936              0.002754     if has_key(s:vcs_config[vcs].untracked, file)
  438              0.000555       let needs_update = 0
  438   0.008034   0.002617       call airline#extensions#branch#update_untracked_config(file, vcs)
  438              0.000274     endif
  936              0.000832   endfor
                            
  468              0.000463   if !needs_update
  438              0.000333     return
                              endif
                            
   90              0.000472   for vcs in keys(s:vcs_config)
   60              0.000268     let config = s:vcs_config[vcs]
   60              0.000089     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
   60   0.024803   0.001940       call airline#async#vim_vcs_untracked(config, file)
   60              0.000093     else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
   60              0.000151   endfor

FUNCTION  <SNR>110_set()
Called 1702 times
Total time:   0.034864
 Self time:   0.034864

count  total (s)   self (s)
 1702              0.002167   let scope = a:0 ? a:1 : 's'
 1702              0.003291   let bufnr = bufnr('%')
 1702              0.004209   if !exists('s:options[bufnr]')
   13              0.000032     let s:options[bufnr] = {}
   13              0.000011   endif
 1702              0.001815   if scope == 's'
 1702              0.004053     let name = 's:options.' . bufnr . '.' . a:name
 1702              0.000986   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
 1702              0.007149   exec 'let ' . name . ' = a:value'

FUNCTION  GetVimIndent()
Called 2 times
Total time:   0.000515
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000019   let ignorecase_save = &ignorecase
    2              0.000003   try
    2              0.000011     let &ignorecase = 0
    2   0.000459   0.000027     return GetVimIndentIntern()
                              finally
    2              0.000010     let &ignorecase = ignorecase_save
    2              0.000004   endtry

FUNCTION  airline#parts#ffenc()
Called 498 times
Total time:   0.011464
 Self time:   0.011464

count  total (s)   self (s)
  498              0.002027   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  498              0.001050   let bomb     = &l:bomb ? '[BOM]' : ''
  498              0.003508   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  498              0.001927   if expected is# &fenc.bomb.ff
                                return ''
                              else
  498              0.001458     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>45_define_commands()
Called 61 times
Total time:   0.018085
 Self time:   0.018085

count  total (s)   self (s)
 1708              0.001764   for command in s:commands
 1647              0.014631     exe 'command! -buffer '.command
 1647              0.001246   endfor

FUNCTION  <SNR>175_L2U_SetTab()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000006   if !b:l2u_cmdtab_set && get(g:, "latex_to_unicode_tab", 1) && b:l2u_enabled
                                cmap <buffer> <S-Tab> <Plug>L2UCmdTab
                                cnoremap <buffer> <Plug>L2UCmdTab <C-\>eLaTeXtoUnicode#CmdTab()<CR>
                                let b:l2u_cmdtab_set = 1
                              endif
    1              0.000001   if b:l2u_tab_set
                                return
                              endif
                              " g:did_insert_enter is set from an autocommand in ftdetect
    1              0.000002   if a:wait_insert_enter && !get(g:, "did_insert_enter", 0)
                                return
                              endif
    1              0.000003   if !get(g:, "latex_to_unicode_tab", 1) || !b:l2u_enabled
    1              0.000001     return
                              endif
                            
                              " Backup the previous omnifunc (the check is probably not really needed)
                              if get(b:, "prev_omnifunc", "") != "LaTeXtoUnicode#omnifunc"
                                let b:prev_omnifunc = &omnifunc
                              endif
                              setlocal omnifunc=LaTeXtoUnicode#omnifunc
                            
                              call s:L2U_SetFallbackMapping('<Tab>', s:l2u_fallback_trigger)
                              imap <buffer> <Tab> <Plug>L2UTab
                              inoremap <buffer><expr> <Plug>L2UTab LaTeXtoUnicode#Tab()
                            
                              augroup L2UTab
                                autocmd! * <buffer>
                                " Every time a completion finishes, the fallback may be invoked
                                autocmd CompleteDone <buffer> call LaTeXtoUnicode#FallbackCallback()
                              augroup END
                            
                              let b:l2u_tab_set = 1

FUNCTION  ale#engine#RemoveManagedFiles()
Called 35 times
Total time:   0.001660
 Self time:   0.001336

count  total (s)   self (s)
   35              0.000131     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
   35   0.000441   0.000117     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
   35              0.000093     if has_key(l:info, 'temporary_file_list')
   35              0.000074         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
   35              0.000080         let l:info.temporary_file_list = []
   35              0.000022     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
   35              0.000103     if has_key(l:info, 'temporary_directory_list')
   35              0.000054         for l:directory in l:info.temporary_directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
   35              0.000083         let l:info.temporary_directory_list = []
   35              0.000020     endif

FUNCTION  <SNR>214_NetrwWideListing()
Called 18 times
Total time:   0.001626
 Self time:   0.001626

count  total (s)   self (s)
                            
   18              0.000037   if w:netrw_liststyle == s:WIDELIST
                            "   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
                               " look for longest filename (cpf=characters per filename)
                               " cpf: characters per filename
                               " fpl: filenames per line
                               " fpc: filenames per column
                               setl ma noro
                            "   call Decho("setl ma noro",'~'.expand("<slnum>"))
                               let b:netrw_cpf= 0
                               if line("$") >= w:netrw_bannercnt
                                exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                NetrwKeepj call histdel("/",-1)
                               else
                            "    call Dret("NetrwWideListing")
                                return
                               endif
                               let b:netrw_cpf= b:netrw_cpf + 2
                            "   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf,'~'.expand("<slnum>"))
                            
                               " determine qty files per line (fpl)
                               let w:netrw_fpl= winwidth(0)/b:netrw_cpf
                               if w:netrw_fpl <= 0
                                let w:netrw_fpl= 1
                               endif
                            "   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl,'~'.expand("<slnum>"))
                            
                               " make wide display
                               "   fpc: files per column of wide listing
                               exe 'sil NetrwKeepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'S",submatch(0)),"\\")/'
                               NetrwKeepj call histdel("/",-1)
                               let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
                               let newcolstart = w:netrw_bannercnt + fpc
                               let newcolend   = newcolstart + fpc - 1
                            "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]",'~'.expand("<slnum>"))
                               if has("clipboard")
                                sil! let keepregstar = @*
                                sil! let keepregplus = @+
                               endif
                               while line("$") >= newcolstart
                                if newcolend > line("$") | let newcolend= line("$") | endif
                                let newcolqty= newcolend - newcolstart
                                exe newcolstart
                                if newcolqty == 0
                                 exe "sil! NetrwKeepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
                                else
                                 exe "sil! NetrwKeepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
                                endif
                                exe "sil! NetrwKeepj ".newcolstart.','.newcolend.'d _'
                                exe 'sil! NetrwKeepj '.w:netrw_bannercnt
                               endwhile
                               if has("clipboard")
                                sil! let @*= keepregstar
                                sil! let @+= keepregplus
                               endif
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$s/\s\+$//e'
                               NetrwKeepj call histdel("/",-1)
                               exe 'nno <buffer> <silent> w	:call search(''^.\\|\s\s\zs\S'',''W'')'."\<cr>"
                               exe 'nno <buffer> <silent> b	:call search(''^.\\|\s\s\zs\S'',''bW'')'."\<cr>"
                            "   call Decho("NetrwWideListing) setl noma nomod ro",'~'.expand("<slnum>"))
                               exe "setl ".g:netrw_bufsettings
                            "   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("NetrwWideListing")
                               return
                              else
   18              0.000108    if hasmapto("w","n")
   18              0.000236     sil! nunmap <buffer> w
   18              0.000010    endif
   18              0.000066    if hasmapto("b","n")
   18              0.000098     sil! nunmap <buffer> b
   18              0.000012    endif
   18              0.000004   endif
                            

FUNCTION  <SNR>182_last_session_persist()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001   if g:session_default_to_last
                                if writefile([a:name], s:last_session_file()) != 0
                                  call xolox#misc#msg#warn("session.vim %s: Failed to persist name of last used session!", g:xolox#session#version)
                                endif
                              endif

FUNCTION  <SNR>141_Highlight_Matching_Pair()
Called 538 times
Total time:   0.049526
 Self time:   0.049526

count  total (s)   self (s)
                              " Remove any previous match.
  538              0.001985   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  538              0.002504   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  538              0.001354   let c_lnum = line('.')
  538              0.001292   let c_col = col('.')
  538              0.000639   let before = 0
                            
  538              0.001489   let text = getline(c_lnum)
  538              0.008368   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  538              0.001047   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  538              0.002272     let [c_before, c] = matches[1:2]
  538              0.000352   endif
  538              0.011838   let plist = split(&matchpairs, '.\zs[:,]')
  538              0.001690   let i = index(plist, c)
  538              0.000590   if i < 0
                                " not found, in Insert mode try character before the cursor
  538              0.001511     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    6              0.000017       let before = strlen(c_before)
    6              0.000009       let c = c_before
    6              0.000013       let i = index(plist, c)
    6              0.000004     endif
  538              0.000492     if i < 0
                                  " not found, nothing to do
  538              0.000472       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>183_unescape()
Called 69 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
   69              0.000305   return substitute(a:s, '\\\([\\,]\)', '\1', 'g')

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 2 times
Total time:   0.000052
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000051   0.000027   return getbufvar(s:bufnr, 'changedtick') != gitgutter#utility#getbufvar(s:bufnr, 'last_tick')

FUNCTION  <SNR>60_addtomrufs()
Called 31 times
Total time:   0.026327
 Self time:   0.012150

count  total (s)   self (s)
   31              0.001192 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
   31              0.000173 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   31              0.000272 	let abs_fn = fnamemodify(fn,':p')
   31              0.009001 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
    9              0.000015 		retu
                            	en
   22              0.000162 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
   22              0.000023 	if idx
   14              0.000234 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   14              0.000047 		cal insert(s:mrufs, fn)
   14              0.000045 		if {s:soup} && idx < 0
    8   0.014839   0.000662 			cal s:savetofile(s:mergelists())
    8              0.000010 		en
   14              0.000008 	en

FUNCTION  <SNR>171_get_prev_group()
Called 522 times
Total time:   0.005317
 Self time:   0.005317

count  total (s)   self (s)
  522              0.000789   let x = a:i - 1
  604              0.000622   while x >= 0
  522              0.001068     let group = a:sections[x][0]
  522              0.000908     if group != '' && group != '|'
  440              0.000404       return group
                                endif
   82              0.000086     let x = x - 1
   82              0.000049   endwhile
   82              0.000054   return ''

FUNCTION  <SNR>45_shellslash()
Called 289 times
Total time:   0.003813
 Self time:   0.002157

count  total (s)   self (s)
  289   0.002646   0.000990   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
  289              0.000275     return a:path
                              endif

FUNCTION  <SNR>214_NetrwCursor()
Called 42 times
Total time:   0.002091
 Self time:   0.002091

count  total (s)   self (s)
   42              0.000162   if !exists("w:netrw_liststyle")
                               let w:netrw_liststyle= g:netrw_liststyle
                              endif
                            "  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)
                            
   42              0.000140   if &ft != "netrw"
                               " if the current window isn't a netrw directory listing window, then use user cursorline/column
                               " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
                            "   call Decho("case ft!=netrw: use user cul,cuc",'~'.expand("<slnum>"))
    7              0.000057    let &l:cursorline   = s:netrw_usercul
    7              0.000030    let &l:cursorcolumn = s:netrw_usercuc
                            
    7              0.000007   elseif g:netrw_cursor == 4
                               " all styles: cursorline, cursorcolumn
                            "   call Decho("case g:netrw_cursor==4: setl cul cuc",'~'.expand("<slnum>"))
                               setl cursorline
                               setl cursorcolumn
                            
                              elseif g:netrw_cursor == 3
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc",'~'.expand("<slnum>"))
                                setl cursorline
                                setl cursorcolumn
                               else
                            "    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                                let &l:cursorcolumn   = s:netrw_usercuc
                               endif
                            
                              elseif g:netrw_cursor == 2
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, user's cursorcolumn
                            "   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)",'~'.expand("<slnum>"))
   35              0.000122    let &l:cursorcolumn = s:netrw_usercuc
   35              0.000077    setl cursorline
                            
   35              0.000033   elseif g:netrw_cursor == 1
                               " thin-long-tree: user's cursorline, user's cursorcolumn
                               " wide          : cursorline,        user's cursorcolumn
                               let &l:cursorcolumn = s:netrw_usercuc
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)",'~'.expand("<slnum>"))
                                setl cursorline
                               else
                            "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)",'~'.expand("<slnum>"))
                                let &l:cursorline   = s:netrw_usercul
                               endif
                            
                              else
                               " all styles: user's cursorline, user's cursorcolumn
                            "   call Decho("default: (use user's cul,cuc)",'~'.expand("<slnum>"))
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            
                            "  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)

FUNCTION  <SNR>24_LoadFTPlugin()
Called 62 times
Total time:   0.229226
 Self time:   0.224184

count  total (s)   self (s)
   62              0.000183     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
   62              0.000198     let s = expand("<amatch>")
   62              0.000089     if s != ""
   62              0.000378       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
  124              0.000426       for name in split(s, '\.')
   62   0.227016   0.221974 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
   62              0.000125       endfor
   62              0.000047     endif

FUNCTION  <SNR>172_get_section()
Called 488 times
Total time:   0.015012
 Self time:   0.013565

count  total (s)   self (s)
  488              0.001173   if has_key(s:section_truncate_width, a:key)
  332              0.000809     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   10              0.000006       return ''
                                endif
  322              0.000157   endif
  478              0.000643   let spc = g:airline_symbols.space
  478              0.001696   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  478   0.004329   0.002882   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  478              0.002671   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  478              0.001507   return empty(text) ? '' : prefix.text.suffix

FUNCTION  delimitMate#Get()
Called 2612 times
Total time:   0.048625
 Self time:   0.010669

count  total (s)   self (s)
 2612   0.048031   0.010075   return call('s:get', a:000)

FUNCTION  xolox#misc#os#is_win()
Called 6 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                              " Returns 1 (true) when on Microsoft Windows, 0 (false) otherwise.
    6              0.000043   return has('win16') || has('win32') || has('win64')

FUNCTION  airline#parts#paste()
Called 554 times
Total time:   0.001425
 Self time:   0.001425

count  total (s)   self (s)
  554              0.001174   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 46 times
Total time:   0.369219
 Self time:   0.004794

count  total (s)   self (s)
   46   0.000678   0.000451   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   82              0.000753   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
   36   0.000284   0.000161     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
   36              0.000131     call setwinvar(nr, 'airline_active', 0)
   36              0.000184     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   36   0.118567   0.000410     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   36              0.000031   endfor
                            
   46              0.000111   unlet! w:airline_render_left w:airline_render_right
   46              0.000918   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
   46              0.000084   let w:airline_active = 1
   46              0.000233   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   46   0.246474   0.000556   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#utility#restore_shell()
Called 37 times
Total time:   0.001277
 Self time:   0.001277

count  total (s)   self (s)
   37              0.000106   if has('unix')
   37              0.000168     if exists('s:shell')
   37              0.000380       let &shell = s:shell
   37              0.000240       let &shellcmdflag = s:shellcmdflag
   37              0.000142       let &shellredir = s:shellredir
   37              0.000022     endif
   37              0.000015   endif

FUNCTION  <SNR>211_clamp_pos()
Called 490 times
Total time:   0.008725
 Self time:   0.004795

count  total (s)   self (s)
  490   0.008428   0.004498 	return s:pos_less_equal(a:min, a:pos) && s:pos_less_equal(a:pos, a:max)

FUNCTION  <SNR>214_NetrwOptionSave()
Called 40 times
Total time:   0.018653
 Self time:   0.018653

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            
   40              0.000185   if !exists("{a:vt}netrw_optionsave")
   40              0.000150    let {a:vt}netrw_optionsave= 1
   40              0.000030   else
                            "   call Dret("s:NetrwOptionSave : options already saved")
                               return
                              endif
                            "  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
   40              0.000104   let s:yykeep          = @@
   40              0.000398   if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
   40              0.000176   let {a:vt}netrw_aikeep    = &l:ai
   40              0.000158   let {a:vt}netrw_awkeep    = &l:aw
   40              0.000192   let {a:vt}netrw_bhkeep    = &l:bh
   40              0.000157   let {a:vt}netrw_blkeep    = &l:bl
   40              0.000148   let {a:vt}netrw_btkeep    = &l:bt
   40              0.000095   let {a:vt}netrw_bombkeep  = &l:bomb
   40              0.000096   let {a:vt}netrw_cedit     = &cedit
   40              0.000149   let {a:vt}netrw_cikeep    = &l:ci
   40              0.000144   let {a:vt}netrw_cinkeep   = &l:cin
   40              0.000162   let {a:vt}netrw_cinokeep  = &l:cino
   40              0.000160   let {a:vt}netrw_comkeep   = &l:com
   40              0.000164   let {a:vt}netrw_cpokeep   = &l:cpo
   40              0.000102   let {a:vt}netrw_diffkeep  = &l:diff
   40              0.000139   let {a:vt}netrw_fenkeep   = &l:fen
   40              0.000117   if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
   40              0.000170    let {a:vt}netrw_ffkeep    = &l:ff
   40              0.000025   endif
   40              0.000152   let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
   40              0.000142   let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
   40              0.000097   let {a:vt}netrw_hidkeep   = &l:hidden
   40              0.000131   let {a:vt}netrw_imkeep    = &l:im
   40              0.000151   let {a:vt}netrw_iskkeep   = &l:isk
   40              0.000124   let {a:vt}netrw_lskeep    = &l:ls
   40              0.000119   let {a:vt}netrw_makeep    = &l:ma
   40              0.000093   let {a:vt}netrw_magickeep = &l:magic
   40              0.000153   let {a:vt}netrw_modkeep   = &l:mod
   40              0.000117   let {a:vt}netrw_nukeep    = &l:nu
   40              0.000122   let {a:vt}netrw_rnukeep   = &l:rnu
   40              0.000104   let {a:vt}netrw_repkeep   = &l:report
   40              0.000166   let {a:vt}netrw_rokeep    = &l:ro
   40              0.000150   let {a:vt}netrw_selkeep   = &l:sel
   40              0.000131   let {a:vt}netrw_spellkeep = &l:spell
   40              0.000057   if !g:netrw_use_noswf
                               let {a:vt}netrw_swfkeep  = &l:swf
                              endif
   40              0.000115   if has("clipboard")
   40              0.010847    let {a:vt}netrw_starkeep = @*
   40              0.000074   endif
   40              0.000174   let {a:vt}netrw_tskeep    = &l:ts
   40              0.000142   let {a:vt}netrw_twkeep    = &l:tw           " textwidth
   40              0.000162   let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
   40              0.000111   let {a:vt}netrw_wrapkeep  = &l:wrap
   40              0.000111   let {a:vt}netrw_writekeep = &l:write
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
   40              0.000049   if g:netrw_keepdir
   40              0.000190    let {a:vt}netrw_dirkeep  = getcwd()
   40              0.000025   endif
   40              0.000094   if has("clipboard")
   40              0.000344    if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
   40              0.000018   endif
   40              0.000146   sil! let {a:vt}netrw_regslash= @/
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())

FUNCTION  <SNR>74_shellslash()
Called 90 times
Total time:   0.000704
 Self time:   0.000704

count  total (s)   self (s)
   90              0.000258   if exists('+shellslash') && !&shellslash
                                return substitute(a:path, '\\', '/', 'g')
                              else
   90              0.000104     return a:path
                              endif

FUNCTION  <SNR>45_can_diffoff()
Called 42 times
Total time:   0.000916
 Self time:   0.000916

count  total (s)   self (s)
   42              0.000827   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  ale#events#SaveEvent()
Called 2 times
Total time:   0.000531
 Self time:   0.000107

count  total (s)   self (s)
    2   0.000300   0.000034     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    2              0.000002     if l:should_lint
    2              0.000013         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    2              0.000000     endif
                            
    2   0.000048   0.000008     if ale#Var(a:buffer, 'fix_on_save')
                                    let l:will_fix = ale#fix#Fix('save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    2   0.000141   0.000023     if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  airline#parts#readonly()
Called 591 times
Total time:   0.004318
 Self time:   0.004318

count  total (s)   self (s)
  591              0.001920   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  591              0.000894     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>204_BuildSignMap()
Called 35 times
Total time:   0.005352
 Self time:   0.004352

count  total (s)   self (s)
   35   0.001217   0.000217     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   35              0.000064     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is type(0) && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
   35              0.000081         let l:selected_grouped_items = a:grouped_items
   35              0.000026     endif
                            
   35              0.000062     let l:sign_map = {}
   35              0.000075     let l:sign_offset = g:ale_sign_offset
                            
   35              0.000080     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
   35              0.000071     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
   35              0.000056     return l:sign_map

FUNCTION  ale#sign#ParseSigns()
Called 35 times
Total time:   0.006474
 Self time:   0.006474

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
   35              0.000075     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   35              0.000051     let l:result = []
   35              0.000060     let l:is_dummy_sign_set = 0
                            
  129              0.000223     for l:line in a:line_list
   94              0.003824         let l:match = matchlist(l:line, l:pattern)
                            
   94              0.000254         if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
                                    endif
   94              0.000177     endfor
                            
   35              0.000083     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#sign#GetSignCommands()
Called 35 times
Total time:   0.002031
 Self time:   0.002031

count  total (s)   self (s)
   35              0.000067     let l:command_list = []
   35              0.000080     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   35              0.000143     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   35              0.000111     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
   35              0.000096     for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   35              0.000061     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
   35              0.000046     return l:command_list

FUNCTION  ale#engine#RunLinters()
Called 35 times
Total time:   0.055895
 Self time:   0.003012

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   35   0.001014   0.000263     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   35   0.002431   0.000318     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   35   0.001045   0.000276     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   35   0.000592   0.000231     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   61              0.000097     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   26              0.000047         if !l:linter.lint_file || a:should_lint_file
   26   0.005445   0.000180             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
   26              0.000022         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   26              0.000060     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   35              0.000055     if l:can_clear_results
   35   0.043887   0.000263         call ale#engine#SetResults(a:buffer, [])
   35              0.000047     elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  CloseWindowOrKillBuffer()
Called 1 time
Total time:   0.035447
 Self time:   0.002736

count  total (s)   self (s)
    1              0.000030   let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))
                            
                              " We should never bdelete a nerd tree
    1              0.000014   if matchstr(expand("%"), 'NERD') == 'NERD'
                                wincmd c
                                return
                              endif
                            
    1              0.000002   if number_of_windows_to_this_buffer > 1
                                wincmd c
                              else
    1   0.035388   0.002677     bdelete
    1              0.000002   endif

FUNCTION  <SNR>204_UpdateLineNumbers()
Called 35 times
Total time:   0.001061
 Self time:   0.001061

count  total (s)   self (s)
   35              0.000084     let l:line_map = {}
   35              0.000063     let l:line_numbers_changed = 0
                            
   35              0.000083     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
   35              0.000055     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
   35              0.000047     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>214_NetrwBookHistHandler()
Called 18 times
Total time:   0.003179
 Self time:   0.003043

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
   18              0.000062   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                            
   18              0.000038   let ykeep    = @@
   18              0.000042   let curbufnr = bufnr("%")
                            
   18              0.000018   if a:chg == 0
                               " bookmark the current directory
                            "   call Decho("(user: <b>) bookmark the current directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(0)
                                echo "bookmarked marked files"
                               else
                                call s:MakeBookmark(a:curdir)
                                echo "bookmarked the current directory"
                               endif
                            
                              elseif a:chg == 1
                               " change to the bookmarked directory
                            "   call Decho("(user: <".v:count."gb>) change to the bookmarked directory",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist[v:count-1]")
                            "    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
                               else
                                echomsg "Sorry, bookmark#".v:count." doesn't exist!"
                               endif
                            
                              elseif a:chg == 2
                            "   redraw!
                               let didwork= 0
                               " list user's bookmarks
                            "   call Decho("(user: <q>) list user's bookmarks",'~'.expand("<slnum>"))
                               if exists("g:netrw_bookmarklist")
                            "    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks','~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1],'~'.expand("<slnum>"))
                                 echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
                                 let didwork = 1
                                 let cnt     = cnt + 1
                                endfor
                               endif
                            
                               " list directory history
                               let cnt     = g:netrw_dirhist_cnt
                               let first   = 1
                               let histcnt = 0
                               if g:netrw_dirhistmax > 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                            "    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt,'~'.expand("<slnum>"))
                                 if exists("g:netrw_dirhist_{cnt}")
                            "     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt},'~'.expand("<slnum>"))
                                  echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
                                  let didwork= 1
                                 endif
                                 let histcnt = histcnt + 1
                                 let first   = 0
                                 let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if didwork
                                call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               endif
                            
                              elseif a:chg == 3
                               " saves most recently visited directories (when they differ)
                            "   call Decho("(browsing) record curdir history",'~'.expand("<slnum>"))
   18              0.000160    if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
   18              0.000021     if g:netrw_dirhistmax > 0
   18              0.000045      let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
   18              0.000069      let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
   18              0.000009     endif
                            "    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
   18              0.000008    endif
                            
   18              0.000013   elseif a:chg == 4
                               " u: change to the previous directory stored on the history list
                            "   call Decho("(user: <u>) chg to prev dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
                                if g:netrw_dirhist_cnt < 0
                                 let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                 setl ma noro
                            "     call Decho("setl ma noro",'~'.expand("<slnum>"))
                                 sil! NetrwKeepj %d _
                                 setl nomod
                            "     call Decho("setl nomod",'~'.expand("<slnum>"))
                            "     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
                                exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                               else
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
                                else
                                 let g:netrw_dirhist_cnt= 0
                                endif
                                echo "Sorry, no predecessor directory exists yet"
                               endif
                            
                              elseif a:chg == 5
                               " U: change to the subsequent directory stored on the history list
                            "   call Decho("(user: <U>) chg to next dir from history",'~'.expand("<slnum>"))
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">",'~'.expand("<slnum>"))
                                 if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                            "      call Decho("setl ma noro",'~'.expand("<slnum>"))
                                  setl ma noro
                                  sil! NetrwKeepj %d _
                            "      call Decho("removed all lines from buffer (%d)",'~'.expand("<slnum>"))
                            "      call Decho("setl nomod",'~'.expand("<slnum>"))
                                  setl nomod
                            "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}),'~'.expand("<slnum>"))
                                 exe "NetrwKeepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                                else
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
                                 if g:netrw_dirhist_cnt < 0
                                  let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                 endif
                                 echo "Sorry, no successor directory exists yet"
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                                echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
                               endif
                            
                              elseif a:chg == 6
                            "   call Decho("(user: <mB>) delete bookmark'd directory",'~'.expand("<slnum>"))
                               if exists("s:netrwmarkfilelist_{curbufnr}")
                                call s:NetrwBookmark(1)
                                echo "removed marked files from bookmarks"
                               else
                                " delete the v:count'th bookmark
                                let iremove = v:count
                                let dremove = g:netrw_bookmarklist[iremove - 1]
                            "    call Decho("delete bookmark#".iremove."<".g:netrw_bookmarklist[iremove - 1].">",'~'.expand("<slnum>"))
                                call s:MergeBookmarks()
                            "    call Decho("remove g:netrw_bookmarklist[".(iremove-1)."]<".g:netrw_bookmarklist[(iremove-1)].">",'~'.expand("<slnum>"))
                                NetrwKeepj call remove(g:netrw_bookmarklist,iremove-1)
                                echo "removed ".dremove." from g:netrw_bookmarklist"
                            "    call Decho("g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                               endif
                            "   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist),'~'.expand("<slnum>"))
                              endif
   18   0.000172   0.000101   call s:NetrwBookmarkMenu()
   18   0.000157   0.000092   call s:NetrwTgtMenu()
   18              0.000054   let @@= ykeep
                            "  call Dret("s:NetrwBookHistHandler")

FUNCTION  airline#highlighter#exec()
Called 4211 times
Total time:   0.817847
 Self time:   0.222333

count  total (s)   self (s)
 4211              0.005974   if pumvisible()
                                return
                              endif
 4211              0.004925   let colors = a:colors
 4211              0.003835   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 4211   0.471434   0.018091   let old_hi = airline#highlighter#get_highlight(a:group)
 4211              0.007484   if len(colors) == 4
  964              0.002018     call add(colors, '')
  964              0.000524   endif
 4211              0.005314   if g:airline_gui_mode ==# 'gui'
 4211              0.015467     let new_hi = [colors[0], colors[1], '', '', colors[4]]
 4211              0.002379   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
 4211   0.099499   0.015958   let colors = s:CheckDefined(colors)
 4211   0.068376   0.018197   if old_hi != new_hi || !s:hl_group_exists(a:group)
  218   0.013940   0.005489     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  218              0.002750     exe cmd
  218              0.000687     if has_key(s:hl_groups, a:group)
  218              0.000463       let s:hl_groups[a:group] = colors
  218              0.000131     endif
  218              0.000102   endif

FUNCTION  gitgutter#diff#process_removed()
Called 4 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000005   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
    4              0.000012     call add(a:modifications, [a:to_line, 'removed'])
    4              0.000003   endif

FUNCTION  <SNR>214_NetrwTgtMenu()
Called 18 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   18              0.000042   if !exists("s:netrw_menucnt")
   18              0.000011    return
                              endif
                            "  call Dfunc("s:NetrwTgtMenu()")
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " try to cull duplicate entries
                               let tgtdict={}
                            
                               " target bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                            "    call Decho("installing bookmarks as easy targets",'~'.expand("<slnum>"))
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 if has_key(tgtdict,bmd)
                                  let cnt= cnt + 1
                                  continue
                                 endif
                                 let tgtdict[bmd]= cnt
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                                 " show bookmarks for goto menu
                            "     call Decho("menu: Targets: ".bmd,'~'.expand("<slnum>"))
                                 exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
                                 let cnt= cnt + 1
                                endfor
                               endif
                            
                               " target directory browsing history
                               if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
                            "    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")",'~'.expand("<slnum>"))
                                let histcnt = 1
                                while histcnt <= g:netrw_dirhistmax
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{histcnt}")
                                  let histentry  = g:netrw_dirhist_{histcnt}
                                  if has_key(tgtdict,histentry)
                                   let histcnt = histcnt + 1
                                   continue
                                  endif
                                  let tgtdict[histentry] = histcnt
                                  let ehistentry         = escape(histentry,g:netrw_menu_escape)
                            "      call Decho("menu: Targets: ".histentry,'~'.expand("<slnum>"))
                                  exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
                                 endif
                                 let histcnt = histcnt + 1
                                endwhile
                               endif
                              endif
                            "  call Dret("s:NetrwTgtMenu")

FUNCTION  <SNR>25_LoadIndent()
Called 62 times
Total time:   0.045010
 Self time:   0.044570

count  total (s)   self (s)
   62              0.000202     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
   62              0.000188     let s = expand("<amatch>")
   62              0.000102     if s != ""
   62              0.000119       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
  124              0.000413       for name in split(s, '\.')
   62   0.043258   0.042818 	exe 'runtime! indent/' . name . '.vim'
   62              0.000069       endfor
   62              0.000044     endif

FUNCTION  ale#util#InSandbox()
Called 692 times
Total time:   0.010171
 Self time:   0.010171

count  total (s)   self (s)
  692              0.000908     try
  692              0.002289         function! s:SandboxCheck() abort
                                    endfunction
  692              0.001310     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  692              0.000792     return 0

FUNCTION  <SNR>182_state_filter()
Called 62 times
Total time:   0.002259
 Self time:   0.002259

count  total (s)   self (s)
                              " Various changes to the output of :mksession.
   62              0.000237   if a:line =~ '^normal!\? zo$'
                                " Silence "E490: No fold found" errors.
                                return 'silent! ' . a:line
                              elseif a:line =~ '^file .\{-}\<NERD_tree_\d\+$'
                                " Silence "E95: Buffer with this name already exists" when restoring
                                " mirrored NERDTree windows.
                                return '" ' . a:line
                              elseif a:line =~ '^file .\{-}\[BufExplorer\]$'
                                " Same trick (about the E95) for BufExplorer.
                                return '" ' . a:line
                              elseif a:line =~ '^file .\{-}__Tag_List__$'
                                " Same trick (about the E95) for TagList.
                                return '" ' . a:line
                              elseif a:line =~ "^\\s*silent exe 'bwipe ' \\. s:wipebuf$" || a:line =~ '^unlet! s:wipebuf$'
                                " Disable Vim's special handling of the initial, empty buffer because it
                                " breaks restoring of special windows with content generated by a Vim
                                " plug-in. The :mksession command doesn't have this problem because it
                                " simply doesn't support buffers with generated contents...
    2              0.000004     return '" ' . a:line
                              else
   60              0.000067     return a:line
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 468 times
Total time:   0.066586
 Self time:   0.051802

count  total (s)   self (s)
  468              0.001606   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  468              0.002672   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
  468              0.001455   if !exists('b:airline_whitespace_check')
   11              0.000384     let b:airline_whitespace_check = ''
   11              0.000160     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
   11              0.000011     let trailing = 0
   11              0.000045     if index(checks, 'trailing') > -1
   11              0.000009       try
   11              0.000033         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
   11              0.005176         let trailing = search(regexp, 'nw')
   11              0.000011       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
   11              0.000004     endif
                            
   11              0.000012     let mixed = 0
   11              0.000011     let check = 'indent'
   11              0.000098     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
   11   0.006809   0.000083       let mixed = s:check_mixed_indent()
   11              0.000011     endif
                            
   11              0.000021     let mixed_file = ''
   11              0.000012     let check = 'mixed-indent-file'
   11              0.000091     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
   11   0.001568   0.000197       let mixed_file = s:check_mixed_indent_file()
   11              0.000007     endif
                            
   11              0.000016     let long = 0
   11              0.000029     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
   11              0.000032     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    1              0.000002       let b:airline_whitespace_check = s:symbol
    1              0.000002       if strlen(s:symbol) > 0
    1              0.000002         let space = (g:airline_symbols.space)
    1              0.000000       else
                                    let space = ''
                                  endif
                            
    1              0.000001       if s:show_message
    1              0.000001         if trailing != 0
    1              0.000004           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000006           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000001         endif
    1              0.000001         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    1              0.000001         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    1              0.000002         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
    1              0.000001       endif
    1              0.000000     endif
   11              0.000007   endif
  468   0.009514   0.002827   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>175_L2U_SetupGlobal()
Called 95 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
                            
                              " Initialization of global and script-local variables
                              " is only performed once
   95              0.000327   if get(g:, "l2u_did_global_setup", 0)
   95              0.000091     return
                              endif
                            
                              let g:l2u_did_global_setup = 1
                            
                              let g:l2u_symbols_dict = julia_latex_symbols#get_dict()
                            
                              call s:L2U_deprecated_options()
                            
                              if v:version < 704
                                  let g:latex_to_unicode_tab = 0
                                  let g:latex_to_unicode_auto = 0
                              endif
                            
                              " YouCompleteMe and neocomplcache/neocomplete/deoplete plug-ins do not work well
                              " with LaTeX symbols suggestions
                              if exists("g:loaded_youcompleteme") || exists("g:loaded_neocomplcache") || exists("g:loaded_neocomplete") || exists("g:loaded_deoplete")
                                let g:latex_to_unicode_suggestions = 0
                              endif
                            
                              " A hack to forcibly get out of completion mode: feed
                              " this string with feedkeys()
                              if has("win32") || has("win64")
                                if has("gui_running")
                                  let s:l2u_esc_sequence = "\u0006"
                                else
                                  let s:l2u_esc_sequence = "\u0006\b"
                                endif
                              else
                                let s:l2u_esc_sequence = "\u0091\b"
                              end
                            
                              " Trigger for the previous mapping of <Tab>
                              let s:l2u_fallback_trigger = "\u0091L2UFallbackTab"
                            

FUNCTION  <SNR>207_FindItemAtCursor()
Called 514 times
Total time:   0.025371
 Self time:   0.018329

count  total (s)   self (s)
  514              0.001591     let l:buf = bufnr('')
  514              0.002795     let l:info = get(g:ale_buffer_info, l:buf, {})
  514              0.002321     let l:loclist = get(l:info, 'loclist', [])
  514              0.001886     let l:pos = getcurpos()
  514   0.011996   0.004954     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
  514              0.001836     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  514              0.001267     return [l:info, l:loc]

FUNCTION  <SNR>182_check_special_tabpage()
Called 1 time
Total time:   0.000129
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000002   let status = 0
    1              0.000004   let winrestcmd = winrestcmd()
    1              0.000002   let window = winnr()
    1   0.000101   0.000017   windo let status += s:check_special_window(a:session)
    1              0.000008   execute window . 'wincmd w'
    1              0.000007   silent! execute winrestcmd
    1              0.000002   if status > 0 && winnr('$') > 1
                                call add(a:session, winrestcmd)
                              endif

FUNCTION  <SNR>124_disableescape()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000004   if exists("b:ragtag_escape_mode")
                                if b:ragtag_escape_mode == "xml"
                                  silent! iunmap <buffer> <BS>
                                  silent! iunmap <buffer> <Lt>
                                  silent! iunmap <buffer> >
                                  silent! iunmap <buffer> &
                                  silent! iunmap <buffer> "
                                elseif b:ragtag_escape_mode == "url"
                                  silent! iunmap <buffer> <BS>
                                  silent! iunmap <buffer> <Tab>
                                  silent! iunmap <buffer> <CR>
                                  silent! iunmap <buffer> <Space>
                                  silent! iunmap <buffer> <Bar>
                                  let i = 33
                                  while i < 127
                                    if nr2char(i) =~# '[|A-Za-z0-9_.~-]'
                                    else
                                      exe "silent! iunmap <buffer> ".nr2char(i)
                                    endif
                                    let i = i + 1
                                  endwhile
                                endif
                                unlet b:ragtag_escape_mode
                              endif

FUNCTION  YRRecord3()
Called 4 times
Total time:   0.006289
 Self time:   0.003264

count  total (s)   self (s)
    4              0.000012     let register = '"'
                            
    4              0.000008     if a:0 > 0 && a:1 != '' 
                                    let register = a:1
                                else
                                    " v:register can be blank in some (unknown) cases
                                    " if v:register == '' || v:register == '_'
    4              0.000008         if v:register == '_'
                                        " Black hole register, ignore recording the operation
                                        return ""
                                    endif
                            
    4   0.000140   0.000045         let register = s:YRRegister()
                            
    4              0.000012         if &clipboard =~ '\<unnamed\>' && register == '*'
                                        " unnamed  A variant of "unnamed" flag which uses the clipboard
                                        "          register '*' (|quote|) for all operations except yank.
                                        "          Yank shall copy the text into register '*' when "unnamed"
                                        "          is included.
                                        "
                                        let register = '*'
                            
                                        " The + and * registers are not modified by yank operations.
                                        " We do not know what operation triggered this event so do a
                                        " simple check if the register values have changed.
                                        " If not, check it against the " register.  Use which ever
                                        " one has changed.
                                        if s:yr_prev_clipboard_star == '' || getreg(register) == s:yr_prev_clipboard_star
                                            if getreg('"') != getreg(register)
                                                let register = '"'
                                            endif
                                        endif
                                    endif
                            
    4              0.000014         if has('unnamedplus') && &clipboard =~ '\<unnamedplus\>' && register == '+'
                                        " unnamedplus    A variant of "unnamed" flag which uses the clipboard
                                        "         register '+' (|quoteplus|) instead of register '*' for all
                                        "         operations except yank.  Yank shall copy the text into
                                        "         register '+' and also into '*' when "unnamed" is included.
                                        "
                                        let register = '+'
                            
                                        " The + and * registers are not modified by yank operations.
                                        " We do not know what operation triggered this event so do a
                                        " simple check if the register values have changed.
                                        " If not, check it against the " register.  Use which ever
                                        " one has changed.
                                        if s:yr_prev_clipboard_plus == '' || getreg(register) == s:yr_prev_clipboard_plus
                                            if getreg('"') != getreg(register)
                                                let register = '"'
                                            endif
                                        endif
                                    endif
    4              0.000002     endif
                            
    4              0.000005     if register == '"'
                                    " If the change has occurred via an omap, we must delay
                                    " the capture of the default register until this event
                                    " since register updates are not reflected until the
                                    " omap function completes
    4              0.000015         let s:yr_prev_reg_unnamed = getreg('"')
    4              0.000009         let s:yr_prev_reg_small   = getreg('-')
    4              0.000003     endif
                            
    4              0.000007     if s:yr_remove_omap_dot == 1
    4   0.000930   0.000040         call s:YRMapsCreate('add_only_zap_keys')
    4              0.000002     endif
                            
                                " Add item to list
                                " This will also account for duplicates.
    4   0.002019   0.000046     call s:YRMRUAdd( 's:yr_history_list' , getreg(register) , getregtype(register) )
                            
    4              0.000007     if g:yankring_clipboard_monitor == 1
    4              0.002335         let s:yr_prev_clipboard_plus = getreg('+')
    4              0.000407         let s:yr_prev_clipboard_star = getreg('*')
    4              0.000005     endif
                            
                                " Manage the numbered registers
    4              0.000009     if g:yankring_manage_numbered_reg == 1
                                    " Allow the user to define an autocmd to dynamically
                                    " setup their connection information.
                                    silent! doautocmd User YRSetNumberedReg
                                endif
                            
                                " If the yankring window is open, refresh it
    4   0.000131   0.000064     call s:YRWindowUpdate()
                            
                                " Reset the past paste entry to the top of the ring.
                                " When the user hits replace last entry it should
                                " start from the top (not from the last previous
                                " replace) after capturing a new value in the YankRing.
    4              0.000008     let s:yr_last_paste_idx = 1
                            
    4              0.000004     return ""

FUNCTION  <SNR>45_repo_bare()
Called 12 times
Total time:   0.000224
 Self time:   0.000180

count  total (s)   self (s)
   12   0.000206   0.000162   if self.dir() =~# '/\.git$'
   12              0.000009     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  ale#CallWithCooldown()
Called 661 times
Total time:   0.327530
 Self time:   0.029756

count  total (s)   self (s)
  661   0.014707   0.006292     let l:now = ale#util#ClockMilliseconds()
                            
  661              0.004676     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
                                    return 0
                                endif
                            
  661              0.004553     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
                            
  661   0.253737   0.060362     let l:return_value = call(a:func, a:arglist)
                            
  661              0.002402     let s:timestamp_map[a:timestamp_key] = -1
                            
  661              0.001077     return l:return_value

FUNCTION  <SNR>87_update_search_status()
Called 491 times
Total time:   0.128949
 Self time:   0.024275

count  total (s)   self (s)
  491              0.003686   if mode() !=# 'n'
    1              0.000003     return
                              endif
                            
  490              0.003216   let curs_hold = get(g:, 'anzu_enable_CursorHold_AnzuUpdateSearchStatus', 0)
  490              0.001717   let curs_mov  = get(g:, 'anzu_enable_CursorMoved_AnzuUpdateSearchStatus', 0)
                            
  490              0.001291   let anzu_echo_output = (curs_hold == 1 || curs_mov == 1)
                            
  490              0.000650   if curs_hold || curs_mov
  490   0.113031   0.008357     if anzu#update(@/,  anzu#get_on_pattern_pos(@/), s:wrapscan_mes()) != -1   && anzu_echo_output
                                  call feedkeys("\<Plug>(anzu-echohl_search_status)")
                                endif
  490              0.000311   endif

FUNCTION  <SNR>214_NetrwEnew()
Called 5 times
Total time:   0.108544
 Self time:   0.002172

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
    5              0.000023   if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
    5              0.000020   if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
    5              0.000012   if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
    5              0.000020   if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
    5              0.000017   if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
    5              0.000015   if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
    5              0.000014   if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
    5              0.000014   if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
    5              0.000016   if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
    5              0.000014   if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
    5              0.000012   if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
    5              0.000012   if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
    5              0.000018   if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
    5              0.000012   if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
    5              0.000012   if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
    5              0.000017   if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
    5   0.054029   0.000059   NetrwKeepj call s:NetrwOptionRestore("w:")
                            "  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
                              " when tree listing uses file TreeListing... a new buffer is made.
                              " Want the old buffer to be unlisted.
                              " COMBAK: this causes a problem, see P43
                            "  setl nobl
    5              0.000011   let netrw_keepdiff= &l:diff
    5   0.045199   0.000811   noswapfile NetrwKeepj keepalt enew!
    5              0.000027   let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
    5   0.002273   0.000052   NetrwKeepj call s:NetrwOptionSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
    5              0.000025   if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
    5              0.000020   if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
    5              0.000016   if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
    5              0.000020   if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
    5              0.000017   if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
    5              0.000015   if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
    5              0.000016   if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
    5              0.000015   if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
    5              0.000016   if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
    5              0.000015   if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
    5              0.000014   if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
    5              0.000015   if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
    5              0.000019   if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
    5              0.000014   if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
    5              0.000016   if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
    5              0.000016   if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
    5              0.000007   if a:0 > 0
    4              0.000008    let b:netrw_curdir= a:1
    4              0.000055    if b:netrw_curdir =~ '/$'
    3              0.000013     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 setl nobl
                                 file NetrwTreeListing
                                 setl nobl bt=nowrite bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
    3   0.006278   0.000485      exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    3              0.000001     endif
    3              0.000001    endif
    4              0.000002   endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))

FUNCTION  airline#extensions#append_to_section()
Called 28 times
Total time:   0.000616
 Self time:   0.000285

count  total (s)   self (s)
   28   0.000469   0.000138   call <sid>check_defined_section(a:name)
   28              0.000140   let w:airline_section_{a:name} .= a:value

FUNCTION  ale#engine#Cleanup()
Called 14 times
Total time:   0.013765
 Self time:   0.000531

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
   14              0.000113     if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
   14              0.000123     if !has_key(g:ale_buffer_info, a:buffer)
    5              0.000003         return
                                endif
                            
    9   0.013289   0.000055     call ale#engine#RunLinters(a:buffer, [], 1)
                            
    9              0.000171     call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>117_YRMapsCreate()
Called 5 times
Total time:   0.001152
 Self time:   0.001152

count  total (s)   self (s)
                                " 7.1.patch205 introduces the v:operator function which was
                                " essential to gain the omap support.
    5              0.000008     if s:yr_has_voperator == 1
    5              0.000010         let s:yr_remove_omap_dot   = 1
   35              0.000150         for key in split(g:yankring_zap_keys)
   30              0.000022             try
   30              0.000032                 if key != '@'
   30              0.000758                     exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. key. '", 1)'
   30              0.000023                 endif
   30              0.000017             catch
                                        endtry
   30              0.000016         endfor
    5              0.000002     endif
                            
    5              0.000010     let s:yr_maps_created_zap = 1
                            
    5              0.000004     if a:0 > 0
                                    " We have only removed the _zap_ keys temporarily
                                    " so abandon further changes.
    5              0.000004         return
                                endif
                            
                                " 7.1.patch205 introduces the v:operator function which was essential
                                " to gain the omap support.
                                if s:yr_has_voperator == 1
                                    let s:yr_remove_omap_dot   = 1
                                    " Set option to add and remove _zap_ keys when
                                    " repeating commands
                                    let o_maps = split(g:yankring_o_keys)
                                    " Loop through and prompt the user for all buffer connection parameters.
                                    for key in o_maps
                                        exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. escape(key,'\"'). '")'
                                    endfor
                                endif
                            
                                " Iterate through a space separated list of mappings and create
                                " calls to the YRYankCount function
                                let n_maps = split(g:yankring_n_keys)
                                " Loop through and prompt the user for all buffer connection parameters.
                                for key in n_maps
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " Andy Wokula's suggestion
                                    exec 'nmap' key key."<SID>yrrecord"
                                endfor
                            
                                if g:yankring_map_dot == 1
                                    if s:yr_has_voperator == 1
                                        nmap <expr> . YRMapsExpression("<SID>", ".")
                                    else
                                        nnoremap <silent> . :<C-U>YRYankCount '.'<CR>
                                    endif
                                endif
                            
                                if g:yankring_v_key != ''
                                    exec 'xnoremap <silent>'.g:yankring_v_key." :YRYankRange 'v'<CR>"
                                endif
                                if g:yankring_del_v_key != ''
                                    for v_map in split(g:yankring_del_v_key)
                                        if strlen(v_map) > 0
                                            try
                                                exec 'xnoremap <silent>'.v_map." :YRDeleteRange 'v'<CR>"
                                            catch
                                            endtry
                                        endif
                                    endfor
                                endif
                                if g:yankring_paste_n_bkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'P'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'gP'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_n_akey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_akey." :<C-U>YRPaste 'p'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_akey." :<C-U>YRPaste 'gp'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_v_bkey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_bkey." :<C-U>YRPaste 'P', 'v'<CR>"
                                endif
                                if g:yankring_paste_v_akey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_akey." :<C-U>YRPaste 'p', 'v'<CR>"
                                endif
                                if g:yankring_replace_n_pkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_pkey." :<C-U>YRReplace '-1', 'P'<CR>"
                                endif
                                if g:yankring_replace_n_nkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_nkey." :<C-U>YRReplace '1', 'p'<CR>"
                                endif
                            
                                let g:yankring_enabled    = 1
                                let s:yr_maps_created     = 1
                            
                                if exists('*YRRunAfterMaps')
                                    " This will allow you to override the default maps if necessary
                                    call YRRunAfterMaps()
                                endif

FUNCTION  <SNR>211_pos_less_equal()
Called 1470 times
Total time:   0.007491
 Self time:   0.007491

count  total (s)   self (s)
 1470              0.006603 	return a:a[0] == a:b[0] ? a:a[1] <= a:b[1] : a:a[0] <= a:b[0]

FUNCTION  <SNR>43_IncludeMarks()
Called 966 times
Total time:   0.033399
 Self time:   0.033399

count  total (s)   self (s)
  966              0.006293 	if exists('b:showmarks_include') && exists('b:showmarks_previous_include') && b:showmarks_include != b:showmarks_previous_include
                            		" The user changed the marks to include; hide all marks; change the
                            		" included mark list, then show all marks.  Prevent infinite
                            		" recursion during this switch.
                            		if exists('s:use_previous_include')
                            			" Recursive call from ShowMarksHideAll()
                            			return b:showmarks_previous_include
                            		elseif exists('s:use_new_include')
                            			" Recursive call from ShowMarks()
                            			return b:showmarks_include
                            		else
                            			let s:use_previous_include = 1
                            			call <sid>ShowMarksHideAll()
                            			unlet s:use_previous_include
                            			let s:use_new_include = 1
                            			call <sid>ShowMarks()
                            			unlet s:use_new_include
                            		endif
                            	endif
                            
  966              0.002294 	if !exists('g:showmarks_include')
                            		let g:showmarks_include = s:all_marks
                            	endif
  966              0.002097 	if !exists('b:showmarks_include')
    4              0.000021 		let b:showmarks_include = g:showmarks_include
    4              0.000004 	endif
                            
                            	" Save this include setting so we can detect if it was changed.
  966              0.002113 	let b:showmarks_previous_include = b:showmarks_include
                            
  966              0.001229 	return b:showmarks_include

FUNCTION  ale#util#StartPartialTimer()
Called 33 times
Total time:   0.000556
 Self time:   0.000556

count  total (s)   self (s)
   33              0.000264     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
   33              0.000194     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
   33              0.000044     return l:timer_id

FUNCTION  anzu#update()
Called 490 times
Total time:   0.050892
 Self time:   0.013144

count  total (s)   self (s)
  490              0.001001 	let pattern = a:pattern
  490              0.000790 	let cursor = a:cursor_pos
  490              0.000774 	if pattern == ""
                            		return
                            	endif
                            
  490   0.021796   0.002816 	let pos_all = s:searchpos(pattern)
                            	
  490              0.000906 	if empty(pos_all)
  432   0.022405   0.003637 		let s:status_cache = s:print_status(g:anzu_no_match_word, pattern, "", "", "")
  432              0.000389 		return -1
                            	endif
                            
   58              0.000328 	let index = index(pos_all, [cursor[1], cursor[2]])
   58              0.000068 	if index == -1
   58              0.000048 		return -1
                            	endif
                            
                            	let wrap_mes = get(a:, 1, "")
                            
                            	let pattern = substitute(pattern, '\\', '\\\\', 'g')
                            	let s:status_cache = s:print_status(g:anzu_status_format, pattern, index+1, len(pos_all), wrap_mes)

FUNCTION  airline#builder#new()
Called 82 times
Total time:   0.001784
 Self time:   0.001784

count  total (s)   self (s)
   82              0.000511   let builder = copy(s:prototype)
   82              0.000160   let builder._context = a:context
   82              0.000115   let builder._sections = []
                            
   82              0.000787   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   82              0.000073   return builder

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 36 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
   36              0.000253   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  indent_guides#init_matches()
Called 109 times
Total time:   0.000992
 Self time:   0.000992

count  total (s)   self (s)
  109              0.000769   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  <SNR>78_Detect()
Called 90 times
Total time:   0.024237
 Self time:   0.002934

count  total (s)   self (s)
   90              0.000214   if !exists('b:bundler_lock')
   90   0.021828   0.000525     let lock = s:FindBundlerLock(a:path)
   90              0.000173     if !empty(lock)
                                  let b:bundler_lock = lock
                                  unlet! b:bundler_gem
                                elseif !empty(getbufvar('#', 'bundler_lock'))
                                  let lock = getbufvar('#', 'bundler_lock')
                                  for [gem, path] in items(s:project(lock).paths())
                                    if strpart(a:path, 0, len(path)) ==# path
                                      let b:bundler_lock = lock
                                      let b:bundler_gem = gem
                                      break
                                    endif
                                  endfor
                                endif
   90              0.000057   endif
   90              0.000187   return exists('b:bundler_lock')

FUNCTION  <SNR>45_buffer_commit()
Called 61 times
Total time:   0.002568
 Self time:   0.000611

count  total (s)   self (s)
   61   0.002532   0.000575   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>159_update_hg_branch()
Called 647 times
Total time:   0.022594
 Self time:   0.022594

count  total (s)   self (s)
                              " path argument is not actually used, so we don't actually care about a:1
                              " it is just needed, because update_git_branch needs it.
  647              0.000931   if s:has_lawrencium
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  647              0.001624     let s:vcs_config['mercurial'].branch = ''
  647              0.000399   endif

FUNCTION  airline#async#vim_vcs_untracked()
Called 60 times
Total time:   0.022375
 Self time:   0.022375

count  total (s)   self (s)
   60              0.000100     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
   60              0.000446       let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
   60              0.000034     endif
                            
   60              0.000236     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
   60              0.000178     if has_key(s:untracked_jobs, a:file)
   48              0.000364       if job_status(get(s:untracked_jobs, a:file)) == 'run'
   40              0.000035         return
                                  elseif has_key(s:untracked_jobs, a:file)
    8              0.000024         call remove(s:untracked_jobs, a:file)
    8              0.000006       endif
    8              0.000005     endif
   20              0.020003     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
   20              0.000316     let s:untracked_jobs[a:file] = id

FUNCTION  <SNR>161_check_mixed_indent_file()
Called 11 times
Total time:   0.001371
 Self time:   0.001371

count  total (s)   self (s)
   11              0.000136   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   11              0.000127   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
   11              0.000016     let head_spc = '\v(^ +)'
   11              0.000010   endif
   11              0.000279   let indent_tabs = search('\v(^\t+)', 'nw')
   11              0.000706   let indent_spc  = search(head_spc, 'nw')
   11              0.000015   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
   11              0.000007     return ''
                              endif

FUNCTION  ale#statusline#Update()
Called 28 times
Total time:   0.002064
 Self time:   0.001858

count  total (s)   self (s)
   28              0.000139     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
   28              0.000342     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
   28   0.000367   0.000161     let l:count = s:CreateCountDict()
   28              0.000080     let l:count.total = len(l:loclist)
                            
   28              0.000040     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
                                        let l:count.error += 1
                                    endif
                                endfor
                            
                                " Set keys for backwards compatibility.
   28              0.000084     let l:count[0] = l:count.error + l:count.style_error
   28              0.000069     let l:count[1] = l:count.total - l:count[0]
                            
   28              0.000287     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  <SNR>117_YRInsertLeave()
Called 1 time
Total time:   0.001113
 Self time:   0.000046

count  total (s)   self (s)
                                " The YankRing uses omaps to execute the prescribed motion
                                " and then appends to the motion a call to a YankRing
                                " function to record the contents of the changed register.
                                "
                                " We cannot append a function call to the end of a motion
                                " that results in Insert mode.  For example, any command
                                " like 'cw' enters insert mode.  Appending a function call
                                " after the w, simply writes out the call as if the user
                                " typed it.
                                "
                                " Using the InsertLeave event, allows us to capture the
                                " contents of any changed register after it completes.
                            
    1   0.000831   0.000026     call YRRecord(s:YRRegister())
                            
                                " When performing a change (not a yank or delete)
                                " it is not possible to call <SID>yrrecord at the end
                                " of the command (or it's contents will be inserted
                                " into the buffer instead of executed).
                                " So, when using ".", we have to remove the _zap_
                                " keys and then re-add them back again after we
                                " record the updates.
    1              0.000002     if s:yr_remove_omap_dot == 1
    1   0.000269   0.000007         call s:YRMapsCreate('add_only_zap_keys')
    1              0.000001     endif
                            

FUNCTION  <SNR>214_ShowLink()
Called 9 times
Total time:   0.003133
 Self time:   0.001439

count  total (s)   self (s)
                            " "  call Dfunc("s:ShowLink()")
                            " "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">",'~'.expand("<slnum>"))
                            " "  call Decho(printf("line#%4d: %s",line("."),getline(".")),'~'.expand("<slnum>"))
    9              0.000025   if exists("b:netrw_curdir")
    9              0.000482    norm! $?\a
    9   0.001792   0.000098    let fname   = b:netrw_curdir.'/'.s:NetrwGetWord()
    9              0.000337    let resname = resolve(fname)
                            " "   call Decho("fname         <".fname.">",'~'.expand("<slnum>"))
                            " "   call Decho("resname       <".resname.">",'~'.expand("<slnum>"))
                            " "   call Decho("b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
    9              0.000219    if resname =~ '^\M'.b:netrw_curdir.'/'
                                let dirlen  = strlen(b:netrw_curdir)
                                let resname = strpart(resname,dirlen+1)
                            " "    call Decho("resname<".resname.">  (b:netrw_curdir elided)",'~'.expand("<slnum>"))
                               endif
    9              0.000031    let modline = getline(".")."\t --> ".resname
                            " "   call Decho("fname  <".fname.">",'~'.expand("<slnum>"))
                            " "   call Decho("modline<".modline.">",'~'.expand("<slnum>"))
    9              0.000059    setl noro ma
    9              0.000039    call setline(".",modline)
    9              0.000057    setl ro noma nomod
    9              0.000003   endif
                            " "  call Dret("s:ShowLink".((exists("fname")? ' : '.fname : 'n/a')))

FUNCTION  airline#parts#spell()
Called 554 times
Total time:   0.013322
 Self time:   0.013322

count  total (s)   self (s)
  554              0.006014   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  554              0.000876   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  554              0.000472   return ''

FUNCTION  ale#Lint()
Called 26 times
Total time:   0.058504
 Self time:   0.001230

count  total (s)   self (s)
   26              0.000164     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
   17              0.000035         let l:buffer = a:2
   17              0.000021     elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
    9              0.000058         let l:buffer = s:queued_buffer_number
    9              0.000022     else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
   26   0.057794   0.000520     return ale#CallWithCooldown(   'dont_lint_until',   function('s:ALELintImpl'),   [l:buffer],)

FUNCTION  ale#linter#GetAll()
Called 140 times
Total time:   0.006495
 Self time:   0.006495

count  total (s)   self (s)
  140              0.000256     let l:combined_linters = []
                            
  280              0.000395     for l:filetype in a:filetypes
                                    " Load linter defintions from files if we haven't loaded them yet.
  140              0.000375         if !has_key(s:linters, l:filetype)
    1              0.001238             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        " Always set an empty List for the loaded linters if we don't find
                                        " any. This will prevent us from executing the runtime command
                                        " many times, redundantly.
    1              0.000003             if !has_key(s:linters, l:filetype)
    1              0.000003                 let s:linters[l:filetype] = []
    1              0.000001             endif
    1              0.000001         endif
                            
  140              0.000688         call extend(l:combined_linters, get(s:linters, l:filetype, []))
  140              0.000115     endfor
                            
  140              0.000183     return l:combined_linters

FUNCTION  <SNR>182_lock_session()
Called 1 time
Total time:   0.030117
 Self time:   0.000056

count  total (s)   self (s)
    1   0.000035   0.000003   if !xolox#session#locking_enabled()
                                return 1
                              endif
    1   0.000072   0.000006   let lock_file = s:lock_file_path(a:session_path)
    1   0.029992   0.000029   if xolox#misc#persist#save(lock_file, s:vim_instance_id())
    1              0.000008     if index(s:lock_files, lock_file) == -1
                                  call add(s:lock_files, lock_file)
                                endif
    1              0.000003     return 1
                              endif

FUNCTION  gitgutter#async#available()
Called 22 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
   22              0.000035   return s:available

FUNCTION  xolox#session#save_cmd()
Called 1 time
Total time:   0.067353
 Self time:   0.000569

count  total (s)   self (s)
    1   0.000020   0.000010   let starttime = xolox#misc#timer#start()
    1   0.000036   0.000013   let name = s:unescape(a:name)
    1              0.000003   if empty(name)
                                let name = xolox#session#find_current_session()
                              endif
    1              0.000002   if empty(name)
                                let name = g:session_default_name
                              endif
    1   0.000298   0.000009   let path = xolox#session#name_to_path(name)
    1              0.000008   let friendly_path = fnamemodify(path, ':~')
    1   0.001519   0.000018   if a:bang == '!' || !s:session_is_locked(name, a:command)
    1              0.000001     let lines = []
    1   0.005510   0.000018     call xolox#session#save_session(lines, friendly_path)
    1   0.000013   0.000005     if xolox#misc#os#is_win() && !xolox#session#options_include('unix')
                                  call map(lines, 'v:val . "\r"')
                                endif
    1              0.000306     if writefile(lines, path) != 0
                                  let msg = "session.vim %s: Failed to save %s session to %s!"
                                  call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), friendly_path)
                                else
    1   0.000022   0.000012       call s:last_session_persist(name)
    1   0.000015   0.000006       call s:flush_session()
    1   0.000134   0.000007       let label = xolox#session#get_label(name, !xolox#session#include_tabs())
    1   0.000026   0.000013       call xolox#misc#timer#stop("session.vim %s: Saved %s in %s.", g:xolox#session#version, label, starttime)
    1   0.029042   0.000063       call xolox#misc#msg#info("session.vim %s: Saved %s to %s.", g:xolox#session#version, label, friendly_path)
    1   0.000215   0.000009       if xolox#session#include_tabs()
    1              0.000002         let v:this_session = path
    1              0.000000       else
                                    let t:this_session = path
                                  endif
    1   0.030148   0.000031       call s:lock_session(path)
    1              0.000004     endif
    1              0.000001   endif

FUNCTION  <SNR>175_L2U_SetAutoSub()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001   if b:l2u_autosub_set
                                return
                              endif
                              " g:did_insert_enter is set from an autocommand in ftdetect
    1              0.000002   if a:wait_insert_enter && !get(g:, "did_insert_enter", 0)
                                return
                              endif
    1              0.000003   if !get(g:, "latex_to_unicode_auto", 0) || !b:l2u_enabled
    1              0.000001     return
                              endif
                              " Viable substitutions are searched at every character insertion via the
                              " autocmd InsertCharPre. The <Enter> key does not seem to be catched in
                              " this way though, so we use a mapping for that case.
                              imap <buffer> <CR> <Plug>L2UAutoSub
                              inoremap <buffer><expr> <Plug>L2UAutoSub LaTeXtoUnicode#AutoSub("\n", "\<CR>")
                            
                              augroup L2UAutoSub
                                autocmd! * <buffer>
                                autocmd InsertCharPre <buffer> call LaTeXtoUnicode#AutoSub()
                              augroup END
                            
                              let b:l2u_autosub_set = 1

FUNCTION  <SNR>60_savetofile()
Called 9 times
Total time:   0.009543
 Self time:   0.000082

count  total (s)   self (s)
    9   0.009541   0.000080 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>175_L2U_UnsetAutoSub()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   if !b:l2u_autosub_set
    1              0.000001     return
                              endif
                            
                              iunmap <buffer> <CR>
                              iunmap <buffer> <Plug>L2UAutoSub
                              augroup L2UAutoSub
                                autocmd! * <buffer>
                              augroup END
                              let b:l2u_autosub_set = 0

FUNCTION  <SNR>22_isAnsible()
Called 9 times
Total time:   0.000730
 Self time:   0.000730

count  total (s)   self (s)
    9              0.000101   let filepath = expand("%:p")
    9              0.000024   let filename = expand("%:t")
    9              0.000138   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    9              0.000102   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    9              0.000233   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    9              0.000017   let shebang = getline(1)
    9              0.000046   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    9              0.000038   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    9              0.000008   return 0

FUNCTION  <SNR>160_airline_ale_count()
Called 936 times
Total time:   0.001842
 Self time:   0.001842

count  total (s)   self (s)
  936              0.001501   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>214_NetrwTreeListing()
Called 18 times
Total time:   0.000748
 Self time:   0.000748

count  total (s)   self (s)
   18              0.000068   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
                            "   call Decho("curdir<".a:dirname.">",'~'.expand("<slnum>"))
                            "   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"),'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " update the treetop
                            "   call Decho("update the treetop",'~'.expand("<slnum>"))
                               if !exists("w:netrw_treetop")
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)",'~'.expand("<slnum>"))
                               elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)",'~'.expand("<slnum>"))
                               endif
                            
                               if !exists("w:netrw_treedict")
                                " insure that we have a treedict, albeit empty
                            "    call Decho("initializing w:netrw_treedict to empty",'~'.expand("<slnum>"))
                                let w:netrw_treedict= {}
                               endif
                            
                               " update the dictionary for the current directory
                            "   call Decho("updating: w:netrw_treedict[".a:dirname.'] -> [directory listing]','~'.expand("<slnum>"))
                            "   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d _'
                               let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
                            "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]),'~'.expand("<slnum>"))
                               exe "sil! NetrwKeepj ".w:netrw_bannercnt.",$d _"
                            
                               " if past banner, record word
                               if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
                                let fname= expand("<cword>")
                               else
                                let fname= ""
                               endif
                            "   call Decho("fname<".fname.">",'~'.expand("<slnum>"))
                            "   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")",'~'.expand("<slnum>"))
                            
                               " display from treetop on down
                               NetrwKeepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
                            "   call Decho("s:NetrwTreeDisplay) setl noma nomod ro",'~'.expand("<slnum>"))
                            
                               " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
                               while getline(1) =~ '^\s*$' && byte2line(1) > 0
                            "    call Decho("deleting blank line",'~'.expand("<slnum>"))
                                1d
                               endwhile
                            
                               exe "setl ".g:netrw_bufsettings
                            
                            "   call Dret("NetrwTreeListing : bufname<".expand("%").">")
                               return
                              endif

FUNCTION  ale#engine#SetResults()
Called 35 times
Total time:   0.043624
 Self time:   0.003975

count  total (s)   self (s)
   35   0.000532   0.000203     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   35              0.000051     if g:ale_set_signs
   35   0.020041   0.000243         call ale#sign#SetSigns(a:buffer, a:loclist)
   35              0.000020     endif
                            
   35              0.000070     if g:ale_set_quickfix || g:ale_set_loclist
   35   0.002647   0.000222         call ale#list#SetLists(a:buffer, a:loclist)
   35              0.000019     endif
                            
   35              0.000129     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
   26   0.001851   0.000166         call ale#statusline#Update(a:buffer, a:loclist)
   26              0.000016     endif
                            
   35              0.000043     if g:ale_set_highlights
   35   0.003644   0.000196         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   35              0.000021     endif
                            
   35              0.000044     if g:ale_echo_cursor
                                    " Try and echo the warning now.
                                    " This will only do something meaningful if we're in normal mode.
   35   0.008277   0.000248         call ale#cursor#EchoCursorWarning()
   35              0.000021     endif
                            
   35              0.000043     if l:linting_is_done
                                    " Reset the save event marker, used for opening windows, etc.
   35              0.000167         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
   35   0.001896   0.000236         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
   35   0.003593   0.001318         silent doautocmd <nomodeline> User ALELint
   35              0.000042     endif

FUNCTION  <SNR>161_ws_refresh()
Called 4 times
Total time:   0.000563
 Self time:   0.000563

count  total (s)   self (s)
    4              0.000013   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    1              0.000001     return
                              endif
    3              0.000503   unlet! b:airline_whitespace_check
    3              0.000016   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    3              0.000012   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>162_wordcount_update()
Called 503 times
Total time:   0.025091
 Self time:   0.025091

count  total (s)   self (s)
  503              0.001569   if empty(bufname(''))
   45              0.000067     return
                              endif
  458              0.011555   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>205_SetListsImpl()
Called 31 times
Total time:   0.012452
 Self time:   0.006800

count  total (s)   self (s)
   31              0.001333     let l:title = expand('#' . a:buffer . ':p')
                            
   31              0.000069     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
   31   0.000545   0.000244         let l:id = s:BufWinId(a:buffer)
                            
   31              0.000185         if has('nvim')
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                    else
   31   0.003315   0.001525             call setloclist(l:id, s:FixList(a:buffer, a:loclist))
   31              0.000209             call setloclist(l:id, [], 'r', {'title': l:title})
   31              0.000036         endif
   31              0.000016     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   31   0.001452   0.000229     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   31   0.000691   0.000329     if !ale#engine#IsCheckingBuffer(a:buffer)
   31   0.002141   0.000165         call s:CloseWindowIfNeeded(a:buffer)
   31              0.000023     endif

FUNCTION  xolox#misc#path#is_relative()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                              " Returns true (1) when the pathname given as the first argument is
                              " relative, false (0) otherwise.
    2              0.000018   if a:path =~ '^\w\+://'
                                return 0
                              elseif s:windows_compatible
                                return a:path !~ '^\(\w:\|[\\/]\)'
                              else
    2              0.000006     return a:path !~ '^/'
                              endif

FUNCTION  <SNR>159_check_in_path()
Called 14 times
Total time:   0.002385
 Self time:   0.002385

count  total (s)   self (s)
   14              0.000040   if !exists('b:airline_file_in_root')
   13              0.000056     let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
   13              0.000667     let bufferpath = resolve(fnamemodify(expand('%'), ':p'))
                            
   13              0.000098     if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
   13              0.000378       if match(root, '\.git$') >= 0
   13              0.000797         let root = expand(fnamemodify(root, ':h'))
   13              0.000015       else
                                    " else it's the newer format, and we need to guesstimate
                                    " 1) check for worktrees
                                    if match(root, 'worktrees') > -1
                                      " worktree can be anywhere, so simply assume true here
                                      return 1
                                    endif
                                    " 2) check for submodules
                                    let pattern = '\.git[\\/]\(modules\)[\\/]'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                  endif
   13              0.000008     endif
                            
   13              0.000054     let b:airline_file_in_root = stridx(bufferpath, root) > -1
   13              0.000007   endif
   14              0.000020   return b:airline_file_in_root

FUNCTION  <SNR>174_GetAliasedFiletype()
Called 140 times
Total time:   0.005866
 Self time:   0.005866

count  total (s)   self (s)
  140              0.000503     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List.
  140              0.000464     if type(l:buffer_aliases) is type([])
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
  560              0.001079     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
  420              0.001010         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
  420              0.000291     endfor
                            
  140              0.000172     return a:original_filetype

FUNCTION  gitgutter#utility#bufnr()
Called 280 times
Total time:   0.000715
 Self time:   0.000715

count  total (s)   self (s)
  280              0.000428   return s:bufnr

FUNCTION  ale#list#SetLists()
Called 35 times
Total time:   0.002425
 Self time:   0.000871

count  total (s)   self (s)
   35              0.000193     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    2   0.001008   0.000010         call s:SetListsImpl(-1, a:buffer, a:loclist)
    2              0.000002     else
   33   0.000913   0.000357         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   33              0.000028     endif

FUNCTION  <SNR>214_NetrwBrowseChgDir()
Called 17 times
Total time:   1.019594
 Self time:   0.016419

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            
   17              0.000044   let ykeep= @@
   17              0.000064   if !exists("b:netrw_curdir")
                               " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
                               " and the current window is the NetrwMessage window.
                               let @@= ykeep
                            "   call Decho("b:netrw_curdir doesn't exist!",'~'.expand("<slnum>"))
                            "   call Decho("getcwd<".getcwd().">",'~'.expand("<slnum>"))
                            "   call Dredir("ls!")
                            "   call Dret("s:NetrwBrowseChgDir")
                               return
                              endif
                            "  call Decho("b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " NetrwBrowseChgDir: save options and initialize {{{3
                            "  call Decho("saving options",'~'.expand("<slnum>"))
   17   0.000417   0.000139   call s:SavePosn(s:netrw_nbcd)
   17   0.009044   0.000179   NetrwKeepj call s:NetrwOptionSave("s:")
   17   0.244826   0.000215   NetrwKeepj call s:NetrwSafeOptions()
   17              0.000176   if (has("win32") || has("win95") || has("win64") || has("win16"))
                               let dirname = substitute(b:netrw_curdir,'\\','/','ge')
                              else
   17              0.000034    let dirname = b:netrw_curdir
   17              0.000024   endif
   17              0.000029   let newdir    = a:newdir
   17              0.000018   let dolockout = 0
   17              0.000016   let dorestore = 1
                            "  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
                            
                              " ignore <cr>s when done in the banner
                            "  call Decho('ignore [return]s when done in banner (g:netrw_banner='.g:netrw_banner.")",'~'.expand("<slnum>"))
   17              0.000019   if g:netrw_banner
                            "   call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"),'~'.expand("<slnum>"))
   17              0.000092    if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
                                if getline(".") =~# 'Quick Help'
                            "     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
                            "     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                 setl ma noro nowrap
                                 NetrwKeepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
                                 setl noma nomod nowrap
                                 call s:RestorePosn(s:netrw_nbcd)
                                 NetrwKeepj call s:NetrwOptionRestore("s:")
                            "     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                endif
                               endif
                            "  else " Decho
                            "   call Decho("(s:NetrwBrowseChgdir) g:netrw_banner=".g:netrw_banner." (no banner)",'~'.expand("<slnum>"))
   17              0.000012   endif
                            
                              " set up o/s-dependent directory recognition pattern
   17              0.000036   if has("amiga")
                               let dirpat= '[\/:]$'
                              else
   17              0.000019    let dirpat= '[\/]$'
   17              0.000011   endif
                            "  call Decho("set up o/s-dependent directory recognition pattern: dirname<".dirname.">  dirpat<".dirpat.">",'~'.expand("<slnum>"))
                            
   17              0.000376   if dirname !~ dirpat
                               " apparently vim is "recognizing" that it is in a directory and
                               " is removing the trailing "/".  Bad idea, so let's put it back.
   17              0.000035    let dirname= dirname.'/'
                            "   call Decho("adjusting dirname<".dirname.'>  (put trailing "/" back)','~'.expand("<slnum>"))
   17              0.000008   endif
                            
                            "  call Decho("[newdir<".newdir."> ".((newdir =~ dirpat)? "=~" : "!~")." dirpat<".dirpat.">] && [islocal=".a:islocal."] && [newdir is ".(isdirectory(s:NetrwFile(newdir))? "" : "not ")."a directory]",'~'.expand("<slnum>"))
   17   0.001077   0.000288   if newdir !~ dirpat && !(a:islocal && isdirectory(s:NetrwFile(s:ComposePath(dirname,newdir))))
                               " ------------------------------
                               " NetrwBrowseChgDir: edit a file {{{3
                               " ------------------------------
                            "   call Decho('edit-a-file: case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">",'~'.expand("<slnum>"))
                            
                               " save position for benefit of Rexplore
    7              0.000074    let s:rexposn_{bufnr("%")}= winsaveview()
                            "   call Decho("edit-a-file: saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            "   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">",'~'.expand("<slnum>"))
                            
    7              0.000028    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: newdir<".newdir.">",'~'.expand("<slnum>"))
                                let dirname= s:NetrwTreeDir(a:islocal)
                                if dirname =~ '/$'
                                 let dirname= dirname.newdir
                                else
                                 let dirname= dirname."/".newdir
                                endif
                            "    call Decho("edit-a-file: dirname<".dirname.">",'~'.expand("<slnum>"))
                            "    call Decho("edit-a-file: tree listing",'~'.expand("<slnum>"))
                               elseif newdir =~ '^\(/\|\a:\)'
                            "    call Decho("edit-a-file: handle an url or path starting with /: <".newdir.">",'~'.expand("<slnum>"))
                                let dirname= newdir
                               else
    7   0.000510   0.000034     let dirname= s:ComposePath(dirname,newdir)
    7              0.000005    endif
                            "   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")",'~'.expand("<slnum>"))
                               " this lets netrw#BrowseX avoid the edit
    7              0.000007    if a:0 < 1
                            "    call Decho("edit-a-file: (a:0=".a:0."<1) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"),'~'.expand("<slnum>"))
    7   0.013102   0.000068     NetrwKeepj call s:NetrwOptionRestore("s:")
    7              0.000012     let curdir= b:netrw_curdir
    7              0.000013     if !exists("s:didsplit")
                            "     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".string(g:netrw_browse_split)." win#".winnr(),'~'.expand("<slnum>"))
    7              0.000014      if type(g:netrw_browse_split) == 3
                                  " open file in server
                                  " Note that g:netrw_browse_split is a List: [servername,tabnr,winnr]
                            "      call Decho("edit-a-file: open file in server",'~'.expand("<slnum>"))
                                  call s:NetrwServerEdit(a:islocal,dirname)
                            "      call Dret("s:NetrwBrowseChgDir")
                                  return
                                 elseif g:netrw_browse_split == 1
                                  " horizontally splitting the window first
                            "      call Decho("edit-a-file: horizontally splitting window prior to edit",'~'.expand("<slnum>"))
                                  keepalt new
                                  if !&ea
                                   keepalt wincmd _
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 2
                                  " vertically splitting the window first
                            "      call Decho("edit-a-file: vertically splitting window prior to edit",'~'.expand("<slnum>"))
                                  keepalt rightb vert new
                                  if !&ea
                                   keepalt wincmd |
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 3
                                  " open file in new tab
                            "      call Decho("edit-a-file: opening new tab prior to edit",'~'.expand("<slnum>"))
                                  keepalt tabnew
                                  if !exists("b:netrw_curdir")
                                   let b:netrw_curdir= getcwd()
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 elseif g:netrw_browse_split == 4
                                  " act like "P" (ie. open previous window)
                            "      call Decho("edit-a-file: use previous window for edit",'~'.expand("<slnum>"))
                                  if s:NetrwPrevWinOpen(2) == 3
                                   let @@= ykeep
                            "       call Dret("s:NetrwBrowseChgDir")
                                   return
                                  endif
                                  call s:SetRexDir(a:islocal,curdir)
                                 else
                                  " handling a file, didn't split, so remove menu
                            "      call Decho("edit-a-file: handling a file+didn't split, so remove menu",'~'.expand("<slnum>"))
    7   0.000764   0.000023       call s:NetrwMenu(0)
                                  " optional change to window
    7              0.000007       if g:netrw_chgwin >= 1
                            "       call Decho("edit-a-file: changing window to #".g:netrw_chgwin,'~'.expand("<slnum>"))
                                   if winnr("$")+1 == g:netrw_chgwin
                            	" if g:netrw_chgwin is set to one more than the last window, then
                            	" vertically split the last window to make that window available.
                            	let curwin= winnr()
                            	exe "NetrwKeepj keepalt ".winnr("$")."wincmd w"
                            	vs
                            	exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd ".curwin
                                   endif
                                   exe "NetrwKeepj keepalt ".g:netrw_chgwin."wincmd w"
                                  endif
    7   0.000114   0.000024       call s:SetRexDir(a:islocal,curdir)
    7              0.000003      endif
    7              0.000005     endif
                            
                                " the point where netrw actually edits the (local) file
                                " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
                                " no keepalt to support  :e #  to return to a directory listing
    7              0.000006     if a:islocal
                            "     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname),'~'.expand("<slnum>"))
                                 " some like c-^ to return to the last edited file
                                 " others like c-^ to return to the netrw buffer
    7              0.000017      if exists("g:netrw_altfile") && g:netrw_altfile
                                  exe "NetrwKeepj keepalt e! ".fnameescape(dirname)
                                 else
    7   0.470728   0.007705       exe "NetrwKeepj e! ".fnameescape(dirname)
    7              0.000007      endif
                            "     call Decho("edit-a-file: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod,'~'.expand("<slnum>"))
    7   0.000435   0.000056      call s:NetrwCursor()
    7              0.000007      if &hidden || &bufhidden == "hide"
                                  " file came from vim's hidden storage.  Don't "restore" options with it.
    7              0.000018       let dorestore= 0
    7              0.000003      endif
    7              0.000003     else
                            "     call Decho("edit-a-file: remote file: NetrwBrowse will edit it",'~'.expand("<slnum>"))
                                endif
    7              0.000048     let dolockout= 1
                            
                                " handle g:Netrw_funcref -- call external-to-netrw functions
                                "   This code will handle g:Netrw_funcref as an individual function reference
                                "   or as a list of function references.  It will ignore anything that's not
                                "   a function reference.  See  :help Funcref  for information about function references.
    7              0.000019     if exists("g:Netrw_funcref")
                            "     call Decho("edit-a-file: handle optional Funcrefs",'~'.expand("<slnum>"))
                                 if type(g:Netrw_funcref) == 2
                            "      call Decho("edit-a-file: handling a g:Netrw_funcref",'~'.expand("<slnum>"))
                                  NetrwKeepj call g:Netrw_funcref()
                                 elseif type(g:Netrw_funcref) == 3
                            "      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs",'~'.expand("<slnum>"))
                                  for Fncref in g:Netrw_funcref
                                   if type(FncRef) == 2
                                    NetrwKeepj call FncRef()
                                   endif
                                  endfor
                                 endif
                                endif
    7              0.000003    endif
                            
    7              0.000005   elseif newdir =~ '^/'
                               " ----------------------------------------------------
                               " NetrwBrowseChgDir: just go to the new directory spec {{{3
                               " ----------------------------------------------------
                            "   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>','~'.expand("<slnum>"))
                               let dirname = newdir
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               NetrwKeepj call s:NetrwOptionRestore("s:")
                               norm! m`
                            
                              elseif newdir == './'
                               " ---------------------------------------------
                               " NetrwBrowseChgDir: refresh the directory list {{{3
                               " ---------------------------------------------
                            "   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"','~'.expand("<slnum>"))
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                               norm! m`
                            
                              elseif newdir == '../'
                               " --------------------------------------
                               " NetrwBrowseChgDir: go up one directory {{{3
                               " --------------------------------------
                            "   call Decho('go-up: case "go up one directory": newdir == "../"','~'.expand("<slnum>"))
                            
    1              0.000002    if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                                " force a refresh
                            "    call Decho("go-up: clear buffer<".expand("%")."> with :%d",'~'.expand("<slnum>"))
                            "    call Decho("go-up: setl noro ma",'~'.expand("<slnum>"))
                                setl noro ma
                                NetrwKeepj %d _
                               endif
                            
    1              0.000003    if has("amiga")
                                " amiga
                            "    call Decho('go-up: case "go up one directory": newdir == "../" and amiga','~'.expand("<slnum>"))
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
                                 let dirname= substitute(dirname,'/$','','')
                                else
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
                                endif
                            "    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                " windows
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                                if dirname =~ '^\a:$'
                                 let dirname= dirname.'/'
                                endif
                            "    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
                            
                               else
                                " unix or cygwin
                            "    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin','~'.expand("<slnum>"))
    1              0.000001     if a:islocal
    1              0.000043      let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
    1              0.000001      if dirname == ""
                                  let dirname= '/'
                                 endif
    1              0.000000     else
                                 let dirname= substitute(dirname,'^\(\a\{3,}://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                            "    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)",'~'.expand("<slnum>"))
    1              0.000000    endif
    1   0.000026   0.000009    NetrwKeepj call s:SetRexDir(a:islocal,dirname)
    1   0.023476   0.000155    norm m`
                            
    1              0.000003   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " --------------------------------------
                               " NetrwBrowseChgDir: Handle Tree Listing {{{3
                               " --------------------------------------
                            "   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists','~'.expand("<slnum>"))
                               " force a refresh (for TREELIST, NetrwTreeDir() will force the refresh)
                            "   call Decho("tree-list: setl noro ma",'~'.expand("<slnum>"))
                               setl noro ma
                               if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
                            "    call Decho("tree-list: clear buffer<".expand("%")."> with :%d  (force refresh)",'~'.expand("<slnum>"))
                                NetrwKeepj %d _
                               endif
                               let treedir      = s:NetrwTreeDir(a:islocal)
                            "   call Decho("tree-list: treedir<".treedir.">",'~'.expand("<slnum>"))
                               let s:treecurpos = winsaveview()
                               let haskey       = 0
                            "   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                            
                               " search treedict for tree dir as-is
                            "   call Decho("tree-list: search treedict for tree dir as-is",'~'.expand("<slnum>"))
                               if has_key(w:netrw_treedict,treedir)
                            "    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!','~'.expand("<slnum>"))
                                let haskey= 1
                               else
                            "    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                               endif
                            
                               " search treedict for treedir with a [/@] appended
                            "   call Decho("tree-list: search treedict for treedir with a [/@] appended",'~'.expand("<slnum>"))
                               if !haskey && treedir !~ '[/@]$'
                                if has_key(w:netrw_treedict,treedir."/")
                                 let treedir= treedir."/"
                            "     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                               " search treedict for treedir with any trailing / elided
                            "   call Decho("tree-list: search treedict for treedir with any trailing / elided",'~'.expand("<slnum>"))
                               if !haskey && treedir =~ '/$'
                                let treedir= substitute(treedir,'/$','','')
                                if has_key(w:netrw_treedict,treedir)
                            "     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!','~'.expand("<slnum>"))
                                 let haskey = 1
                                else
                            "     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found','~'.expand("<slnum>"))
                                endif
                               endif
                            
                            "   call Decho("haskey=".haskey,'~'.expand("<slnum>"))
                               if haskey
                                " close tree listing for selected subdirectory
                            "    call Decho("tree-list: closing selected subdirectory<".dirname.">",'~'.expand("<slnum>"))
                                call remove(w:netrw_treedict,treedir)
                            "    call Decho("tree-list: removed     entry<".treedir."> from treedict",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">",'~'.expand("<slnum>"))
                                let dirname= w:netrw_treetop
                               else
                                " go down one directory
                                let dirname= substitute(treedir,'/*$','/','')
                            "    call Decho("tree-list: go down one dir: treedir<".treedir.">",'~'.expand("<slnum>"))
                            "    call Decho("tree-list: ...            : dirname<".dirname.">",'~'.expand("<slnum>"))
                               endif
                               NetrwKeepj call s:SetRexDir(a:islocal,dirname)
                            "   call Decho("setting s:treeforceredraw to true",'~'.expand("<slnum>"))
                               let s:treeforceredraw = 1
                            
                              else
                               " ----------------------------------------
                               " NetrwBrowseChgDir: Go down one directory {{{3
                               " ----------------------------------------
    9   0.000708   0.000056    let dirname    = s:ComposePath(dirname,newdir)
                            "   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">",'~'.expand("<slnum>"))
    9   0.000265   0.000082    NetrwKeepj call s:SetRexDir(a:islocal,dirname)
    9   0.229049   0.000816    norm m`
    9              0.000004   endif
                            
                             " --------------------------------------
                             " NetrwBrowseChgDir: Restore and Cleanup {{{3
                             " --------------------------------------
   17              0.000018   if dorestore
                               " dorestore is zero'd when a local file was hidden or bufhidden;
                               " in such a case, we want to keep whatever settings it may have.
                            "   call Decho("doing option restore (dorestore=".dorestore.")",'~'.expand("<slnum>"))
   10   0.018465   0.000154    NetrwKeepj call s:NetrwOptionRestore("s:")
                            "  else " Decho
                            "   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod,'~'.expand("<slnum>"))
   10              0.000004   endif
   17   0.000674   0.000502   call s:RestorePosn(s:netrw_nbcd)
   17              0.000017   if dolockout && dorestore
                            "   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname),'~'.expand("<slnum>"))
                               if filewritable(dirname)
                            "    call Decho("restore: doing modification lockout settings: ma nomod noro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma noro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               else
                            "    call Decho("restore: doing modification lockout settings: ma nomod ro",'~'.expand("<slnum>"))
                            "    call Decho("restore: setl ma nomod noro",'~'.expand("<slnum>"))
                                setl ma ro nomod
                            "    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                               endif
                              endif
   17              0.000057   let @@= ykeep
                            
                            "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
   17              0.000036   return dirname

FUNCTION  airline#parts#crypt()
Called 554 times
Total time:   0.002987
 Self time:   0.002987

count  total (s)   self (s)
  554              0.002654   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>217_untracked_output()
Called 19 times
Total time:   0.000791
 Self time:   0.000791

count  total (s)   self (s)
   19              0.000515   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
    4              0.000035     let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    4              0.000004   else
   15              0.000063     let a:dict.cfg.untracked[a:dict.file] = ''
   15              0.000013   endif

FUNCTION  ale#util#ClockMilliseconds()
Called 667 times
Total time:   0.008692
 Self time:   0.008692

count  total (s)   self (s)
  667              0.006680     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  <SNR>179_reset_summary()
Called 37 times
Total time:   0.000905
 Self time:   0.000340

count  total (s)   self (s)
   37   0.000867   0.000302   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  <SNR>45_buffer_getvar()
Called 388 times
Total time:   0.001245
 Self time:   0.001245

count  total (s)   self (s)
  388              0.001140   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>214_NetrwMenu()
Called 25 times
Total time:   0.002855
 Self time:   0.002855

count  total (s)   self (s)
                            
   25              0.000062   if !exists("g:NetrwMenuPriority")
    1              0.000001    let g:NetrwMenuPriority= 80
    1              0.000001   endif
                            
   25              0.000112   if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                            "   call Dfunc("NetrwMenu(domenu=".a:domenu.")")
                            
                               if !exists("s:netrw_menu_enabled") && a:domenu
                            "    call Decho("initialize menu",'~'.expand("<slnum>"))
                                let s:netrw_menu_enabled= 1
                                exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
                                if g:netrw_dirhistmax > 0
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
                                else
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
                                endif
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Exten<tab>s      :let g:netrw_sort_by="exten"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
                                let s:netrw_menucnt= 28
                                call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
                                call s:NetrwTgtMenu()      " let bookmarks and history be easy targets
                            
                               elseif !a:domenu
                                let s:netrwcnt = 0
                                let curwin     = winnr()
                                windo if getline(2) =~# "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
                                exe curwin."wincmd w"
                            
                                if s:netrwcnt <= 1
                            "     call Decho("clear menus",'~'.expand("<slnum>"))
                                 exe 'sil! unmenu '.g:NetrwTopLvlMenu
                            "     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*','~'.expand("<slnum>"))
                                 sil! unlet s:netrw_menu_enabled
                                endif
                               endif
                            "   call Dret("NetrwMenu")
                               return
                              endif
                            

FUNCTION  xolox#misc#persist#load()
Called 1 time
Total time:   0.000909
 Self time:   0.000909

count  total (s)   self (s)
                              " Read a Vim value like a number, string, list or dictionary from a file
                              " using [readfile()][] and [eval()][]. The first argument is the filename of
                              " the file to read (a string). The optional second argument specifies the
                              " default value which is returned when the file can't be loaded. This
                              " function returns the loaded value or the default value (which itself
                              " defaults to the integer 0).
                              "
                              " [eval()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#eval()
                              " [readfile()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#readfile()
    1              0.000004   let default_value = exists('a:1') ? a:1 : 0
    1              0.000001   try
    1              0.000884     let lines = readfile(a:filename)
    1              0.000010     return eval(join(lines, "\n"))
                              catch
                                return default_value
                              endtry

FUNCTION  fugitive#is_git_dir()
Called 94 times
Total time:   0.002423
 Self time:   0.001402

count  total (s)   self (s)
   94   0.001480   0.000459   let path = s:sub(a:path, '[\/]$', '') . '/'
   94              0.000898   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>161_check_mixed_indent()
Called 11 times
Total time:   0.006726
 Self time:   0.006726

count  total (s)   self (s)
   11              0.000036   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   11              0.000012   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
   11              0.006576     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>117_YRMRUAdd()
Called 6 times
Total time:   0.003093
 Self time:   0.000459

count  total (s)   self (s)
                                " Only add new items if they do not already exist in the MRU.
                                " If the item is found, move it to the start of the MRU.
    6              0.000008     let found   = -1
                                " let elem    = a:element
                                " if g:yankring_max_element_length != 0
                                "     let elem    = strpart(a:element, 0, g:yankring_max_element_length)
                                " endif
                                " if s:yr_history_version == 'v1'
                                "     let elem    = escape(elem, '@')
                                "     let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
                                " else
                                "     let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
                                " endif
                                " " Append the regtype to the end so we have it available
                                " let elem    = elem.",".a:element_type
                            
    6              0.000059     if strlen(a:element) < g:yankring_min_element_length
                                    return 1
                                endif
                            
    6   0.000397   0.000063     let elem = s:YRMRUElemFormat(a:element, a:element_type)
                            
                                " Refresh the List
    6   0.000474   0.000057     call s:YRHistoryRead()
                            
    6   0.000126   0.000049     let found   = s:YRMRUHas(a:mru_list, elem)
                            
                                " Special case for efficiency, if it is first item in the
                                " List, do nothing
    6              0.000007     if found != 0
    5              0.000003         if found != -1
                                        " Remove found item since we will add it to the top
    1              0.000004             call remove({a:mru_list}, found)
    1              0.000000         endif
    5              0.000022         call insert({a:mru_list}, elem, 0)
    5   0.001853   0.000047         call s:YRHistorySave()
    5              0.000004     endif
                            
    6              0.000006     return 1

FUNCTION  airline#extensions#branch#head()
Called 647 times
Total time:   0.347901
 Self time:   0.017311

count  total (s)   self (s)
  647              0.001952   if !exists('b:buffer_vcs_config')
   13   0.000419   0.000092     call s:init_buffer()
   13              0.000010   endif
                            
  647   0.254858   0.003018   call s:update_branch()
  647   0.078964   0.003320   call s:update_untracked()
                            
  647              0.002759   if exists('b:airline_head') && !empty(b:airline_head)
  633              0.000787     return b:airline_head
                              endif
                            
   14              0.000093   let b:airline_head = ''
   14              0.000066   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
   14              0.000020   let heads = {}
   42              0.000055   for vcs in vcs_priority
   28              0.000100     if !empty(b:buffer_vcs_config[vcs].branch)
   14              0.000041       let heads[vcs] = b:buffer_vcs_config[vcs].branch
   14              0.000009     endif
   28              0.000041   endfor
                            
   28              0.000047   for vcs in keys(heads)
   14              0.000025     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
   14   0.000246   0.000217     let b:airline_head .= (len(heads) > 1 ? s:vcs_config[vcs].exe .':' : '') . s:format_name(heads[vcs])
   14              0.000042     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
   14              0.000008   endfor
                            
   14              0.000023   if empty(heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
   14              0.000062   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
   14   0.002494   0.000109   if has_key(heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
   14              0.000066   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   14   0.000530   0.000165   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
   14              0.000051   return b:airline_head

FUNCTION  <SNR>109_set()
Called 1702 times
Total time:   0.049391
 Self time:   0.006966

count  total (s)   self (s)
 1702   0.049019   0.006594   return call('delimitMate#Set', a:000)

FUNCTION  gitgutter#diff#run_diff()
Called 22 times
Total time:   0.051323
 Self time:   0.007897

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   22              0.000033   let cmd = '('
                            
   22   0.000117   0.000077   let bufnr = gitgutter#utility#bufnr()
   22   0.000338   0.000102   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
   22              0.000018   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
    8              0.000006     if a:realtime
                                  throw 'diff failed'
                                else
    8   0.000330   0.000091       let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
    8              0.000003     endif
    8              0.000005   endif
                            
   22              0.000019   if a:realtime
    3   0.015420   0.000078     let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
    3              0.000008     let blob_file = s:temp_index
    3              0.000005     let buff_file = s:temp_buffer
    3   0.000084   0.000066     let extension = gitgutter#utility#extension()
    3              0.000009     if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
    3              0.000027     let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
    3              0.000021     let modified      = getbufvar(bufnr, "&mod")
    3              0.000020     let op_mark_start = getpos("'[")
    3              0.000010     let op_mark_end   = getpos("']")
                            
    3              0.003277     execute 'keepalt noautocmd silent write!' buff_file
                            
    3              0.000087     call setbufvar(bufnr, "&mod", modified)
    3              0.000017     call setpos("'[", op_mark_start)
    3              0.000010     call setpos("']", op_mark_end)
    3              0.000006   endif
                            
   22              0.000060   let cmd .= g:gitgutter_git_executable
   22              0.000026   if s:c_flag
   22              0.000041     let cmd .= ' -c "diff.autorefreshindex=0"'
   22              0.000048     let cmd .= ' -c "diff.noprefix=false"'
   22              0.000008   endif
   22              0.000070   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
   22              0.000018   if a:realtime
    3              0.000016     let cmd .= ' -- '.blob_file.' '.buff_file
    3              0.000003   else
   19   0.000641   0.000165     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
   19              0.000011   endif
                            
   22              0.000039   if !a:preserve_full_diff && s:grep_available
   22   0.001116   0.000174     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
   22              0.000014   endif
                            
   22              0.000045   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
   22              0.000042     let cmd .= ' || exit 0'
   22              0.000009   endif
                            
   22              0.000031   let cmd .= ')'
                            
   22              0.000031   if !tracked
    8              0.000008     let cmd .= ')'
    8              0.000005   endif
                            
   22   0.000913   0.000122   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
   22   0.000195   0.000142   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
   22   0.026686   0.001397     call gitgutter#async#execute(cmd)
   22              0.000153     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>214_SetRexDir()
Called 21 times
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
                            "  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">) win#".winnr())
   21              0.000058   let w:netrw_rexdir         = a:dirname
   21              0.000040   let w:netrw_rexlocal       = a:islocal
   21              0.000185   let s:rexposn_{bufnr("%")} = winsaveview()
                            "  call Decho("setting w:netrw_rexdir  =".w:netrw_rexdir,'~'.expand("<slnum>"))
                            "  call Decho("setting w:netrw_rexlocal=".w:netrw_rexlocal,'~'.expand("<slnum>"))
                            "  call Decho("saving posn to s:rexposn_".bufnr("%")."<".string(s:rexposn_{bufnr("%")}).">",'~'.expand("<slnum>"))
                            "  call Decho("setting s:rexposn_".bufnr("%")."<".bufname("%")."> to ".string(winsaveview()),'~'.expand("<slnum>"))
                            "  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)

FUNCTION  GitGutterGetHunkSummary()
Called 459 times
Total time:   0.013946
 Self time:   0.003326

count  total (s)   self (s)
  459   0.013652   0.003032   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 554 times
Total time:   0.014403
 Self time:   0.005105

count  total (s)   self (s)
  554   0.014000   0.004702   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>186_RemoveProblemsForDisabledLinters()
Called 35 times
Total time:   0.000769
 Self time:   0.000769

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
   35              0.000094     let l:name_map = {}
                            
   61              0.000095     for l:linter in a:linters
   26              0.000089         let l:name_map[l:linter.name] = 1
   26              0.000030     endfor
                            
   35              0.000243     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#highlight#BufferHidden()
Called 19 times
Total time:   0.000338
 Self time:   0.000126

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
   19   0.000291   0.000079     call ale#highlight#RemoveHighlights()

FUNCTION  ProjectionistDetect()
Called 28 times
Total time:   0.048896
 Self time:   0.008811

count  total (s)   self (s)
   28              0.000111   let b:projectionist = {}
   28              0.000041   unlet! b:projectionist_file
   28              0.000956   let file = simplify(fnamemodify(a:path, ':p:s?[\/]$??'))
                            
   28              0.000045   let root = file
   28              0.000037   let previous = ""
  230              0.000310   while root !=# previous
  202   0.008159   0.000885     if s:has(root, '.projections.json')
                                  try
                                    let value = projectionist#json_parse(readfile(root.'/.projections.json'))
                                    call projectionist#append(root, value)
                                  catch /^invalid JSON:/
                                  endtry
                                endif
  202              0.000472     for [key, value] in items(g:projectionist_heuristics)
                                  for test in split(key, '|')
                                    if empty(filter(split(test, '&'), '!s:has(root, v:val)'))
                                      call projectionist#append(root, value)
                                      break
                                    endif
                                  endfor
                                endfor
  202              0.000225     let previous = root
  202              0.000530     let root = fnamemodify(root, ':h')
  202              0.000223   endwhile
                            
   28              0.000041   let modelines = &modelines
   28              0.000018   try
   28              0.000117     set modelines=0
   28              0.000068     let g:projectionist_file = file
   28   0.033429   0.000618     silent doautocmd User ProjectionistDetect
   28              0.000032   finally
   28              0.000153     let &modelines = modelines
   28              0.000043     unlet! g:projectionist_file
   28              0.000023   endtry
                            
   28              0.000060   if !empty(b:projectionist)
                                let b:projectionist_file = file
                                call projectionist#activate()
                              endif

FUNCTION  ale#highlight#SetHighlights()
Called 35 times
Total time:   0.003448
 Self time:   0.000775

count  total (s)   self (s)
   35              0.000277     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   35              0.000201     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   35   0.002862   0.000189     call ale#highlight#UpdateHighlights()

FUNCTION  xolox#misc#msg#info()
Called 1 time
Total time:   0.028979
 Self time:   0.000115

count  total (s)   self (s)
                              " Show a formatted informational message to the user.
                              "
                              " This function has the same argument handling as Vim's [printf()] []
                              " function with one notable difference: Any arguments which are not numbers
                              " or strings are coerced to strings using Vim's [string()] [] function.
                              "
                              " In the case of `xolox#misc#msg#info()`, automatic string coercion simply
                              " makes the function a bit easier to use.
                              "
                              " The messages emitted by this function have no highlighting. Previously
                              " these messages were highlighted using the [Title group] [hl-title], but it
                              " was pointed out in [pull request 16] [pr-16] that this group shouldn't be
                              " used for informational messages because it is meant for titles and because
                              " of this some color schemes use colors that stand out quite a bit, causing
                              " the informational messages to look like errors.
                              "
                              " [hl-title]: http://vimdoc.sourceforge.net/htmldoc/syntax.html#hl-Title
                              " [pr-16]: https://github.com/xolox/vim-misc/pull/16
                              " [printf()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
    1   0.028970   0.000106   call s:show_message('None', a:000)

FUNCTION  <SNR>39_on_window_changed()
Called 110 times
Total time:   0.374999
 Self time:   0.005612

count  total (s)   self (s)
  110              0.000447   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
  110              0.001127   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
  110              0.002472   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   64              0.000054     return
                              endif
   46              0.000385   let g:airline_last_window_changed = l:key
   46   0.000423   0.000255   call s:init()
   46   0.369436   0.000217   call airline#update_statusline()

FUNCTION  <SNR>44_InTmuxSession()
Called 11 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   11              0.000056   return $TMUX != ''

FUNCTION  <SNR>182_cleanup_after_plugin()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000005   call add(a:commands, "if !getbufvar(" . a:bufnr_var . ", '&modified')")
    1              0.000004   call add(a:commands, "  let s:wipebuflines = getbufline(" . a:bufnr_var . ", 1, '$')")
    1              0.000003   call add(a:commands, "  if len(s:wipebuflines) <= 1 && empty(get(s:wipebuflines, 0, ''))")
    1              0.000004   call add(a:commands, "    silent execute 'bwipeout' " . a:bufnr_var)
    1              0.000002   call add(a:commands, "  endif")
    1              0.000002   call add(a:commands, "endif")

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 4 times
Total time:   0.000186
 Self time:   0.000080

count  total (s)   self (s)
    4   0.000019   0.000014   let bufnr = gitgutter#utility#bufnr()
    4   0.000098   0.000027   let summary = gitgutter#hunk#summary(bufnr)
    4              0.000008   let summary[2] += a:count
    4   0.000051   0.000021   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#strip_trailing_new_line()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000046   return substitute(a:line, '\n$', '', '')

FUNCTION  gitgutter#utility#stringify()
Called 22 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
   22              0.000106   return join(a:list, "\n")."\n"

FUNCTION  xolox#misc#escape#shell()
Called 3 times
Total time:   0.000078
 Self time:   0.000054

count  total (s)   self (s)
                              " Takes a single string argument and converts it into a quoted command line
                              " argument.
                              "
                              " I was going to add a long rant here about Vim's ['shellslash' option]
                              " [shellslash], but really, it won't make any difference. Let's just suffice
                              " to say that I have yet to encounter a single person out there who uses
                              " this option for its intended purpose (running a UNIX style shell on
                              " Microsoft Windows).
                              "
                              " [shellslash]: http://vimdoc.sourceforge.net/htmldoc/options.html#'shellslash'
    3   0.000035   0.000011   if xolox#misc#os#is_win()
                                try
                                  let ssl_save = &shellslash
                                  set noshellslash
                                  return shellescape(a:string)
                                finally
                                  let &shellslash = ssl_save
                                endtry
                              else
    3              0.000012     return shellescape(a:string)
                              endif

FUNCTION  <SNR>117_YRMRUHas()
Called 6 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
                                " This function will find a string and return the element #
    6              0.000062     let find_idx = index({a:mru_list}, a:find_str)
                            
    6              0.000008     return find_idx

FUNCTION  gitgutter#async#execute()
Called 22 times
Total time:   0.025289
 Self time:   0.025150

count  total (s)   self (s)
   22   0.000163   0.000125   let options = {   'stdoutbuffer': [],   'buffer': gitgutter#utility#bufnr() }
   22   0.000208   0.000107   let command = s:build_command(a:cmd)
                            
   22              0.000065   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
   22              0.024216     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   22              0.000162   endif

FUNCTION  <SNR>173_ApplyPartialTimer()
Called 29 times
Total time:   0.012635
 Self time:   0.001181

count  total (s)   self (s)
   29              0.000733     let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
   29   0.011848   0.000394     call call(l:Callback, [a:timer_id] + l:args)

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 3 times
Total time:   0.015241
 Self time:   0.000272

count  total (s)   self (s)
    3   0.000044   0.000017   let file_path_relative_to_repo_root = gitgutter#utility#getbufvar(s:bufnr, 'repo_relative_path')
    3              0.000005   if empty(file_path_relative_to_repo_root)
    1   0.014862   0.000044     let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(g:gitgutter_git_executable.' rev-parse --show-prefix'))
    1   0.000174   0.000123     let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
    1   0.000038   0.000020     let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
    1   0.000071   0.000016     call gitgutter#utility#setbufvar(s:bufnr, 'repo_relative_path', file_path_relative_to_repo_root)
    1              0.000002   endif
    3              0.000008   return file_path_relative_to_repo_root

FUNCTION  <SNR>22_DetectCoffee()
Called 9 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    9              0.000039     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif

FUNCTION  <SNR>167_get_syn()
Called 13358 times
Total time:   0.372322
 Self time:   0.372322

count  total (s)   self (s)
13358              0.030441   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
13358              0.012190   let color = ''
13358              0.060149   if hlexists(a:group)
12800              0.084182     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
12800              0.007394   endif
13358              0.025767   if empty(color) || color == -1
                                " should always exists
  558              0.004642     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  558              0.001089     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  558              0.000239   endif
13358              0.011047   return color

FUNCTION  <SNR>60_record()
Called 44 times
Total time:   0.028926
 Self time:   0.002599

count  total (s)   self (s)
   44              0.000212 	if s:locked | retu | en
   44              0.000095 	let bufnr = a:bufnr + 0
   44              0.000117 	let bufname = bufname(bufnr)
   44              0.000101 	if bufnr > 0 && !empty(bufname)
   31              0.001253 		cal filter(s:mrbs, 'v:val != bufnr')
   31              0.000354 		cal insert(s:mrbs, bufnr)
   31   0.026559   0.000232 		cal s:addtomrufs(bufname)
   31              0.000022 	en

FUNCTION  fugitive#head()
Called 647 times
Total time:   0.127425
 Self time:   0.009964

count  total (s)   self (s)
  647              0.001936   if !exists('b:git_dir')
                                return ''
                              endif
                            
  647   0.123775   0.006314   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  xolox#session#auto_save_periodic()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    1              0.000002   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 28 times
Total time:   0.000681
 Self time:   0.000681

count  total (s)   self (s)
   28              0.000573   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  xolox#session#save_fullscreen()
Called 1 time
Total time:   0.000968
 Self time:   0.000968

count  total (s)   self (s)
                              " Save the full screen state of Vim. This function provides integration
                              " between my [vim-session] [] and [vim-shell] [] plug-ins. The first
                              " argument is expected to be a list, it will be extended with the lines to
                              " be added to the session script.
                              "
                              " [vim-session]: http://peterodding.com/code/vim/session
                              " [vim-shell]: http://peterodding.com/code/vim/shell
    1              0.000001   try
    1              0.000927     let commands = xolox#shell#persist_fullscreen()
                                if !empty(commands)
                                  call add(a:commands, "try")
                                  for line in commands
                                    call add(a:commands, "  " . line)
                                  endfor
                                  if has('gui_running') && (has('gui_gtk') || has('gui_gtk2') || has('gui_gnome'))
                                    " Without this hack GVim on GTK doesn't preserve the window size.
                                    call add(a:commands, "  call feedkeys(\":set lines=" . &lines . " columns=" . &columns . "\\<CR>\")")
                                  endif
                                  call add(a:commands, "catch " . '/^Vim\%((\a\+)\)\=:E117/')
                                  call add(a:commands, "  \" Ignore missing full-screen plug-in.")
                                  call add(a:commands, "endtry")
                                endif
                              catch /^Vim\%((\a\+)\)\=:E117/
                                " Ignore missing full-screen functionality.
    1              0.000002   endtry

FUNCTION  xolox#misc#perm#get()
Called 1 time
Total time:   0.029019
 Self time:   0.000112

count  total (s)   self (s)
                              " Get the owner, group and permissions of the pathname given as the first
                              " argument. Returns an opaque value which you can later pass to
                              " `xolox#misc#perm#set()`.
    1   0.000186   0.000009   let pathname = xolox#misc#path#absolute(a:fname)
    1              0.000025   if filereadable(pathname)
    1              0.000008     let command = printf('stat --format %s %s', '%U:%G:%a', shellescape(pathname))
    1   0.028772   0.000042     let result = xolox#misc#os#exec({'command': command, 'check': 0})
    1              0.000004     if result['exit_code'] == 0 && len(result['stdout']) >= 1
                                  let tokens = split(result['stdout'][0], ':')
                                  if len(tokens) == 3
                                    let [owner, group, mode] = tokens
                                    let mode = '0' . mode
                                    call xolox#misc#msg#debug("vim-misc %s: File %s has owner %s, group %s, mode %s.", g:xolox#misc#version, pathname, owner, group, mode)
                                    return [owner, group, mode]
                                  endif
                                endif
    1              0.000000   endif
    1              0.000003   return []

FUNCTION  <SNR>111_gotoline()
Called 8 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
    8              0.000024 	let file = bufname("%")
                            
                            	" :e command calls BufRead even though the file is a new one.
                            	" As a workaround Jonas Pfenniger<jonas@pfenniger.name> added an
                            	" AutoCmd BufRead, this will test if this file actually exists before
                            	" searching for a file and line to goto.
    8              0.000119 	if (filereadable(file) || file == '')
    7              0.000008 		return file
                            	endif
                            
    1              0.000002 	let l:names = []
    2              0.000005 	for regexp in s:regexpressions
    1              0.000107 		let l:names =  matchlist(file, regexp)
                            
    1              0.000002 		if ! empty(l:names)
                            			let file_name = l:names[1]
                            			let line_num  = l:names[2] == ''? '0' : l:names[2]
                            			let  col_num  = l:names[3] == ''? '0' : l:names[3]
                            			call s:reopenAndGotoLine(file_name, line_num, col_num)
                            			return file_name
                            		endif
    1              0.000005 	endfor
    1              0.000001 	return file

FUNCTION  indent_guides#clear_matches()
Called 109 times
Total time:   0.003565
 Self time:   0.002573

count  total (s)   self (s)
  109   0.001610   0.000618   call indent_guides#init_matches()
  109              0.000233   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif

FUNCTION  <SNR>43_ShowMarks()
Called 13 times
Total time:   0.293348
 Self time:   0.237307

count  total (s)   self (s)
   13              0.000059 	if g:showmarks_enable == 0
                            		return
                            	endif
                            
   13              0.000463 	if   ((match(g:showmarks_ignore_type, "[Hh]") > -1) && (&buftype    == "help"    )) || ((match(g:showmarks_ignore_type, "[Qq]") > -1) && (&buftype    == "quickfix")) || ((match(g:showmarks_ignore_type, "[Pp]") > -1) && (&pvw        == 1         )) || ((match(g:showmarks_ignore_type, "[Rr]") > -1) && (&readonly   == 1         )) || ((match(g:showmarks_ignore_type, "[Mm]") > -1) && (&modifiable == 0         ))
                            		return
                            	endif
                            
   13              0.000034 	let n = 0
   13   0.000737   0.000131 	let s:maxmarks = strlen(s:IncludeMarks())
  965              0.001062 	while n < s:maxmarks
  953   0.037357   0.004564 		let c = strpart(s:IncludeMarks(), n, 1)
  953   0.011763   0.003387 		let nm = s:NameOfMark(c)
  953              0.002365 		let id = n + (s:maxmarks * winbufnr(0))
                            		"let ln = line("'".c)
  953   0.018809   0.004543 		let ln = s:GetMarkLine("'".c)
                            
  953              0.002944 		if ln == 0 && (exists('b:placed_'.nm) && b:placed_{nm} != ln)
                            			exe 'sign unplace '.id.' buffer='.winbufnr(0)
                            		elseif ln > 1 || c !~ '[a-zA-Z]'
                            			" Have we already placed a mark here in this call to ShowMarks?
  277              0.000644 			if exists('mark_at'.ln)
                            				" Already placed a mark, set the highlight to multiple
  196              0.000761 				if c =~# '[a-zA-Z]' && b:ShowMarksLink{mark_at{ln}} != 'ShowMarksHLm'
                            					let b:ShowMarksLink{mark_at{ln}} = 'ShowMarksHLm'
                            					exe 'hi link '.s:ShowMarksDLink{mark_at{ln}}.mark_at{ln}.' '.b:ShowMarksLink{mark_at{ln}}
                            				endif
  196              0.000093 			else
   81              0.000431 				if !exists('b:ShowMarksLink'.nm) || b:ShowMarksLink{nm} != s:ShowMarksDLink{nm}
   20              0.000087 					let b:ShowMarksLink{nm} = s:ShowMarksDLink{nm}
   20              0.000432 					exe 'hi link '.s:ShowMarksDLink{nm}.nm.' '.b:ShowMarksLink{nm}
   20              0.000010 				endif
   81              0.000172 				let mark_at{ln} = nm
   81              0.000263 				if !exists('b:placed_'.nm) || b:placed_{nm} != ln
   24              0.187961 					exe 'sign unplace '.id.' buffer='.winbufnr(0)
   24              1.636439 					exe 'sign place '.id.' name=ShowMark'.nm.' line='.ln.' buffer='.winbufnr(0)
   23              0.000094 					let b:placed_{nm} = ln
   23              0.000017 				endif
   80              0.000034 			endif
  276              0.000121 		endif
  952              0.001224 		let n = n + 1
  952              0.000709 	endw

FUNCTION  <SNR>214_NetrwMaps()
Called 18 times
Total time:   0.027842
 Self time:   0.027441

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                            
   18              0.000044   if g:netrw_mousemaps && g:netrw_retmap
                            "   call Decho("set up Rexplore 2-leftmouse",'~'.expand("<slnum>"))
                               if !hasmapto("<Plug>NetrwReturn")
                                if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
                            "     call Decho("making map for 2-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
                                elseif maparg("<c-leftmouse>","n") == ""
                            "     call Decho("making map for c-leftmouse",'~'.expand("<slnum>"))
                                 nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
                                endif
                               endif
                               nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
                            "   call Decho("made <Plug>NetrwReturn map",'~'.expand("<slnum>"))
                              endif
                            
   18              0.000015   if a:islocal
                            "   call Decho("make local maps",'~'.expand("<slnum>"))
                               " local normal-mode maps
   18              0.001250    nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(1)<cr>
   18              0.000378    nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(1)<cr>
   18              0.000294    nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(1)<cr>
   18              0.000313    nnoremap <buffer> <silent> <nowait> c	:<c-u>call <SID>NetrwLcd(b:netrw_curdir)<cr>
   18              0.000256    nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
   18              0.000337    nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   18              0.000273    nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(3,<SID>NetrwGetWord())<cr>
   18              0.000247    nnoremap <buffer> <silent> <nowait> d	:<c-u>call <SID>NetrwMakeDir("")<cr>
   18              0.000289    nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   18              0.000274    nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   18              0.000261    nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   18              0.000225    nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   18              0.000301    nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
   18              0.000254    nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   18              0.000229    nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
   18              0.000232    nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(1)<cr>
   18              0.000234    nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(1,0)<cr>
   18              0.000258    nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(1,1)<cr>
   18              0.000268    nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   18              0.000260    nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   18              0.000250    nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   18              0.000211    nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   18              0.000239    nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   18              0.000255    nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   18              0.000341    nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   18              0.000268    nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   18              0.000232    nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   18              0.000236    nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   18              0.000226    nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   18              0.000331    nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   18              0.000300    nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   18              0.000236    nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   18              0.000235    nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   18              0.000236    nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   18              0.000243    nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   18              0.000261    nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
   18              0.000278    nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
   18              0.000285    nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   18              0.000277    nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(1)<cr>
   18              0.000234    nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(3)<cr>
   18              0.000340    nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   18              0.000276    nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(1)<cr>
   18              0.000288    nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   18              0.000265    nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   18              0.000283    nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   18              0.000282    nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
   18              0.000460    nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   18              0.000234    nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(1)<cr>
   18              0.000219    nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(1)<cr>
   18              0.000237    nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
   18              0.000216    nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(4)<cr>
   18              0.000257    nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
   18              0.000282    nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   18              0.000277    nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   18              0.000210    nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(5)<cr>
   18              0.000278    nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   18              0.000269    nnoremap <buffer> <silent> <nowait> X	:<c-u>call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
                            "   " local insert-mode maps
                            "   inoremap <buffer> <silent> <nowait> a	<c-o>:call <SID>NetrwHide(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> c	<c-o>:exe "NetrwKeepj lcd ".fnameescape(b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> c	<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> C	<c-o>:call <SID>NetrwSetChgwin()<cr>
                            "   inoremap <buffer> <silent> <nowait> %	<c-o>:call <SID>NetrwOpenFile(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> -	<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
                            "   inoremap <buffer> <silent> <nowait> d	<c-o>:call <SID>NetrwMakeDir("")<cr>
                            "   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
                            "   nnoremap <buffer> <silent> <nowait> gn	:<c-u>call netrw#SetTreetop(<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> I	<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> i	<c-o>:call <SID>NetrwListStyle(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1,1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> O	<c-o>:call <SID>NetrwObtain(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> o	<c-o>:call <SID>NetrwSplit(3)<cr>
                            "   inoremap <buffer> <silent> <nowait> p	<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                            "   inoremap <buffer> <silent> <nowait> P	<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
                            "   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(1,getloclist(v:count))<cr>
                            "   inoremap <buffer> <silent> <nowait> r	<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> s	<c-o>:call <SID>NetrwSortStyle(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> S	<c-o>:call <SID>NetSortSequence(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> t	<c-o>:call <SID>NetrwSplit(4)<cr>
                            "   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'b',v:count1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt(1,'h',v:count)<cr>
                            "   inoremap <buffer> <silent> <nowait> u	<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
                            "   inoremap <buffer> <silent> <nowait> U	<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
                            "   inoremap <buffer> <silent> <nowait> v	<c-o>:call <SID>NetrwSplit(5)<cr>
                            "   inoremap <buffer> <silent> <nowait> x	<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   18              0.001228    if !hasmapto('<Plug>NetrwHideEdit')
   18              0.000155     nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
                            "    imap <buffer> <unique> <c-h> <c-o><Plug>NetrwHideEdit
   18              0.000011    endif
   18              0.000313    nnoremap <buffer> <silent> <Plug>NetrwHideEdit		:call <SID>NetrwHideEdit(1)<cr>
   18              0.000741    if !hasmapto('<Plug>NetrwRefresh')
   18              0.000110     nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
                            "    imap <buffer> <unique> <c-l> <c-o><Plug>NetrwRefresh
   18              0.000011    endif
   18              0.000397    nnoremap <buffer> <silent> <Plug>NetrwRefresh		<c-l>:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,(w:netrw_liststyle == 3)? w:netrw_treetop : './'))<cr>
   18              0.000163    if s:didstarstar || !mapcheck("<s-down>","n")
   18              0.000211     nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                            "    inoremap <buffer> <silent> <s-down>	<c-o>:Nexplore<cr>
   18              0.000011    endif
   18              0.000109    if s:didstarstar || !mapcheck("<s-up>","n")
   18              0.000211     nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                            "    inoremap <buffer> <silent> <s-up>	<c-o>:Pexplore<cr>
   18              0.000009    endif
   18              0.000758    if !hasmapto('<Plug>NetrwTreeSqueeze')
    4              0.000053     nmap <buffer> <silent> <nowait> <s-cr>			<Plug>NetrwTreeSqueeze
                            "    imap <buffer> <silent> <nowait> <s-cr>			<c-o><Plug>NetrwTreeSqueeze
    4              0.000002    endif
   18              0.000330    nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze		:call <SID>TreeSqueezeDir(1)<cr>
   18              0.000122    let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   18              0.000024    if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>   				<Plug>NetrwLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
                                nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(1)<cr>
                                nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>		<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
                                nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
                                nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
                                nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
                                nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>		<Plug>ILeftmouse
                            "    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
                                imap <buffer> <middlemouse>		<Plug>IMiddlemouse
                            "    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                            "    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
                            "    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               endif
   18              0.000395    exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   18              0.000352    exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   18              0.000349    exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   18              0.000249    exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("")<cr>'
   18              0.000347    exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   18              0.000332    exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   18              0.000331    exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
   18              0.000228    nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
   18   0.000574   0.000173    call netrw#UserMaps(1)
                            
   18              0.000013   else " remote
                            "   call Decho("make remote maps",'~'.expand("<slnum>"))
                               call s:RemotePathAnalysis(b:netrw_curdir)
                               " remote normal-mode maps
                               nnoremap <buffer> <silent> <nowait> a	:<c-u>call <SID>NetrwHide(0)<cr>
                               nnoremap <buffer> <silent> <nowait> -	:<c-u>call <SID>NetrwBrowseUpDir(0)<cr>
                               nnoremap <buffer> <silent> <nowait> %	:<c-u>call <SID>NetrwOpenFile(0)<cr>
                               nnoremap <buffer> <silent> <nowait> C	:<c-u>call <SID>NetrwSetChgwin()<cr>
                               nnoremap <buffer> <silent> <nowait> <c-l>	:<c-u>call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> <cr>	:<c-u>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <nowait> <c-r>	:<c-u>call <SID>NetrwServerEdit(2,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
                               nnoremap <buffer> <silent> <nowait> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> I	:<c-u>call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> <nowait> i	:<c-u>call <SID>NetrwListStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ma	:<c-u>call <SID>NetrwMarkFileArgList(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mA	:<c-u>call <SID>NetrwMarkFileArgList(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               nnoremap <buffer> <silent> <nowait> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               nnoremap <buffer> <silent> <nowait> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               nnoremap <buffer> <silent> <nowait> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               nnoremap <buffer> <silent> <nowait> mx	:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
                               nnoremap <buffer> <silent> <nowait> mX	:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
                               nnoremap <buffer> <silent> <nowait> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               nnoremap <buffer> <silent> <nowait> O	:<c-u>call <SID>NetrwObtain(0)<cr>
                               nnoremap <buffer> <silent> <nowait> o	:call <SID>NetrwSplit(0)<cr>
                               nnoremap <buffer> <silent> <nowait> p	:<c-u>call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> <nowait> P	:<c-u>call <SID>NetrwPrevWinOpen(0)<cr>
                               nnoremap <buffer> <silent> <nowait> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               nnoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
                               nnoremap <buffer> <silent> <nowait> r	:<c-u>let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> <nowait> s	:call <SID>NetrwSortStyle(0)<cr>
                               nnoremap <buffer> <silent> <nowait> S	:<c-u>call <SID>NetSortSequence(0)<cr>
                               nnoremap <buffer> <silent> <nowait> Tb	:<c-u>call <SID>NetrwSetTgt(0,'b',v:count1)<cr>
                               nnoremap <buffer> <silent> <nowait> t	:call <SID>NetrwSplit(1)<cr>
                               nnoremap <buffer> <silent> <nowait> Th	:<c-u>call <SID>NetrwSetTgt(0,'h',v:count)<cr>
                               nnoremap <buffer> <silent> <nowait> u	:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> U	:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> <nowait> v	:call <SID>NetrwSplit(2)<cr>
                               nnoremap <buffer> <silent> <nowait> x	:<c-u>call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                            "   " remote insert-mode maps
                            "   inoremap <buffer> <silent> <nowait> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                            "   inoremap <buffer> <silent> <nowait> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> a		<c-o>:call <SID>NetrwHide(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                            "   nnoremap <buffer> <silent> <nowait> mv	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mX	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0,1)<cr>
                            "   inoremap <buffer> <silent> <nowait> mv	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
                            "   inoremap <buffer> <silent> <nowait> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> o		<c-o>:call <SID>NetrwSplit(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> O		<c-o>:call <SID>NetrwObtain(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                            "   inoremap <buffer> <silent> <nowait> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                            "   inoremap <buffer> <silent> <nowait> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                            "   inoremap <buffer> <silent> <nowait> qL	:<c-u>call <SID>NetrwMarkFileQFEL(0,getloclist(v:count))<cr>
                            "   inoremap <buffer> <silent> <nowait> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~# 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                            "   inoremap <buffer> <silent> <nowait> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> S		<c-o>:call <SID>NetSortSequence(0)<cr>
                            "   inoremap <buffer> <silent> <nowait> t		<c-o>:call <SID>NetrwSplit(1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                            "   inoremap <buffer> <silent> <nowait> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                            "   inoremap <buffer> <silent> <nowait> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                            "   inoremap <buffer> <silent> <nowait> v		<c-o>:call <SID>NetrwSplit(2)<cr>
                            "   inoremap <buffer> <silent> <nowait> x		<c-o>:call netrw#BrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                            "   inoremap <buffer> <silent> <nowait> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <c-h> <Plug>NetrwHideEdit
                            "    imap <buffer> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <c-l> <Plug>NetrwRefresh
                            "    imap <buffer> <c-l> <Plug>NetrwRefresh
                               endif
                               if !hasmapto('<Plug>NetrwTreeSqueeze')
                                nmap <buffer> <silent> <nowait> <s-cr>	<Plug>NetrwTreeSqueeze
                            "    imap <buffer> <silent> <nowait> <s-cr>	<c-o><Plug>NetrwTreeSqueeze
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwTreeSqueeze	:call <SID>TreeSqueezeDir(0)<cr>
                            
                               let mapsafepath     = escape(s:path, s:netrw_map_escape)
                               let mapsafeusermach = escape(((s:user == "")? "" : s:user."@").s:machine, s:netrw_map_escape)
                            
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>		<Plug>NetrwLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
                                nmap <buffer> <c-leftmouse>		<Plug>NetrwCLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwCLeftmouse	<leftmouse>:call <SID>NetrwCLeftmouse(0)<cr>
                                nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
                                nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
                                nno  <buffer> <silent>		<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
                                nmap <middlemouse>			<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>		<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
                                nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>		<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>		<Plug>ILeftmouse
                            "    ino  <buffer> <silent>		<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
                                imap <buffer> <middlemouse>		<Plug>IMiddlemouse
                            "    ino  <buffer> <silent>		<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                                imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
                            "    ino  <buffer> <silent>		<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <nowait> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                            "   exe 'inoremap <buffer> <silent> <nowait> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                            "   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
                            
                               " support user-specified maps
                               call netrw#UserMaps(0)
                              endif
                            
                            "  call Dret("s:NetrwMaps")

FUNCTION  xolox#session#options_include()
Called 8 times
Total time:   0.000953
 Self time:   0.000095

count  total (s)   self (s)
                              " Check whether Vim's [sessionoptions] [] option includes the keyword given
                              " as the first argument (expected to be a string). Returns 1 (true) when it
                              " does, 0 (false) otherwise.
                              "
                              " [sessionoptions]: http://vimdoc.sourceforge.net/htmldoc/options.html#'sessionoptions'
    8   0.000935   0.000077   return index(xolox#misc#option#split(&sessionoptions), a:value) >= 0

FUNCTION  <SNR>214_SavePosn()
Called 18 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
                            "  call Dfunc("s:SavePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
                            
   18              0.000273   let a:posndict[bufnr("%")]= winsaveview()
                            "  call Decho("saving posn: posndict[".bufnr("%")."]=".string(winsaveview()),'~'.expand("<slnum>"))
                            
                            "  call Dret("s:SavePosn posndict")
   18              0.000029   return a:posndict

FUNCTION  gitgutter#hunk#reset()
Called 15 times
Total time:   0.000926
 Self time:   0.000314

count  total (s)   self (s)
   15   0.000457   0.000192   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
   15   0.000457   0.000110   call s:reset_summary()

FUNCTION  gitgutter#utility#exists_file()
Called 61 times
Total time:   0.000992
 Self time:   0.000992

count  total (s)   self (s)
   61              0.000965   return filereadable(s:file)

FUNCTION  <SNR>196_foldable()
Called 22 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   22              0.000050   if index(s:foldable_groups, 'ALL') > -1
   22              0.000017     return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  xolox#session#auto_unlock()
Called 1 time
Total time:   0.000240
 Self time:   0.000198

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.000047   0.000005   if xolox#session#locking_enabled()
    1              0.000002     let i = 0
    2              0.000005     while i < len(s:lock_files)
    1              0.000005       let lock_file = s:lock_files[i]
    1              0.000147       if delete(lock_file) == 0
    1              0.000012         call remove(s:lock_files, i)
    1              0.000001       else
                                    let i += 1
                                  endif
    1              0.000001     endwhile
    1              0.000001   endif

FUNCTION  airline#extensions#apply()
Called 64 times
Total time:   0.005195
 Self time:   0.002460

count  total (s)   self (s)
   64              0.000147   let s:active_winnr = winnr()
                            
   64   0.003000   0.000265   if s:is_excluded_window()
                                return -1
                              endif
                            
   64              0.000108   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   64              0.000056   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   64              0.000231   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   64              0.000178   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  gitgutter#utility#is_file_buffer()
Called 61 times
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
   61              0.000272   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>214_NetrwLcd()
Called 39 times
Total time:   0.003914
 Self time:   0.003914

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")
                            
   39              0.000049   try
   39              0.002782    exe 'NetrwKeepj sil lcd '.fnameescape(a:newdir)
   39              0.000067   catch /^Vim\%((\a\+)\)\=:E344/
                                 " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
                                 " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
                                 " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or
                                 " forward slashes ('//Foo'), depending on whether backslashes have been converted to
                                 " forward slashes by earlier code; so check for both.
                                 if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
                                   if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
                                     let dirname = '\'
                            	 exe 'NetrwKeepj sil lcd '.fnameescape(dirname)
                                   endif
                                 endif
                              catch /^Vim\%((\a\+)\)\=:E472/
                               call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
                               if exists("w:netrw_prvdir")
                                let a:newdir= w:netrw_prvdir
                               else
                                call s:NetrwOptionRestore("w:")
                            "    call Decho("setl noma nomod nowrap",'~'.expand("<slnum>"))
                                exe "setl ".g:netrw_bufsettings
                            "    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                                let a:newdir= dirname
                            "    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
                                return
                               endif
                              endtry
                            
                            "  call Dret("s:NetrwLcd")

FUNCTION  <SNR>171_section_is_empty()
Called 522 times
Total time:   0.004561
 Self time:   0.004561

count  total (s)   self (s)
  522              0.000493   let start=1
                            
                              " do not check for inactive windows or the tabline
  522              0.000629   if a:self._context.active == 0
  180              0.000130     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  342              0.000741   if get(g:, 'airline_skip_empty_sections', 0) == 0
  342              0.000266     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  gitgutter#utility#is_active()
Called 61 times
Total time:   0.005226
 Self time:   0.000803

count  total (s)   self (s)
   61   0.005175   0.000752   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  <SNR>158_is_branch_empty()
Called 468 times
Total time:   0.003330
 Self time:   0.003330

count  total (s)   self (s)
  468              0.003071   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>214_NetrwBookmarkMenu()
Called 18 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   18              0.000041   if !exists("s:netrw_menucnt")
   18              0.000013    return
                              endif
                            "  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)",'~'.expand("<slnum>"))
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " show bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd,'~'.expand("<slnum>"))
                                 let bmd= escape(bmd,g:netrw_menu_escape)
                            
                                 " show bookmarks for goto menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"
                            
                                 " show bookmarks for deletion menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
                                 let cnt= cnt + 1
                                endfor
                            
                               endif
                            
                               " show directory browsing history
                               if g:netrw_dirhistmax > 0
                                let cnt     = g:netrw_dirhist_cnt
                                let first   = 1
                                let histcnt = 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                                 let histcnt  = histcnt + 1
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{cnt}")
                                  let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir,'~'.expand("<slnum>"))
                                  exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
                                 endif
                                 let first = 0
                                 let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               endif
                            
                              endif
                            "  call Dret("NetrwBookmarkMenu")

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 22 times
Total time:   0.000345
 Self time:   0.000141

count  total (s)   self (s)
   22   0.000334   0.000130   call gitgutter#utility#setbufvar(s:bufnr, 'last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  <SNR>109_get()
Called 2612 times
Total time:   0.058759
 Self time:   0.010134

count  total (s)   self (s)
 2612   0.058094   0.009469   return call('delimitMate#Get', a:000)

FUNCTION  <SNR>172_add_section()
Called 332 times
Total time:   0.020526
 Self time:   0.007721

count  total (s)   self (s)
  332              0.001168     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  332   0.003048   0.001384     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
  332              0.000259     if condition
                                  call a:builder.add_raw('%(')
                                endif
  332   0.013575   0.002434     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  332              0.000254     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  xolox#misc#path#equals()
Called 1 time
Total time:   0.000268
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000268   0.000014     return a:a ==# a:b || xolox#misc#path#absolute(a:a) ==# xolox#misc#path#absolute(a:b)

FUNCTION  xolox#session#name_to_path()
Called 2 times
Total time:   0.000527
 Self time:   0.000048

count  total (s)   self (s)
                              " Convert the name of a session (the first argument, expected to be a
                              " string) to an absolute pathname. Any special characters in the session
                              " name will be encoded using URL encoding. This means you're free to use
                              " whatever naming conventions you like (regardless of special characters
                              " like slashes). Returns a string.
    2   0.000335   0.000013   let directory = xolox#misc#path#absolute(g:session_directory)
    2   0.000113   0.000016   let filename = xolox#misc#path#encode(a:name) . g:session_extension
    2   0.000073   0.000013   return xolox#misc#path#merge(directory, filename)

FUNCTION  airline#highlighter#get_highlight()
Called 6679 times
Total time:   0.725745
 Self time:   0.305802

count  total (s)   self (s)
 6679              0.021805   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
 6679   0.223926   0.029935     let fg = s:get_syn(a:group, 'fg')
 6679   0.204056   0.025725     let bg = s:get_syn(a:group, 'bg')
 6679              0.075984     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 6679              0.038916     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 6679              0.007592     let opts = a:000
 6679              0.005379     if bold
 1220              0.001476       let opts = ['bold']
 1220              0.000662     endif
 6679   0.085993   0.038372     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
 6679              0.003762   endif
 6679              0.019598   let s:hl_groups[a:group] = res
 6679              0.005361   return res

FUNCTION  <SNR>117_YRPaste()
Called 1 time
Total time:   0.000622
 Self time:   0.000332

count  total (s)   self (s)
    1              0.000005     if g:yankring_manual_clipboard_check == 1
    1   0.000291   0.000029         call s:YRCheckClipboard()
    1              0.000001     endif
                            
                                " Disabling the yankring removes the default maps.
                                " But there are some maps the user can create on their own, and
                                " these would most likely call this function.  So place an extra
                                " check and display a message.
    1              0.000002     if g:yankring_enabled == 0
                                    call s:YRWarningMsg( 'YR: The yankring is currently disabled, use YRToggle.' )
                                    return
                                endif
                            
    1   0.000034   0.000006     let user_register  = s:YRRegister()
    1              0.000009     let default_buffer = ((&clipboard=~'\<unnamed\>')?'*':((&clipboard=~'\<unnamedplus\>' && has('unnamedplus'))?'+':'"'))
    1              0.000002     let v_count        = v:count
                            
                                " Default command mode to normal mode 'n'
    1              0.000002     let cmd_mode = 'n'
    1              0.000001     if a:0 > 0
                                    " Change to visual mode, if command executed via
                                    " a visual map
                                    let cmd_mode = ((a:1 == 'v') ? 'v' : 'n')
                                endif
                            
                                " User has decided to bypass the yankring and specify a specific
                                " register
    1              0.000002     if user_register != default_buffer
                                    if a:replace_last_paste_selection == 1
                                        call s:YRWarningMsg( 'YR: A register cannot be specified in replace mode' )
                                        return
                                    else
                                        " Check for the expression register, in this special case
                                        " we must copy it's evaluation into the default buffer and paste
                                        if user_register == '='
                                            " Save the default register since Vim will only
                                            " allow the expression register to be pasted once
                                            " and will revert back to the default buffer
                                            let save_default_reg = @"
                                            call setreg(default_buffer, eval(histget('=', -1)) )
                                        else
                                            let user_register = '"'.user_register
                                        endif
                                        exec "normal! ". ((cmd_mode=='n') ? "" : "gv"). ((v_count > 0)?(v_count):''). ((user_register=='=')?'':user_register). a:direction
                                        if user_register == '='
                                            let @" = save_default_reg
                                        endif
                                        " In this case, we have bypassed the yankring
                                        " If the user hits next or previous we want the
                                        " next item pasted to be the top of the yankring.
                                        let s:yr_last_paste_idx = 1
                                    endif
                                    let s:yr_paste_dir     = a:direction
                                    let s:yr_prev_vis_mode = ((cmd_mode=='n') ? 0 : 1)
                                    return
                                endif
                            
                                " Try to second guess the user to make these mappings less intrusive.
                                " If the user hits paste, compare the contents of the paste register
                                " to the current entry in the yankring.  If they are different, lets
                                " assume the user wants the contents of the paste register.
                                " The user could have:
                                "     let @" = 'test string'
                                " would not be in the yankring as no mapping triggered this action.
    1              0.000002     if a:replace_last_paste_selection != 1
                                        " Only check the default buffer is the user wants us to.
                                        " This was necessary prior to version 4.0 since we did not
                                        " capture as many items as 4.0 and above does. (A. Budden)
    1              0.000002             if g:yankring_paste_check_default_buffer == 1
    1              0.000049                 if ( default_buffer == '"' &&  getreg(default_buffer) != s:yr_prev_reg_unnamed )
                                                " There are only a couple of scenarios where this would happen
                                                " 1.  set clipboard = unnamed[plus]
                                                "     The user performs an action which changes the
                                                "     unnamed register (i.e. x - delete character)
                                                " 2.  Any type of direct manipulation of the registers
                                                "     let @" = 'something'
                                                " 3.  Something changed the system clipboard outside of Vim
                                                if getreg('"') != s:yr_prev_reg_unnamed
                                                    let default_buffer = '"'
                                                endif
                            
                                                " The user has performed a yank / delete operation
                                                " outside of the yankring maps.  First, add this
                                                " value to the yankring.
                                                call YRRecord(default_buffer)
                                            elseif ( default_buffer == '+' && len(getreg(default_buffer)) != 0 && getreg(default_buffer) != s:yr_prev_clipboard_plus )
                            
                                                " The user has performed a yank / delete operation
                                                " outside of the yankring maps.  First, add this
                                                " value to the yankring.
                                                call YRRecord(default_buffer)
                                            elseif ( default_buffer == '*' && len(getreg(default_buffer)) != 0 && getreg(default_buffer) != s:yr_prev_clipboard_star )
                            
                                                " The user has performed a yank / delete operation
                                                " outside of the yankring maps.  First, add this
                                                " value to the yankring.
                                                call YRRecord(default_buffer)
                                            endif
    1              0.000001             endif
                            
    1              0.000126             exec "normal! ". ((cmd_mode=='n') ? "" : "gv"). ((v_count > 0)?(v_count):''). a:direction
                                                    "\ '"'.default_buffer.
    1              0.000004             let s:yr_paste_dir     = a:direction
    1              0.000003             let s:yr_prev_vis_mode = ((cmd_mode=='n') ? 0 : 1)
    1              0.000001             return
                                endif
                            
                                " if s:yr_count > 0 || (
                                "             \ default_buffer != '"' &&
                                "             \ len(getreg(default_buffer)) == 0
                                "             \ )
                                "     " Nothing to paste
                                "     return
                                " endif
                            
                                if a:replace_last_paste_selection == 1
                                    " Replacing the previous put
                                    let start = line("'[")
                                    let end = line("']")
                            
                                    if start != line('.')
                                        call s:YRWarningMsg( 'YR: You must paste text first, before you can replace' )
                                        return
                                    endif
                            
                                    if start == 0 || end == 0
                                        return
                                    endif
                            
                                    " If a count was provided (ie 5<C-P>), multiply the
                                    " nextvalue accordingly and position the next paste index
                                    " let which_elem = a:nextvalue * ((v_count > 0)?(v_count):1) * -1
                                    let which_elem = matchstr(a:nextvalue, '-\?\d\+') * ((v_count > 0)?(v_count):1) * -1
                                    let s:yr_last_paste_idx = s:YRGetNextElem( s:yr_last_paste_idx, which_elem )
                            
                                    let save_reg            = getreg(default_buffer)
                                    let save_reg_type       = getregtype(default_buffer)
                                    call setreg( default_buffer , s:YRGetValElemNbr((s:yr_last_paste_idx-1),'v') , s:YRGetValElemNbr((s:yr_last_paste_idx-1),'t') )
                            
                                    " First undo the previous paste
                                    exec "normal! u"
                                    " Check if the visual selection should be reselected
                                    " Next paste the correct item from the ring
                                    " This is done as separate statements since it appeared that if
                                    " there was nothing to undo, the paste never happened.
                                    exec "normal! ". ((s:yr_prev_vis_mode==0) ? "" : "gv"). '"'.default_buffer. s:yr_paste_dir
                                    call setreg(default_buffer, save_reg, save_reg_type)
                                    call s:YRSetPrevOP('', '', '', 'n')
                                else
                                    " User hit p or P
                                    " Supports this for example -   5"ayy
                                    " And restores the current register
                                    let save_reg            = getreg(default_buffer)
                                    let save_reg_type       = getregtype(default_buffer)
                                    let s:yr_last_paste_idx = 1
                                    call setreg(default_buffer , s:YRGetValElemNbr(0,'v') , s:YRGetValElemNbr(0,'t') )
                                    exec "normal! ". ((cmd_mode=='n') ? "" : "gv"). ((v_count > 0)?(v_count):''). '"'.default_buffer. a:direction
                                    call setreg(default_buffer, save_reg, save_reg_type)
                                    call s:YRSetPrevOP( a:direction , v_count , default_buffer , 'n' )
                                    let s:yr_paste_dir     = a:direction
                                    let s:yr_prev_vis_mode = ((cmd_mode=='n') ? 0 : 1)
                                endif

FUNCTION  ale#history#Add()
Called 26 times
Total time:   0.000832
 Self time:   0.000832

count  total (s)   self (s)
   26              0.000053     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   26              0.000117     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   26              0.000077     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
   26              0.000168     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   26              0.000108     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  gitgutter#diff#parse_diff()
Called 22 times
Total time:   0.001021
 Self time:   0.000631

count  total (s)   self (s)
   22              0.000032   let hunks = []
   33              0.000151   for line in split(a:diff, '\n')
   11   0.000573   0.000183     let hunk_info = gitgutter#diff#parse_hunk(line)
   11              0.000021     if len(hunk_info) == 4
    4              0.000009       call add(hunks, hunk_info)
    4              0.000004     endif
   11              0.000007   endfor
   22              0.000021   return hunks

FUNCTION  xolox#misc#os#exec()
Called 1 time
Total time:   0.028730
 Self time:   0.001792

count  total (s)   self (s)
                              " Execute an external command (hiding the console on Microsoft Windows when
                              " my [vim-shell plug-in] [vim-shell] is installed).
                              "
                              " Expects a dictionary with the following key/value pairs as the first
                              " argument:
                              "
                              " - **command** (required): The command line to execute
                              " - **async** (optional): set this to 1 (true) to execute the command in the
                              "   background (asynchronously)
                              " - **stdin** (optional): a string or list of strings with the input for the
                              "   external command
                              " - **check** (optional): set this to 0 (false) to disable checking of the
                              "   exit code of the external command (by default an exception will be
                              "   raised when the command fails)
                              "
                              " Returns a dictionary with one or more of the following key/value pairs:
                              "
                              " - **command** (always available): the generated command line that was used
                              "   to run the external command
                              " - **exit_code** (only in synchronous mode): the exit status of the
                              "   external command (an integer, zero on success)
                              " - **stdout** (only in synchronous mode): the output of the command on the
                              "   standard output stream (a list of strings, one for each line)
                              " - **stderr** (only in synchronous mode): the output of the command on the
                              "   standard error stream (as a list of strings, one for each line)
                              "
                              " [vim-shell]: http://peterodding.com/code/vim/shell/
    1              0.000001   try
                            
                                " Unpack the options.
    1              0.000002     let cmd = a:options['command']
    1              0.000003     let async = get(a:options, 'async', 0)
                            
                                " We need to know in a couple of places whether we are on Windows.
    1   0.000021   0.000007     let is_win = xolox#misc#os#is_win()
                            
                                " Use vim-shell so we don't pop up a console window on Windows? If the
                                " caller specifically asks us *not* to use vim-shell, we'll respect that
                                " choice; this is very useful for automated tests :-).
    1              0.000002     if get(a:options, 'use_dll', 1) == 0
                                  let use_dll = 0
                                else
    1   0.000925   0.000007       let use_dll = xolox#misc#os#can_use_dll()
    1              0.000001     endif
                            
                                " Decide whether to redirect the standard output and standard error
                                " streams to temporary files.
    1              0.000002     let redirect_output = !async && (use_dll || !is_win)
                            
                                " Write the input for the external command to a temporary file?
    1              0.000003     if has_key(a:options, 'stdin') && use_dll
                                  let tempin = tempname()
                                  if type(a:options['stdin']) == type([])
                                    let lines = a:options['stdin']
                                  else
                                    let lines = split(a:options['stdin'], "\n")
                                  endif
                                  call writefile(lines, tempin)
                                  let cmd .= ' < ' . xolox#misc#escape#shell(tempin)
                                endif
                            
                                " Redirect the standard output and/or standard error streams of the
                                " external process to temporary files? (only in synchronous mode)
    1              0.000001     if redirect_output
    1              0.000006       let tempout = tempname()
    1              0.000002       let temperr = tempname()
    1   0.001638   0.001008       let cmd = printf('(%s) 1>%s 2>%s', cmd, xolox#misc#escape#shell(tempout), xolox#misc#escape#shell(temperr))
    1              0.000001     endif
                            
                                " Use vim-shell or system() to execute the external command?
    1              0.000001     if use_dll
                                  call xolox#misc#msg#debug("vim-misc %s: Executing external command using compiled DLL: %s", g:xolox#misc#version, cmd)
                                  let exit_code = xolox#shell#execute_with_dll(cmd, async)
                                else
                            
                                  " Enable asynchronous mode (very platform specific).
    1              0.000001       if async
                                    if is_win
                                      " As pointed out in issue 17 [1] the use of `:!start' on Windows
                                      " requires characters like `!', `%' and `#' to be escaped with a
                                      " backslash [2]. Vim's shellescape() function knows how to escape
                                      " these special characters however the use of `:!start' is an
                                      " implementation detail of xolox#misc#os#exec() so I don't want to
                                      " bother callers (who perform the shell escaping) with such a
                                      " specific implementation detail. This is why I resort to manually
                                      " escaping characters documented to have a special meaning [2].
                                      "
                                      " [1] https://github.com/xolox/vim-misc/issues/17
                                      " [2] All characters interpreted specially in shell command lines
                                      "     executed from Vim's command mode, refer to `:help :!' for
                                      "     details.
                                      let cmd = printf('start /b %s', escape(cmd, "\\\n!%#"))
                                    elseif has('unix')
                                      let cmd = printf('(%s) &', cmd)
                                    else
                                      call xolox#misc#msg#warn("vim-misc %s: I don't know how to execute the command %s asynchronously on your platform! Falling back to synchronous mode...", g:xolox#misc#version, cmd)
                                    endif
                                  endif
                            
                                  " On UNIX we explicitly execute the command line using 'sh' instead of
                                  " the default shell, because we assume that standard output and standard
                                  " error can be redirected separately, but (t)csh does not support this
                                  " (and it might be the default shell).
    1              0.000002       if has('unix')
    1   0.000018   0.000008         call xolox#misc#msg#debug("vim-misc %s: Generated shell expression: %s", g:xolox#misc#version, cmd)
    1   0.000028   0.000005         let cmd = printf('sh -c %s', xolox#misc#escape#shell(cmd))
    1              0.000001       endif
                            
                                  " Let the user know what's happening (in case they're interested).
    1              0.000001       if async && is_win
                                    call xolox#misc#msg#debug("vim-misc %s: Executing external command using !start command: %s", g:xolox#misc#version, cmd)
                                    silent execute '!' . cmd
                                  else
    1   0.000012   0.000005         call xolox#misc#msg#debug("vim-misc %s: Executing external command using system() function: %s", g:xolox#misc#version, cmd)
    1              0.000002         let arguments = [cmd]
    1              0.000002         if has_key(a:options, 'stdin')
                                      if type(a:options['stdin']) == type([])
                                        call add(arguments, join(a:options['stdin'], "\n"))
                                      else
                                        call add(arguments, a:options['stdin'])
                                      endif
                                    endif
    1   0.025481   0.000235         let stdout = call('system', arguments)
    1              0.000009         let exit_code = v:shell_error
    1              0.000002       endif
                            
    1              0.000000     endif
                            
                                " Return the results as a dictionary with one or more key/value pairs.
    1              0.000008     let result = {'command': cmd}
    1              0.000002     if !async
    1              0.000007       let result['exit_code'] = exit_code
                                  " Get the standard output of the command.
    1              0.000002       if redirect_output
    1   0.000099   0.000048         let result['stdout'] = s:readfile(tempout, 'standard output', a:options['command'])
    1              0.000002       elseif exists('stdout')
                                    let result['stdout'] = split(stdout, "\n")
                                  else
                                    let result['stdout'] = []
                                  endif
                                  " Get the standard error of the command.
    1              0.000004       if exists('temperr')
    1   0.000048   0.000009         let result['stderr'] = s:readfile(temperr, 'standard error', a:options['command'])
    1              0.000001       else
                                    let result['stderr'] = []
                                  endif
                                  " If we just executed a synchronous command and the caller didn't
                                  " specifically ask us *not* to check the exit code of the external
                                  " command, we'll do so now. The idea here is that it should be easy
                                  " to 'do the right thing'.
    1              0.000004       if get(a:options, 'check', 1) && exit_code != 0
                                    " Prepare an error message with enough details so the user can investigate.
                                    let msg = printf("vim-misc %s: External command failed with exit code %d!", g:xolox#misc#version, result['exit_code'])
                                    let msg .= printf("\nCommand line: %s", result['command'])
                                    " If the external command reported an error, we'll include it in our message.
                                    if !empty(result['stderr'])
                                      " This is where we would normally expect to find an error message.
                                      let msg .= printf("\nOutput on standard output stream:\n%s", join(result['stderr'], "\n"))
                                    elseif !empty(result['stdout'])
                                      " Exuberant Ctags on Windows XP reports errors on standard output :-x.
                                      let msg .= printf("\nOutput on standard error stream:\n%s", join(result['stdout'], "\n"))
                                    endif
                                    throw msg
                                  endif
    1              0.000001     endif
    1              0.000001     return result
                            
                              finally
                                " Cleanup any temporary files we created.
    4              0.000008     for name in ['tempin', 'tempout', 'temperr']
    3              0.000013       if exists(name)
    2              0.000234         call delete({name})
    2              0.000004       endif
    3              0.000003     endfor
    1              0.000004   endtry
                            

FUNCTION  xolox#misc#path#merge()
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                              " Join a directory pathname and filename into a single pathname.
    2              0.000010   if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
    2              0.000002     if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
                                else
    2              0.000016       let parent = substitute(a:parent, '/\+$', '', '')
    2              0.000009       let child = substitute(a:child, '^/\+', '', '')
    2              0.000004       return parent . '/' . child
                                endif
                              endif
                              return ''

FUNCTION  <SNR>214_NetrwOptionRestore()
Called 58 times
Total time:   0.118081
 Self time:   0.064438

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
   58              0.000221   if !exists("{a:vt}netrw_optionsave")
   19   0.000248   0.000070    call s:RestorePosn(s:netrw_nbcd)
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
   19              0.000018    return
                              endif
   39              0.000131   unlet {a:vt}netrw_optionsave
                            
   39              0.000167   if exists("+acd")
   39              0.000116    if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
   39              0.000083     let curdir = getcwd()
   39              0.000251     let &l:acd = {a:vt}netrw_acdkeep
   39              0.000098     unlet {a:vt}netrw_acdkeep
   39              0.000079     if &l:acd
                                 call s:NetrwLcd(curdir)
                                endif
   39              0.000023    endif
   39              0.000017   endif
   39              0.000383   if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
   39              0.000338   if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
   39              0.000341   if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
   39              0.000390   if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
   39              0.000331   if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
   39              0.000343   if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
   39              0.000345   if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
   39              0.000396   if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
   39              0.000430   if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
   39              0.000412   if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
   39              0.000390   if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
   39              0.000324   if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
   39              0.000367   if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
   39              0.000092   if exists("g:netrw_ffkep") && g:netrw_ffkeep
                               if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
                              endif
   39              0.000366   if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
   39              0.000317   if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
   39              0.000297   if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
   39              0.000358   if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
   39              0.001163   if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
   39              0.000345   if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
   39              0.000341   if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
   39              0.000337   if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
   39              0.000334   if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
   39              0.000293   if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
   39              0.000328   if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
   39              0.000297   if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
   39              0.000298   if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
   39              0.000338   if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
   39              0.000315   if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
   39              0.000080   if has("clipboard")
   39              0.044920    if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
   39              0.000018   endif
                              " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                            "  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
   39              0.001493   if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
   39              0.000498   if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
   39              0.000401   if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
   39              0.000335   if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
   39              0.000233   if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
   39              0.000131   if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory= getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                if !g:netrw_use_noswf
                                 " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                 sil! let &l:swf= {a:vt}netrw_swfkeep
                                endif
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
   39   0.002813   0.000848   if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
   39              0.000313    let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   39              0.000118    if exists("{a:vt}netrw_dirkeep")
   39   0.004165   0.000251     call s:NetrwLcd(dirkeep)
   39              0.000100     unlet {a:vt}netrw_dirkeep
   39              0.000020    endif
   39              0.000016   endif
   39              0.000089   if has("clipboard")
   39              0.000205    if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
   39              0.000013   endif
   39              0.000305   if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
   39   0.000778   0.000223   call s:RestorePosn(s:netrw_nbcd)
                            
                            "  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
   39              0.000127   if &ft != "netrw"
                            "   call Decho("filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
    1   0.047035   0.000004    filetype detect
    1              0.000000   endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  <SNR>209_on_stderr_vim()
Called 2 times
Total time:   0.000788
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000787   0.000020   call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))

FUNCTION  xolox#session#locking_enabled()
Called 3 times
Total time:   0.000102
 Self time:   0.000032

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    3   0.000090   0.000020   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  xolox#misc#option#get()
Called 6 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    6              0.000027   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    5              0.000006     return a:1
                              endif

FUNCTION  <SNR>182_flush_session()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007   let s:session_last_flushed = localtime()

FUNCTION  <SNR>214_NetrwBookHistSave()
Called 1 time
Total time:   0.002830
 Self time:   0.001949

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
    1              0.000009   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
                               return
                              endif
                            
    1   0.000157   0.000010   let savefile= s:NetrwHome()."/.netrwhist"
    1              0.000133   1split
    1   0.000746   0.000012   call s:NetrwEnew()
    1              0.000001   if g:netrw_use_noswf
    1              0.000060    setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
    1              0.000001   else
                               setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000
                              endif
    1              0.000024   setl nocin noai noci magic nospell nohid wig= noaw
    1              0.000006   setl ma noro write
    1              0.000007   if exists("+acd") | setl noacd | endif
    1              0.000009   sil! NetrwKeepj keepalt %d _
                            
                              " save .netrwhist -- no attempt to merge
    1              0.000102   sil! keepalt file .netrwhist
    1              0.000013   call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
    1              0.000005   call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
    1              0.000003   let lastline = line("$")
    1              0.000001   let cnt      = 1
    5              0.000007   while cnt <= g:netrw_dirhist_cnt
    4              0.000024    call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
    4              0.000004    let cnt= cnt + 1
    4              0.000004   endwhile
    1              0.001031   exe "sil! w! ".savefile
                            
    1              0.000019   sil NetrwKeepj %d _
    1              0.000006   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
                               " merge and write .netrwbook
                               let savefile= s:NetrwHome()."/.netrwbook"
                            
                               if filereadable(s:NetrwFile(savefile))
                                let booklist= deepcopy(g:netrw_bookmarklist)
                                exe "sil NetrwKeepj keepalt so ".savefile
                                for bdm in booklist
                                 if index(g:netrw_bookmarklist,bdm) == -1
                                  call add(g:netrw_bookmarklist,bdm)
                                 endif
                                endfor
                                call sort(g:netrw_bookmarklist)
                               endif
                            
                               " construct and save .netrwbook
                               call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
                               exe "sil! w! ".savefile
                              endif
    1              0.000004   let bgone= bufnr("%")
    1              0.000089   q!
    1              0.000317   exe "keepalt ".bgone."bwipe!"
                            
                            "  call Dret("s:NetrwBookHistSave")

FUNCTION  xolox#session#save_qflist()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                              " Save the contents of the quick-fix list. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
    1              0.000003   if has('quickfix')
    1              0.000001     let qf_list = []
    1              0.000003     for qf_entry in getqflist()
                                  if has_key(qf_entry, 'bufnr')
                                    if !has_key(qf_entry, 'filename')
                                      let qf_entry.filename = bufname(qf_entry.bufnr)
                                    endif
                                    unlet qf_entry.bufnr
                                  endif
                                  call add(qf_list, qf_entry)
                                endfor
    1              0.000005     call add(a:commands, 'call setqflist(' . string(qf_list) . ')')
    1              0.000001   endif

FUNCTION  ale#linter#GetExecutable()
Called 26 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   26              0.000172     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  <SNR>214_NetrwFile()
Called 470 times
Total time:   0.020914
 Self time:   0.020914

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
                            "  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            
                              " clean up any leading treedepthstring
  470              0.001657   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
                            "   call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
                              else
  470              0.000652    let fname= a:fname
  470              0.000257   endif
                            
  470              0.000450   if g:netrw_keepdir
                               " vim's idea of the current directory possibly may differ from netrw's
  470              0.001106    if !exists("b:netrw_curdir")
    9              0.000023     let b:netrw_curdir= getcwd()
    9              0.000004    endif
                            
  470              0.001927    if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                                if fname =~ '^\' || fname =~ '^\a:\'
                                 " windows, but full path given
                                 let ret= fname
                            "     call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                else
                                 " windows, relative path given
                                 let ret= s:ComposePath(b:netrw_curdir,fname)
                            "     call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                endif
                            
                               elseif fname =~ '^/'
                                " not windows, full path given
  470              0.000619     let ret= fname
                            "    call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
  470              0.000281    else
                                " not windows, relative path given
                                let ret= s:ComposePath(b:netrw_curdir,fname)
                            "    call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               endif
  470              0.000208   else
                               " vim and netrw agree on the current directory
                               let ret= fname
                            "   call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
                            "   call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
                            "   call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
                              endif
                            
                            "  call Dret("s:NetrwFile ".ret)
  470              0.000493   return ret

FUNCTION  xolox#misc#os#can_use_dll()
Called 1 time
Total time:   0.000918
 Self time:   0.000918

count  total (s)   self (s)
                              " If a) we're on Microsoft Windows, b) the vim-shell plug-in is installed
                              " and c) the compiled DLL included in vim-shell works, we can use the
                              " vim-shell plug-in to execute external commands! Returns 1 (true)
                              " if we can use the DLL, 0 (false) otherwise.
    1              0.000001   let can_use_dll = 0
    1              0.000001   try
    1              0.000896     let can_use_dll = xolox#shell#can_use_dll()
                              catch /^Vim\%((\a\+)\)\=:E117/
                                " Silence E117.
    1              0.000001   endtry
    1              0.000002   return can_use_dll

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 52 times
Total time:   0.014400
 Self time:   0.001821

count  total (s)   self (s)
   52              0.000303   if getbufvar(a:bufnr, '&modified')
    8              0.000084     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000005   else
   44              0.000456     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   44              0.000032   endif
                            
   52              0.000087   if !empty(colors)
   52   0.013063   0.000484     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   52              0.000029   endif

FUNCTION  anzu#clear_search_cache()
Called 28 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   28              0.000140 	let bufnr = get(a:, 1, bufnr("%"))
   28              0.000155 	call setbufvar(bufnr, "anzu_searchpos_cache", {})

FUNCTION  airline#extensions#branch#get_head()
Called 647 times
Total time:   0.361955
 Self time:   0.014054

count  total (s)   self (s)
  647   0.351012   0.003111   let head = airline#extensions#branch#head()
  647              0.002575   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
  647              0.002696   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  647              0.004765   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>159_reset_untracked_cache()
Called 2 times
Total time:   0.000489
 Self time:   0.000370

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    2              0.000010   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    2              0.000072   let file = expand("%:p")
    6              0.000015   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    4   0.000143   0.000024     call airline#extensions#branch#update_untracked_config(file, vcs)
    4              0.000207     let s:vcs_config[vcs].untracked = {}
    4              0.000004   endfor

FUNCTION  xolox#session#save_special_windows()
Called 1 time
Total time:   0.000469
 Self time:   0.000077

count  total (s)   self (s)
                              " Implements support for buffers with content that was generated by other
                              " Vim plug-ins. The first argument is expected to be a list, it will be
                              " extended with the lines to be added to the session script.
    1              0.000003   let tabpage = tabpagenr()
    1              0.000002   let window = winnr()
    1              0.000002   let s:nerdtrees = {}
    1              0.000003   call add(a:session, '')
    1              0.000003   call add(a:session, '" Support for special windows like quick-fix and plug-in windows.')
    1              0.000003   call add(a:session, '" Everything down here is generated by vim-session (not supported')
    1              0.000002   call add(a:session, '" by :mksession out of the box).')
    1              0.000002   call add(a:session, '')
    1              0.000001   try
    1   0.000143   0.000008     if xolox#session#include_tabs()
    1   0.000147   0.000018       tabdo call s:check_special_tabpage(a:session)
    1              0.000001     else
                                  call s:check_special_tabpage(a:session)
                                endif
    1              0.000002   finally
    1              0.000002     unlet s:nerdtrees
    1              0.000004     execute 'tabnext' tabpage
    1              0.000003     execute window . 'wincmd w'
    1   0.000137   0.000009     call s:jump_to_window(a:session, tabpage, window)
    1              0.000001   endtry

FUNCTION  airline#extensions#ctrlp#apply()
Called 28 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
   28              0.000269   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  indent_guides#process_autocmds()
Called 109 times
Total time:   0.006119
 Self time:   0.001391

count  total (s)   self (s)
  109              0.000268   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
  109   0.005240   0.000512     call indent_guides#disable()
  109              0.000057   end

FUNCTION  ale#sign#ReadSigns()
Called 35 times
Total time:   0.000983
 Self time:   0.000983

count  total (s)   self (s)
   35              0.000136     redir => l:output
   35              0.000409        silent execute 'sign place buffer=' . a:buffer
   35              0.000107     redir end
                            
   35              0.000282     return split(l:output, "\n")

FUNCTION  <SNR>135_ALELintImpl()
Called 26 times
Total time:   0.056049
 Self time:   0.001744

count  total (s)   self (s)
   26   0.004138   0.000127     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
   26   0.007897   0.000264     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
   26              0.000049     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
   26              0.000111     if has_key(s:should_lint_file_for_buffer, a:buffer)
   17              0.000041         unlet s:should_lint_file_for_buffer[a:buffer]
                                    " Lint files if they exist.
   17              0.000597         let l:should_lint_file = filereadable(expand('#' . a:buffer . ':p'))
   17              0.000014     endif
                            
   26   0.042948   0.000287     call ale#engine#RunLinters(a:buffer, l:linters, l:should_lint_file)

FUNCTION  <SNR>218_GetCounts()
Called 936 times
Total time:   0.017795
 Self time:   0.017396

count  total (s)   self (s)
  936              0.004832     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
    2   0.000032   0.000012         return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  934              0.002847     if !has_key(g:ale_buffer_info[a:buffer], 'count')
    2   0.000531   0.000152         call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
    2              0.000002     endif
                            
  934              0.001822     return g:ale_buffer_info[a:buffer].count

FUNCTION  airline#extensions#hunks#get_hunks()
Called 468 times
Total time:   0.074027
 Self time:   0.038409

count  total (s)   self (s)
  468              0.001380   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  468              0.007118   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  468   0.037728   0.002110   let hunks = s:get_hunks()
  468              0.000517   let string = ''
  468              0.000814   if !empty(hunks)
 1836              0.002513     for i in [0, 1, 2]
 1377              0.003713       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
 1377              0.007459         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 1377              0.000818       endif
 1377              0.001752     endfor
  459              0.000307   endif
  468              0.000903   let b:airline_hunks = string
  468              0.001045   let b:airline_changenr = b:changedtick
  468              0.000971   let s:airline_winwidth = winwidth(0)
  468              0.000492   return string

FUNCTION  <SNR>45_winshell()
Called 289 times
Total time:   0.001656
 Self time:   0.001656

count  total (s)   self (s)
  289              0.001552   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>189_coerce_argument()
Called 4 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                              " Callback to coerce printf() arguments into strings.
    4              0.000009   let value_type = type(a:value)
    4              0.000010   if value_type != type(0) && value_type != type('')
                                return string(a:value)
                              else
    4              0.000004     return a:value
                              endif

FUNCTION  <SNR>214_NetrwHome()
Called 2 times
Total time:   0.000447
 Self time:   0.000262

count  total (s)   self (s)
    2              0.000007   if exists("g:netrw_home")
    1              0.000002    let home= g:netrw_home
    1              0.000000   else
                               " go to vim plugin home
    1              0.000068    for home in split(&rtp,',') + ['']
    1   0.000129   0.000045     if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                 if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
    1              0.000001    if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
    1              0.000008    if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
    1              0.000001   endif
                              " insure that the home directory exists
    2   0.000138   0.000037   if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
                               if exists("g:netrw_mkdir")
                                call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
                               else
                                call mkdir(home)
                               endif
                              endif
    2              0.000007   let g:netrw_home= home
    2              0.000001   return home

FUNCTION  ale#engine#IsExecutable()
Called 26 times
Total time:   0.004310
 Self time:   0.003478

count  total (s)   self (s)
   26              0.000063     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   26              0.000141     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   26              0.000053     if l:result isnot v:null
                                    return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
   26              0.002400     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
   26              0.000059     if l:result || g:ale_cache_executable_check_failures
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
   26              0.000036     if g:ale_history_enabled
   26   0.001096   0.000264         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   26              0.000021     endif
                            
   26              0.000032     return l:result

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 22 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   22              0.000111   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>171_should_change_group()
Called 276 times
Total time:   0.066780
 Self time:   0.004764

count  total (s)   self (s)
  276              0.000467   if a:group1 == a:group2
                                return 0
                              endif
  276   0.033064   0.001289   let color1 = airline#highlighter#get_highlight(a:group1)
  276   0.031368   0.001127   let color2 = airline#highlighter#get_highlight(a:group2)
  276              0.000386   if g:airline_gui_mode ==# 'gui'
  276              0.000797     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>45_buffer()
Called 195 times
Total time:   0.004947
 Self time:   0.004264

count  total (s)   self (s)
  195              0.000881   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
  195              0.001966   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
  195   0.001695   0.001012   if buffer.getvar('git_dir') !=# ''
  195              0.000170     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>186_StopCurrentJobs()
Called 35 times
Total time:   0.002113
 Self time:   0.002113

count  total (s)   self (s)
   35              0.000180     let l:info = get(g:ale_buffer_info, a:buffer, {})
   35              0.000067     let l:new_job_list = []
   35              0.000065     let l:new_active_linter_list = []
                            
   35              0.000291     for l:job_id in get(l:info, 'job_list', [])
                                    let l:job_info = get(s:job_info_map, l:job_id, {})
                            
                                    if !empty(l:job_info)
                                        if a:include_lint_file_jobs || !l:job_info.linter.lint_file
                                            call ale#job#Stop(l:job_id)
                                            call remove(s:job_info_map, l:job_id)
                                        else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
                                    endif
                                endfor
                            
                                " Remove duplicates from the active linter list.
   35              0.000142     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
   35              0.000343     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
   35              0.000092     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  <SNR>152_sync_active_winnr()
Called 491 times
Total time:   0.004332
 Self time:   0.004332

count  total (s)   self (s)
  491              0.002638   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  <SNR>117_YRHistoryRead()
Called 6 times
Total time:   0.000417
 Self time:   0.000417

count  total (s)   self (s)
    6              0.000008     let refresh_needed  = 1
    6              0.000009     let yr_history_list = []
    6              0.000023     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    6              0.000214     if filereadable(yr_filename)
    6              0.000056         let last_upd = getftime(yr_filename)
                            
    6              0.000015         if s:yr_history_last_upd != 0 && last_upd <= s:yr_history_last_upd
    6              0.000008             let refresh_needed = 0
    6              0.000006         endif
                            
    6              0.000007         if refresh_needed == 1
                                        let s:yr_history_list = readfile(yr_filename)
                                        let s:yr_history_last_upd = last_upd
                                        let s:yr_count = len(s:yr_history_list)
                                        return
                                    else
    6              0.000005             return
                                    endif
                                else
                                    if s:yr_history_version == 'v2'
                                        " Check to see if an upgrade is required
                                        " else, let the empty yr_history_list be returned.
                                        if filereadable(s:yr_history_file_v1)
                                            " Perform upgrade to v2 of the history file
                                            call s:YRHistoryUpgrade('v1')
                                            return
                                        endif
                                    endif
                                endif
                            
                                let s:yr_history_list = yr_history_list
                                call s:YRHistorySave()
                            

FUNCTION  <SNR>60_chop()
Called 9 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
    9              0.000075 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    9              0.000012 	retu a:mrufs

FUNCTION  gitgutter#diff#is_removed()
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000007   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 493 times
Total time:   0.035764
 Self time:   0.019442

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  493              0.001530     if mode() isnot# 'n'
    1              0.000001         return
                                endif
                            
  492   0.006333   0.002485     call s:StopCursorTimer()
                            
  492              0.002465     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  492              0.001075     if l:pos != s:last_pos
  484   0.015574   0.003100         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
  484              0.001283         let s:last_pos = l:pos
  484              0.002767         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  484              0.000316     endif

FUNCTION  <SNR>214_NetrwGlob()
Called 36 times
Total time:   0.012409
 Self time:   0.009507

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGlob(direntry<".a:direntry."> expr<".a:expr."> pare=".a:pare.")")
   36   0.000553   0.000145   if netrw#CheckIfRemote()
                               keepalt 1sp
                               keepalt enew
                               let keep_liststyle    = w:netrw_liststyle
                               let w:netrw_liststyle = s:THINLIST
                               if s:NetrwRemoteListing() == 0
                                keepj keepalt %s@/@@
                                let filelist= getline(1,$)
                                q!
                               else
                                " remote listing error -- leave treedict unchanged
                                let filelist= w:netrw_treedict[a:direntry]
                               endif
                               let w:netrw_liststyle= keep_liststyle
                              elseif v:version > 704 || (v:version == 704 && has("patch656"))
   36   0.010676   0.008182    let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1,1)
   36              0.000060    if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
                               endif
   36              0.000034   else
                               let filelist= glob(s:ComposePath(fnameescape(a:direntry),a:expr),0,1)
                               if a:pare
                                let filelist= map(filelist,'substitute(v:val, "^.*/", "", "")')
                               endif
                              endif
                            "  call Dret("s:NetrwGlob ".string(filelist))
   36              0.000036   return filelist

FUNCTION  <SNR>214_NetrwSafeOptions()
Called 35 times
Total time:   0.493123
 Self time:   0.007661

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
                            "  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
   35              0.000366   if exists("+acd") | setl noacd | endif
   35              0.000126   setl noai
   35              0.000109   setl noaw
   35              0.000106   setl nobl
   35              0.000077   setl nobomb
   35              0.000206   setl bt=nofile
   35              0.000119   setl noci
   35              0.000102   setl nocin
   35              0.000144   setl bh=hide
   35              0.000144   setl cino=
   35              0.000173   setl com=
   35              0.000190   setl cpo-=a
   35              0.000137   setl cpo-=A
   35              0.000140   setl fo=nroql2
   35              0.000104   setl nohid
   35              0.000099   setl noim
   35              0.002526   setl isk+=@ isk+=* isk+=/
   35              0.000067   setl magic
   35              0.000051   if g:netrw_use_noswf
   35              0.000116    setl noswf
   35              0.000018   endif
   35              0.000108   setl report=10000
   35              0.000117   setl sel=inclusive
   35              0.000066   setl nospell
   35              0.000894   setl tw=0
   35              0.000123   setl wig=
   35              0.000101   setl cedit&
   35   0.001992   0.000280   call s:NetrwCursor()
                            
                              " allow the user to override safe options
                            "  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
   35              0.000095   if &ft == "netrw"
                            "   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
   35   0.484172   0.000422    sil! keepalt NetrwKeepj doau FileType netrw
   35              0.000022   endif
                            
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwSafeOptions")

FUNCTION  gitgutter#handle_diff()
Called 22 times
Total time:   0.015019
 Self time:   0.001249

count  total (s)   self (s)
   22   0.000938   0.000139   call gitgutter#debug#log(a:diff)
                            
   22   0.000632   0.000138   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'tracked', 1)
                            
   22   0.002439   0.000281   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
   22   0.001398   0.000162   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
   22              0.000049   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
   22              0.000032   if g:gitgutter_signs || g:gitgutter_highlight_lines
   22   0.008890   0.000152     call gitgutter#sign#update_signs(modified_lines)
   22              0.000009   endif
                            
   22   0.000429   0.000084   call gitgutter#utility#save_last_seen_change()

FUNCTION  delimitMate#Set()
Called 1702 times
Total time:   0.042425
 Self time:   0.007561

count  total (s)   self (s)
 1702   0.041988   0.007124   return call('s:set', a:000)

FUNCTION  <SNR>205_FixList()
Called 31 times
Total time:   0.001790
 Self time:   0.001015

count  total (s)   self (s)
   31   0.000974   0.000199     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
   31              0.000060     let l:new_list = []
                            
   31              0.000071     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
   31              0.000047     return l:new_list

FUNCTION  YRRecord()
Called 2 times
Total time:   0.002083
 Self time:   0.000928

count  total (s)   self (s)
                            
    2              0.000005     let register = '"'
    2              0.000002     if a:0 > 0
                                    " If no yank command has been supplied, assume it is
                                    " a full line yank
    2              0.000006         let register = ((a:1 == '') ? register : a:1)
    2              0.000002     endif
                            
                                " v:register can be blank in some (unknown) cases
                                " if v:register == '' || v:register == '_'
    2              0.000002     if v:register == '_'
                                    " Black hole register, ignore recording the operation
                                    return ""
                                endif
                            
    2              0.000023     let register = ((&clipboard=~'\<unnamed\>')?'*':((&clipboard=~'\<unnamedplus\>' && has('unnamedplus'))?'+':register))
                            
                                " let s:yr_prev_changenr    = changenr()
    2              0.000003     if register == '"'
                                    " If the change has occurred via an omap, we must delay
                                    " the capture of the default register until this event
                                    " since register updates are not reflected until the
                                    " omap function completes
    2              0.000016         let s:yr_prev_reg_unnamed = getreg('"')
    2              0.000006         let s:yr_prev_reg_small   = getreg('-')
    2              0.000002     endif
                            
                                " Add item to list
                                " This will also account for duplicates.
    2   0.001149   0.000029     call s:YRMRUAdd( 's:yr_history_list' , getreg(register) , getregtype(register) )
                            
    2              0.000003     if g:yankring_clipboard_monitor == 1
    2              0.000587         let s:yr_prev_clipboard_plus = getreg('+')
    2              0.000160         let s:yr_prev_clipboard_star = getreg('*')
    2              0.000003     endif
                            
                                " Manage the numbered registers
    2              0.000005     if g:yankring_manage_numbered_reg == 1
                                    " Allow the user to define an autocmd to dynamically
                                    " setup their connection information.
                                    silent! doautocmd User YRSetNumberedReg
                                endif
                            
                                " If the yankring window is open, refresh it
    2   0.000053   0.000018     call s:YRWindowUpdate()
                            
                                " Reset the past paste entry to the top of the ring.
                                " When the user hits replace last entry it should
                                " start from the top (not from the last previous
                                " replace) after capturing a new value in the YankRing.
    2              0.000004     let s:yr_last_paste_idx = 1
                            
    2              0.000002     return ""

FUNCTION  netrw#LocalBrowseCheck()
Called 25 times
Total time:   0.981751
 Self time:   0.001694

count  total (s)   self (s)
                              " This function is called by netrwPlugin.vim's s:LocalBrowse(), s:NetrwRexplore(), and by <cr> when atop listed file/directory
                              " unfortunate interaction -- split window debugging can't be
                              " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
                              " event triggers another call to LocalBrowseCheck() when attempts
                              " to write to the DBG buffer are made.
                              " The &ft == "netrw" test was installed because the BufEnter event
                              " would hit when re-entering netrw windows, creating unexpected
                              " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
                            "  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
                            "  call Decho("isdir<".a:dirname."> =".isdirectory(s:NetrwFile(a:dirname)).((exists("s:treeforceredraw")? " treeforceredraw" : "")).'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Dredir("ls!","ls!")
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "  call Decho("current buffer#".bufnr("%")."<".bufname("%")."> ft=".&ft,'~'.expand("<slnum>"))
                            
   25              0.000086   let ykeep= @@
   25   0.001759   0.000523   if isdirectory(s:NetrwFile(a:dirname))
                            "   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse,'~'.expand("<slnum>"))
                            
   18              0.000115    if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
                            "    call Decho("case 1 : ft=".&ft,'~'.expand("<slnum>"))
                            "    call Decho("s:rexposn_".bufnr("%")."<".bufname("%")."> ".(exists("s:rexposn_".bufnr("%"))? "exists" : "does not exist"),'~'.expand("<slnum>"))
   18   0.979109   0.000288     sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
   18              0.000031    elseif &ft == "netrw" && line("$") == 1
                            "    call Decho("case 2 (ft≡netrw && line($)≡1)",'~'.expand("<slnum>"))
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                            
                               elseif exists("s:treeforceredraw")
                            "    call Decho("case 3 (treeforceredraw)",'~'.expand("<slnum>"))
                                unlet s:treeforceredraw
                                sil! NetrwKeepj keepalt call s:NetrwBrowse(1,a:dirname)
                               endif
                            "   call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                            "   call Dret("netrw#LocalBrowseCheck")
   18              0.000012    return
                              endif
                            
                              " following code wipes out currently unused netrw buffers
                              "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
                              "   AND IF the listing style is not a tree listing
    7              0.000022   if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
                            "   call Decho("wiping out currently unused netrw buffers",'~'.expand("<slnum>"))
                               let ibuf    = 1
                               let buflast = bufnr("$")
                               while ibuf <= buflast
                                if bufwinnr(ibuf) == -1 && isdirectory(s:NetrwFile(bufname(ibuf)))
                                 exe "sil! keepj keepalt ".ibuf."bw!"
                                endif
                                let ibuf= ibuf + 1
                               endwhile
                              endif
    7              0.000014   let @@= ykeep
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
                            "  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
                              " not a directory, ignore it
                            "  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")

FUNCTION  <SNR>109_ExtraMappings()
Called 74 times
Total time:   0.028282
 Self time:   0.022934

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
   74              0.001180   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
   74              0.001356   if !hasmapto('<Plug>delimitMateBS','i')
   74              0.000811     if empty(maparg('<BS>', 'i'))
   74              0.000926       silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
   74              0.000043     endif
   74              0.000794     if empty(maparg('<C-H>', 'i'))
   74              0.000830       silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
   74              0.000033     endif
   74              0.000038   endif
                              " If pair is empty, delete closing delimiter:
   74              0.001178   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
   74              0.001923   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
   74              0.000897     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
   74              0.000042   endif
                              " Expand return if inside an empty pair:
   74              0.001230   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
   74   0.002234   0.000412   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
   74              0.001373   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
   74   0.002308   0.000397   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
   74              0.001348   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
   74   0.003905   0.002290   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
   74              0.000939     silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
   74              0.000037   endif
                              " Jump over next delimiters
   74              0.001224   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
   74              0.001885   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
   74              0.000911     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
   74              0.000042   endif

FUNCTION  xolox#misc#option#split()
Called 8 times
Total time:   0.000858
 Self time:   0.000539

count  total (s)   self (s)
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
    8              0.000196   let values = split(a:value, '[^\\]\zs,')
    8   0.000559   0.000240   return map(values, 's:unescape(v:val)')

FUNCTION  airline#extensions#ale#get_warning()
Called 468 times
Total time:   0.043625
 Self time:   0.003210

count  total (s)   self (s)
  468   0.043359   0.002944   return airline#extensions#ale#get('warning')

FUNCTION  gitgutter#hunk#set_hunks()
Called 22 times
Total time:   0.001137
 Self time:   0.000313

count  total (s)   self (s)
   22   0.000414   0.000148   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', a:hunks)
   22   0.000645   0.000087   call s:reset_summary()

FUNCTION  <SNR>117_YRRegister()
Called 7 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
                                " v:register can be blank in some (unknown) cases
                                " so test for this condition and return the
                                " default register
    7              0.000046     let user_register = ((v:register=='')?('"'):(v:register))
    7              0.000057     if &clipboard =~ '\<unnamed\>' && user_register == '"'
                                    let user_register = '*'
                                endif
    7              0.000036     if has('unnamedplus') && &clipboard =~ '\<unnamedplus\>' && user_register == '"'
                                    let user_register = '+'
                                endif
    7              0.000009     return user_register

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  770   1.110935   0.069459  airline#check_mode()
   52   1.027076   0.123878  airline#highlighter#highlight()
   17   1.019594   0.016419  <SNR>214_NetrwBrowseChgDir()
   25   0.981751   0.001694  netrw#LocalBrowseCheck()
   18   0.978821   0.007359  <SNR>214_NetrwBrowse()
 4211   0.817847   0.222333  airline#highlighter#exec()
   18   0.787579   0.009916  <SNR>214_PerformListing()
 6679   0.725745   0.305802  airline#highlighter#get_highlight()
   35   0.493123   0.007661  <SNR>214_NetrwSafeOptions()
   33   0.435474   0.002938  <SNR>142_LocalBrowse()
  958   0.434450   0.031712  <SNR>167_exec_separator()
  110   0.374999   0.005612  <SNR>39_on_window_changed()
13358   0.372322             <SNR>167_get_syn()
   46   0.369219   0.004794  airline#update_statusline()
   82   0.364075   0.003292  <SNR>154_invoke_funcrefs()
  647   0.361955   0.014054  airline#extensions#branch#get_head()
  647   0.347901   0.017311  airline#extensions#branch#head()
   62   0.336931   0.129240  <SNR>3_SynSet()
  661   0.327530   0.029756  ale#CallWithCooldown()
   82   0.311524   0.042486  22()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
13358              0.372322  <SNR>167_get_syn()
 6679   0.725745   0.305802  airline#highlighter#get_highlight()
   13   0.293348   0.237307  <SNR>43_ShowMarks()
   62   0.229226   0.224184  <SNR>24_LoadFTPlugin()
 4211   0.817847   0.222333  airline#highlighter#exec()
   62   0.336931   0.129240  <SNR>3_SynSet()
   52   1.027076   0.123878  airline#highlighter#highlight()
 4211              0.083541  <SNR>167_CheckDefined()
  647   0.251840   0.073275  <SNR>159_update_branch()
  770   1.110935   0.069459  airline#check_mode()
   58   0.118081   0.064438  <SNR>214_NetrwOptionRestore()
 2056              0.058820  ale#Var()
  657   0.118215   0.058336  ale#ShouldDoNothing()
  468   0.066586   0.051802  airline#extensions#whitespace#check()
 3993              0.050179  <SNR>167_hl_group_exists()
  538              0.049526  <SNR>141_Highlight_Matching_Pair()
  151              0.047984  RailsDetect()
 6679              0.047621  <SNR>167_get_array()
  647   0.075644   0.047364  <SNR>159_update_untracked()
   18   0.076012   0.046435  <SNR>214_LocalListing()

